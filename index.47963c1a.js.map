{"mappings":"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","sources":["<anon>","src/app.ts","node_modules/chess.js/dist/esm/chess.js","node_modules/chess.js/src/chess.ts","node_modules/chessground/dist/chessground.js","node_modules/chessground/src/chessground.ts","node_modules/chessground/dist/api.js","node_modules/chessground/src/api.ts","node_modules/chessground/dist/board.js","node_modules/chessground/src/board.ts","node_modules/chessground/dist/util.js","node_modules/chessground/src/util.ts","node_modules/chessground/dist/types.js","node_modules/chessground/src/types.ts","node_modules/chessground/dist/premove.js","node_modules/chessground/src/premove.ts","node_modules/chessground/dist/fen.js","node_modules/chessground/src/fen.ts","node_modules/chessground/dist/config.js","node_modules/chessground/src/config.ts","node_modules/chessground/dist/anim.js","node_modules/chessground/src/anim.ts","node_modules/chessground/dist/drag.js","node_modules/chessground/src/drag.ts","node_modules/chessground/dist/draw.js","node_modules/chessground/src/draw.ts","node_modules/chessground/dist/explosion.js","node_modules/chessground/src/explosion.ts","node_modules/chessground/dist/state.js","node_modules/chessground/src/state.ts","node_modules/chessground/dist/wrap.js","node_modules/chessground/src/wrap.ts","node_modules/chessground/dist/svg.js","node_modules/chessground/src/svg.ts","node_modules/chessground/dist/events.js","node_modules/chessground/src/events.ts","node_modules/chessground/dist/drop.js","node_modules/chessground/src/drop.ts","node_modules/chessground/dist/render.js","node_modules/chessground/src/render.ts","node_modules/chessground/dist/autoPieces.js","node_modules/chessground/src/autoPieces.ts","node_modules/chessground/dist/sync.js","node_modules/chessground/src/sync.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */ const $e1e1f1f3cd154daa$export$29814851e0aa981f = 'w';\nconst $e1e1f1f3cd154daa$export$7a91b0fde7ec420f = 'b';\nconst $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0 = 'p';\nconst $e1e1f1f3cd154daa$export$ce32bc8c2a29bae6 = 'n';\nconst $e1e1f1f3cd154daa$export$54a167f801c5dba3 = 'b';\nconst $e1e1f1f3cd154daa$export$68d4c913908dc245 = 'r';\nconst $e1e1f1f3cd154daa$export$36a8946792f13ec9 = 'q';\nconst $e1e1f1f3cd154daa$export$42387107bb0d6206 = 'k';\nconst $e1e1f1f3cd154daa$export$1264a6620073cfaa = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nclass $e1e1f1f3cd154daa$export$e49a5ad3dd6df925 {\n    color;\n    from;\n    to;\n    piece;\n    captured;\n    promotion;\n    /**\n     * @deprecated This field is deprecated and will be removed in version 2.0.0.\n     * Please use move descriptor functions instead: `isCapture`, `isPromotion`,\n     * `isEnPassant`, `isKingsideCastle`, `isQueensideCastle`, `isCastle`, and\n     * `isBigPawn`\n     */ flags;\n    san;\n    lan;\n    before;\n    after;\n    constructor(chess, internal){\n        const { color: color, piece: piece, from: from, to: to, flags: flags, captured: captured, promotion: promotion } = internal;\n        const fromAlgebraic = $e1e1f1f3cd154daa$var$algebraic(from);\n        const toAlgebraic = $e1e1f1f3cd154daa$var$algebraic(to);\n        this.color = color;\n        this.piece = piece;\n        this.from = fromAlgebraic;\n        this.to = toAlgebraic;\n        /*\n         * HACK: The chess['_method']() calls below invoke private methods in the\n         * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\n         * code cleaner elsewhere.\n         */ this.san = chess['_moveToSan'](internal, chess['_moves']({\n            legal: true\n        }));\n        this.lan = fromAlgebraic + toAlgebraic;\n        this.before = chess.fen();\n        // Generate the FEN for the 'after' key\n        chess['_makeMove'](internal);\n        this.after = chess.fen();\n        chess['_undoMove']();\n        // Build the text representation of the move flags\n        this.flags = '';\n        for(const flag in $e1e1f1f3cd154daa$var$BITS)if ($e1e1f1f3cd154daa$var$BITS[flag] & flags) this.flags += $e1e1f1f3cd154daa$var$FLAGS[flag];\n        if (captured) this.captured = captured;\n        if (promotion) {\n            this.promotion = promotion;\n            this.lan += promotion;\n        }\n    }\n    isCapture() {\n        return this.flags.indexOf($e1e1f1f3cd154daa$var$FLAGS['CAPTURE']) > -1;\n    }\n    isPromotion() {\n        return this.flags.indexOf($e1e1f1f3cd154daa$var$FLAGS['PROMOTION']) > -1;\n    }\n    isEnPassant() {\n        return this.flags.indexOf($e1e1f1f3cd154daa$var$FLAGS['EP_CAPTURE']) > -1;\n    }\n    isKingsideCastle() {\n        return this.flags.indexOf($e1e1f1f3cd154daa$var$FLAGS['KSIDE_CASTLE']) > -1;\n    }\n    isQueensideCastle() {\n        return this.flags.indexOf($e1e1f1f3cd154daa$var$FLAGS['QSIDE_CASTLE']) > -1;\n    }\n    isBigPawn() {\n        return this.flags.indexOf($e1e1f1f3cd154daa$var$FLAGS['BIG_PAWN']) > -1;\n    }\n}\nconst $e1e1f1f3cd154daa$var$EMPTY = -1;\nconst $e1e1f1f3cd154daa$var$FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q'\n};\nconst $e1e1f1f3cd154daa$export$5fc67852ab417150 = [\n    'a8',\n    'b8',\n    'c8',\n    'd8',\n    'e8',\n    'f8',\n    'g8',\n    'h8',\n    'a7',\n    'b7',\n    'c7',\n    'd7',\n    'e7',\n    'f7',\n    'g7',\n    'h7',\n    'a6',\n    'b6',\n    'c6',\n    'd6',\n    'e6',\n    'f6',\n    'g6',\n    'h6',\n    'a5',\n    'b5',\n    'c5',\n    'd5',\n    'e5',\n    'f5',\n    'g5',\n    'h5',\n    'a4',\n    'b4',\n    'c4',\n    'd4',\n    'e4',\n    'f4',\n    'g4',\n    'h4',\n    'a3',\n    'b3',\n    'c3',\n    'd3',\n    'e3',\n    'f3',\n    'g3',\n    'h3',\n    'a2',\n    'b2',\n    'c2',\n    'd2',\n    'e2',\n    'f2',\n    'g2',\n    'h2',\n    'a1',\n    'b1',\n    'c1',\n    'd1',\n    'e1',\n    'f1',\n    'g1',\n    'h1'\n];\nconst $e1e1f1f3cd154daa$var$BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */ // prettier-ignore\n// eslint-disable-next-line\nconst $e1e1f1f3cd154daa$var$Ox88 = {\n    a8: 0,\n    b8: 1,\n    c8: 2,\n    d8: 3,\n    e8: 4,\n    f8: 5,\n    g8: 6,\n    h8: 7,\n    a7: 16,\n    b7: 17,\n    c7: 18,\n    d7: 19,\n    e7: 20,\n    f7: 21,\n    g7: 22,\n    h7: 23,\n    a6: 32,\n    b6: 33,\n    c6: 34,\n    d6: 35,\n    e6: 36,\n    f6: 37,\n    g6: 38,\n    h6: 39,\n    a5: 48,\n    b5: 49,\n    c5: 50,\n    d5: 51,\n    e5: 52,\n    f5: 53,\n    g5: 54,\n    h5: 55,\n    a4: 64,\n    b4: 65,\n    c4: 66,\n    d4: 67,\n    e4: 68,\n    f4: 69,\n    g4: 70,\n    h4: 71,\n    a3: 80,\n    b3: 81,\n    c3: 82,\n    d3: 83,\n    e3: 84,\n    f3: 85,\n    g3: 86,\n    h3: 87,\n    a2: 96,\n    b2: 97,\n    c2: 98,\n    d2: 99,\n    e2: 100,\n    f2: 101,\n    g2: 102,\n    h2: 103,\n    a1: 112,\n    b1: 113,\n    c1: 114,\n    d1: 115,\n    e1: 116,\n    f1: 117,\n    g1: 118,\n    h1: 119\n};\nconst $e1e1f1f3cd154daa$var$PAWN_OFFSETS = {\n    b: [\n        16,\n        32,\n        17,\n        15\n    ],\n    w: [\n        -16,\n        -32,\n        -17,\n        -15\n    ]\n};\nconst $e1e1f1f3cd154daa$var$PIECE_OFFSETS = {\n    n: [\n        -18,\n        -33,\n        -31,\n        -14,\n        18,\n        33,\n        31,\n        14\n    ],\n    b: [\n        -17,\n        -15,\n        17,\n        15\n    ],\n    r: [\n        -16,\n        1,\n        16,\n        -1\n    ],\n    q: [\n        -17,\n        -16,\n        -15,\n        1,\n        17,\n        16,\n        15,\n        -1\n    ],\n    k: [\n        -17,\n        -16,\n        -15,\n        1,\n        17,\n        16,\n        15,\n        -1\n    ]\n};\n// prettier-ignore\nconst $e1e1f1f3cd154daa$var$ATTACKS = [\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    24,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    2,\n    24,\n    2,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    2,\n    53,\n    56,\n    53,\n    2,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    56,\n    0,\n    56,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    2,\n    53,\n    56,\n    53,\n    2,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    2,\n    24,\n    2,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    24,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20\n];\n// prettier-ignore\nconst $e1e1f1f3cd154daa$var$RAYS = [\n    17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    16,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    15,\n    0,\n    0,\n    17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    16,\n    0,\n    0,\n    0,\n    0,\n    0,\n    15,\n    0,\n    0,\n    0,\n    0,\n    17,\n    0,\n    0,\n    0,\n    0,\n    16,\n    0,\n    0,\n    0,\n    0,\n    15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    17,\n    0,\n    0,\n    0,\n    16,\n    0,\n    0,\n    0,\n    15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    17,\n    0,\n    0,\n    16,\n    0,\n    0,\n    15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    17,\n    0,\n    16,\n    0,\n    15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    17,\n    16,\n    15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    -16,\n    -17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    0,\n    -16,\n    0,\n    -17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    0,\n    0,\n    -16,\n    0,\n    0,\n    -17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    0,\n    0,\n    0,\n    -16,\n    0,\n    0,\n    0,\n    -17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    0,\n    0,\n    0,\n    0,\n    -16,\n    0,\n    0,\n    0,\n    0,\n    -17,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -16,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -17,\n    0,\n    0,\n    -15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -16,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -17\n];\nconst $e1e1f1f3cd154daa$var$PIECE_MASKS = {\n    p: 0x1,\n    n: 0x2,\n    b: 0x4,\n    r: 0x8,\n    q: 0x10,\n    k: 0x20\n};\nconst $e1e1f1f3cd154daa$var$SYMBOLS = 'pnbrqkPNBRQK';\nconst $e1e1f1f3cd154daa$var$PROMOTIONS = [\n    $e1e1f1f3cd154daa$export$ce32bc8c2a29bae6,\n    $e1e1f1f3cd154daa$export$54a167f801c5dba3,\n    $e1e1f1f3cd154daa$export$68d4c913908dc245,\n    $e1e1f1f3cd154daa$export$36a8946792f13ec9\n];\nconst $e1e1f1f3cd154daa$var$RANK_1 = 7;\nconst $e1e1f1f3cd154daa$var$RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */ const $e1e1f1f3cd154daa$var$RANK_7 = 1;\nconst $e1e1f1f3cd154daa$var$RANK_8 = 0;\nconst $e1e1f1f3cd154daa$var$SIDES = {\n    [$e1e1f1f3cd154daa$export$42387107bb0d6206]: $e1e1f1f3cd154daa$var$BITS.KSIDE_CASTLE,\n    [$e1e1f1f3cd154daa$export$36a8946792f13ec9]: $e1e1f1f3cd154daa$var$BITS.QSIDE_CASTLE\n};\nconst $e1e1f1f3cd154daa$var$ROOKS = {\n    w: [\n        {\n            square: $e1e1f1f3cd154daa$var$Ox88.a1,\n            flag: $e1e1f1f3cd154daa$var$BITS.QSIDE_CASTLE\n        },\n        {\n            square: $e1e1f1f3cd154daa$var$Ox88.h1,\n            flag: $e1e1f1f3cd154daa$var$BITS.KSIDE_CASTLE\n        }\n    ],\n    b: [\n        {\n            square: $e1e1f1f3cd154daa$var$Ox88.a8,\n            flag: $e1e1f1f3cd154daa$var$BITS.QSIDE_CASTLE\n        },\n        {\n            square: $e1e1f1f3cd154daa$var$Ox88.h8,\n            flag: $e1e1f1f3cd154daa$var$BITS.KSIDE_CASTLE\n        }\n    ]\n};\nconst $e1e1f1f3cd154daa$var$SECOND_RANK = {\n    b: $e1e1f1f3cd154daa$var$RANK_7,\n    w: $e1e1f1f3cd154daa$var$RANK_2\n};\nconst $e1e1f1f3cd154daa$var$TERMINATION_MARKERS = [\n    '1-0',\n    '0-1',\n    '1/2-1/2',\n    '*'\n];\n// Extracts the zero-based rank of an 0x88 square.\nfunction $e1e1f1f3cd154daa$var$rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction $e1e1f1f3cd154daa$var$file(square) {\n    return square & 0xf;\n}\nfunction $e1e1f1f3cd154daa$var$isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction $e1e1f1f3cd154daa$var$algebraic(square) {\n    const f = $e1e1f1f3cd154daa$var$file(square);\n    const r = $e1e1f1f3cd154daa$var$rank(square);\n    return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n}\nfunction $e1e1f1f3cd154daa$var$swapColor(color) {\n    return color === $e1e1f1f3cd154daa$export$29814851e0aa981f ? $e1e1f1f3cd154daa$export$7a91b0fde7ec420f : $e1e1f1f3cd154daa$export$29814851e0aa981f;\n}\nfunction $e1e1f1f3cd154daa$export$d9e02ca3a6185312(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) return {\n        ok: false,\n        error: 'Invalid FEN: must contain six space-delimited fields'\n    };\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) return {\n        ok: false,\n        error: 'Invalid FEN: move number must be a positive integer'\n    };\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) return {\n        ok: false,\n        error: 'Invalid FEN: half move counter number must be a non-negative integer'\n    };\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) return {\n        ok: false,\n        error: 'Invalid FEN: en-passant square is invalid'\n    };\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) return {\n        ok: false,\n        error: 'Invalid FEN: castling availability is invalid'\n    };\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) return {\n        ok: false,\n        error: 'Invalid FEN: side-to-move is invalid'\n    };\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) return {\n        ok: false,\n        error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\"\n    };\n    // 8th criterion: every row is valid?\n    for(let i = 0; i < rows.length; i++){\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for(let k = 0; k < rows[i].length; k++)if ($e1e1f1f3cd154daa$var$isDigit(rows[i][k])) {\n            if (previousWasNumber) return {\n                ok: false,\n                error: 'Invalid FEN: piece data is invalid (consecutive number)'\n            };\n            sumFields += parseInt(rows[i][k], 10);\n            previousWasNumber = true;\n        } else {\n            if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) return {\n                ok: false,\n                error: 'Invalid FEN: piece data is invalid (invalid piece)'\n            };\n            sumFields += 1;\n            previousWasNumber = false;\n        }\n        if (sumFields !== 8) return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (too many squares in rank)'\n        };\n    }\n    // 9th criterion: is en-passant square legal?\n    if (tokens[3][1] == '3' && tokens[1] == 'w' || tokens[3][1] == '6' && tokens[1] == 'b') return {\n        ok: false,\n        error: 'Invalid FEN: illegal en-passant square'\n    };\n    // 10th criterion: does chess position contain exact two kings?\n    const kings = [\n        {\n            color: 'white',\n            regex: /K/g\n        },\n        {\n            color: 'black',\n            regex: /k/g\n        }\n    ];\n    for (const { color: color, regex: regex } of kings){\n        if (!regex.test(tokens[0])) return {\n            ok: false,\n            error: `Invalid FEN: missing ${color} king`\n        };\n        if ((tokens[0].match(regex) || []).length > 1) return {\n            ok: false,\n            error: `Invalid FEN: too many ${color} kings`\n        };\n    }\n    // 11th criterion: are any pawns on the first or eighth rows?\n    if (Array.from(rows[0] + rows[7]).some((char)=>char.toUpperCase() === 'P')) return {\n        ok: false,\n        error: 'Invalid FEN: some pawns are on the edge rows'\n    };\n    return {\n        ok: true\n    };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction $e1e1f1f3cd154daa$var$getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for(let i = 0, len = moves.length; i < len; i++){\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */ if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if ($e1e1f1f3cd154daa$var$rank(from) === $e1e1f1f3cd154daa$var$rank(ambigFrom)) sameRank++;\n            if ($e1e1f1f3cd154daa$var$file(from) === $e1e1f1f3cd154daa$var$file(ambigFrom)) sameFile++;\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */ return $e1e1f1f3cd154daa$var$algebraic(from);\n        else if (sameFile > 0) /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */ return $e1e1f1f3cd154daa$var$algebraic(from).charAt(1);\n        else // else use the file symbol\n        return $e1e1f1f3cd154daa$var$algebraic(from).charAt(0);\n    }\n    return '';\n}\nfunction $e1e1f1f3cd154daa$var$addMove(moves, color, from, to, piece, captured, flags = $e1e1f1f3cd154daa$var$BITS.NORMAL) {\n    const r = $e1e1f1f3cd154daa$var$rank(to);\n    if (piece === $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0 && (r === $e1e1f1f3cd154daa$var$RANK_1 || r === $e1e1f1f3cd154daa$var$RANK_8)) for(let i = 0; i < $e1e1f1f3cd154daa$var$PROMOTIONS.length; i++){\n        const promotion = $e1e1f1f3cd154daa$var$PROMOTIONS[i];\n        moves.push({\n            color: color,\n            from: from,\n            to: to,\n            piece: piece,\n            captured: captured,\n            promotion: promotion,\n            flags: flags | $e1e1f1f3cd154daa$var$BITS.PROMOTION\n        });\n    }\n    else moves.push({\n        color: color,\n        from: from,\n        to: to,\n        piece: piece,\n        captured: captured,\n        flags: flags\n    });\n}\nfunction $e1e1f1f3cd154daa$var$inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) return undefined;\n        return $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') return $e1e1f1f3cd154daa$export$42387107bb0d6206;\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction $e1e1f1f3cd154daa$var$strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nfunction $e1e1f1f3cd154daa$var$trimFen(fen) {\n    /*\n     * remove last two fields in FEN string as they're not needed when checking\n     * for repetition\n     */ return fen.split(' ').slice(0, 4).join(' ');\n}\nclass $e1e1f1f3cd154daa$export$a4d6ea685c300d39 {\n    _board = new Array(128);\n    _turn = $e1e1f1f3cd154daa$export$29814851e0aa981f;\n    _header = {};\n    _kings = {\n        w: $e1e1f1f3cd154daa$var$EMPTY,\n        b: $e1e1f1f3cd154daa$var$EMPTY\n    };\n    _epSquare = -1;\n    _halfMoves = 0;\n    _moveNumber = 0;\n    _history = [];\n    _comments = {};\n    _castling = {\n        w: 0,\n        b: 0\n    };\n    // tracks number of times a position has been seen for repetition checking\n    _positionCount = {};\n    constructor(fen = $e1e1f1f3cd154daa$export$1264a6620073cfaa){\n        this.load(fen);\n    }\n    clear({ preserveHeaders: preserveHeaders = false } = {}) {\n        this._board = new Array(128);\n        this._kings = {\n            w: $e1e1f1f3cd154daa$var$EMPTY,\n            b: $e1e1f1f3cd154daa$var$EMPTY\n        };\n        this._turn = $e1e1f1f3cd154daa$export$29814851e0aa981f;\n        this._castling = {\n            w: 0,\n            b: 0\n        };\n        this._epSquare = $e1e1f1f3cd154daa$var$EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = preserveHeaders ? this._header : {};\n        this._positionCount = {};\n        /*\n         * Delete the SetUp and FEN headers (if preserved), the board is empty and\n         * these headers don't make sense in this state. They'll get added later\n         * via .load() or .put()\n         */ delete this._header['SetUp'];\n        delete this._header['FEN'];\n    }\n    load(fen, { skipValidation: skipValidation = false, preserveHeaders: preserveHeaders = false } = {}) {\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = [\n                '-',\n                '-',\n                '0',\n                '1'\n            ];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n        }\n        tokens = fen.split(/\\s+/);\n        if (!skipValidation) {\n            const { ok: ok, error: error } = $e1e1f1f3cd154daa$export$d9e02ca3a6185312(fen);\n            if (!ok) throw new Error(error);\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear({\n            preserveHeaders: preserveHeaders\n        });\n        for(let i = 0; i < position.length; i++){\n            const piece = position.charAt(i);\n            if (piece === '/') square += 8;\n            else if ($e1e1f1f3cd154daa$var$isDigit(piece)) square += parseInt(piece, 10);\n            else {\n                const color = piece < 'a' ? $e1e1f1f3cd154daa$export$29814851e0aa981f : $e1e1f1f3cd154daa$export$7a91b0fde7ec420f;\n                this._put({\n                    type: piece.toLowerCase(),\n                    color: color\n                }, $e1e1f1f3cd154daa$var$algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) this._castling.w |= $e1e1f1f3cd154daa$var$BITS.KSIDE_CASTLE;\n        if (tokens[2].indexOf('Q') > -1) this._castling.w |= $e1e1f1f3cd154daa$var$BITS.QSIDE_CASTLE;\n        if (tokens[2].indexOf('k') > -1) this._castling.b |= $e1e1f1f3cd154daa$var$BITS.KSIDE_CASTLE;\n        if (tokens[2].indexOf('q') > -1) this._castling.b |= $e1e1f1f3cd154daa$var$BITS.QSIDE_CASTLE;\n        this._epSquare = tokens[3] === '-' ? $e1e1f1f3cd154daa$var$EMPTY : $e1e1f1f3cd154daa$var$Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(fen);\n        this._incPositionCount(fen);\n    }\n    fen() {\n        let empty = 0;\n        let fen = '';\n        for(let i = $e1e1f1f3cd154daa$var$Ox88.a8; i <= $e1e1f1f3cd154daa$var$Ox88.h1; i++){\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color: color, type: piece } = this._board[i];\n                fen += color === $e1e1f1f3cd154daa$export$29814851e0aa981f ? piece.toUpperCase() : piece.toLowerCase();\n            } else empty++;\n            if (i + 1 & 0x88) {\n                if (empty > 0) fen += empty;\n                if (i !== $e1e1f1f3cd154daa$var$Ox88.h1) fen += '/';\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = '';\n        if (this._castling[$e1e1f1f3cd154daa$export$29814851e0aa981f] & $e1e1f1f3cd154daa$var$BITS.KSIDE_CASTLE) castling += 'K';\n        if (this._castling[$e1e1f1f3cd154daa$export$29814851e0aa981f] & $e1e1f1f3cd154daa$var$BITS.QSIDE_CASTLE) castling += 'Q';\n        if (this._castling[$e1e1f1f3cd154daa$export$7a91b0fde7ec420f] & $e1e1f1f3cd154daa$var$BITS.KSIDE_CASTLE) castling += 'k';\n        if (this._castling[$e1e1f1f3cd154daa$export$7a91b0fde7ec420f] & $e1e1f1f3cd154daa$var$BITS.QSIDE_CASTLE) castling += 'q';\n        // do we have an empty castling flag?\n        castling = castling || '-';\n        let epSquare = '-';\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */ if (this._epSquare !== $e1e1f1f3cd154daa$var$EMPTY) {\n            const bigPawnSquare = this._epSquare + (this._turn === $e1e1f1f3cd154daa$export$29814851e0aa981f ? 16 : -16);\n            const squares = [\n                bigPawnSquare + 1,\n                bigPawnSquare - 1\n            ];\n            for (const square of squares){\n                // is the square off the board?\n                if (square & 0x88) continue;\n                const color = this._turn;\n                // is there a pawn that can capture the epSquare?\n                if (this._board[square]?.color === color && this._board[square]?.type === $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0) {\n                    // if the pawn makes an ep capture, does it leave it's king in check?\n                    this._makeMove({\n                        color: color,\n                        from: square,\n                        to: this._epSquare,\n                        piece: $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0,\n                        captured: $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0,\n                        flags: $e1e1f1f3cd154daa$var$BITS.EP_CAPTURE\n                    });\n                    const isLegal = !this._isKingAttacked(color);\n                    this._undoMove();\n                    // if ep is legal, break and set the ep square in the FEN output\n                    if (isLegal) {\n                        epSquare = $e1e1f1f3cd154daa$var$algebraic(this._epSquare);\n                        break;\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber\n        ].join(' ');\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */ _updateSetup(fen) {\n        if (this._history.length > 0) return;\n        if (fen !== $e1e1f1f3cd154daa$export$1264a6620073cfaa) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        } else {\n            delete this._header['SetUp'];\n            delete this._header['FEN'];\n        }\n    }\n    reset() {\n        this.load($e1e1f1f3cd154daa$export$1264a6620073cfaa);\n    }\n    get(square) {\n        return this._board[$e1e1f1f3cd154daa$var$Ox88[square]];\n    }\n    put({ type: type, color: color }, square) {\n        if (this._put({\n            type: type,\n            color: color\n        }, square)) {\n            this._updateCastlingRights();\n            this._updateEnPassantSquare();\n            this._updateSetup(this.fen());\n            return true;\n        }\n        return false;\n    }\n    _put({ type: type, color: color }, square) {\n        // check for piece\n        if ($e1e1f1f3cd154daa$var$SYMBOLS.indexOf(type.toLowerCase()) === -1) return false;\n        // check for valid square\n        if (!(square in $e1e1f1f3cd154daa$var$Ox88)) return false;\n        const sq = $e1e1f1f3cd154daa$var$Ox88[square];\n        // don't let the user place more than one king\n        if (type == $e1e1f1f3cd154daa$export$42387107bb0d6206 && !(this._kings[color] == $e1e1f1f3cd154daa$var$EMPTY || this._kings[color] == sq)) return false;\n        const currentPieceOnSquare = this._board[sq];\n        // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n        if (currentPieceOnSquare && currentPieceOnSquare.type === $e1e1f1f3cd154daa$export$42387107bb0d6206) this._kings[currentPieceOnSquare.color] = $e1e1f1f3cd154daa$var$EMPTY;\n        this._board[sq] = {\n            type: type,\n            color: color\n        };\n        if (type === $e1e1f1f3cd154daa$export$42387107bb0d6206) this._kings[color] = sq;\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[$e1e1f1f3cd154daa$var$Ox88[square]];\n        if (piece && piece.type === $e1e1f1f3cd154daa$export$42387107bb0d6206) this._kings[piece.color] = $e1e1f1f3cd154daa$var$EMPTY;\n        this._updateCastlingRights();\n        this._updateEnPassantSquare();\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _updateCastlingRights() {\n        const whiteKingInPlace = this._board[$e1e1f1f3cd154daa$var$Ox88.e1]?.type === $e1e1f1f3cd154daa$export$42387107bb0d6206 && this._board[$e1e1f1f3cd154daa$var$Ox88.e1]?.color === $e1e1f1f3cd154daa$export$29814851e0aa981f;\n        const blackKingInPlace = this._board[$e1e1f1f3cd154daa$var$Ox88.e8]?.type === $e1e1f1f3cd154daa$export$42387107bb0d6206 && this._board[$e1e1f1f3cd154daa$var$Ox88.e8]?.color === $e1e1f1f3cd154daa$export$7a91b0fde7ec420f;\n        if (!whiteKingInPlace || this._board[$e1e1f1f3cd154daa$var$Ox88.a1]?.type !== $e1e1f1f3cd154daa$export$68d4c913908dc245 || this._board[$e1e1f1f3cd154daa$var$Ox88.a1]?.color !== $e1e1f1f3cd154daa$export$29814851e0aa981f) this._castling.w &= ~$e1e1f1f3cd154daa$var$BITS.QSIDE_CASTLE;\n        if (!whiteKingInPlace || this._board[$e1e1f1f3cd154daa$var$Ox88.h1]?.type !== $e1e1f1f3cd154daa$export$68d4c913908dc245 || this._board[$e1e1f1f3cd154daa$var$Ox88.h1]?.color !== $e1e1f1f3cd154daa$export$29814851e0aa981f) this._castling.w &= ~$e1e1f1f3cd154daa$var$BITS.KSIDE_CASTLE;\n        if (!blackKingInPlace || this._board[$e1e1f1f3cd154daa$var$Ox88.a8]?.type !== $e1e1f1f3cd154daa$export$68d4c913908dc245 || this._board[$e1e1f1f3cd154daa$var$Ox88.a8]?.color !== $e1e1f1f3cd154daa$export$7a91b0fde7ec420f) this._castling.b &= ~$e1e1f1f3cd154daa$var$BITS.QSIDE_CASTLE;\n        if (!blackKingInPlace || this._board[$e1e1f1f3cd154daa$var$Ox88.h8]?.type !== $e1e1f1f3cd154daa$export$68d4c913908dc245 || this._board[$e1e1f1f3cd154daa$var$Ox88.h8]?.color !== $e1e1f1f3cd154daa$export$7a91b0fde7ec420f) this._castling.b &= ~$e1e1f1f3cd154daa$var$BITS.KSIDE_CASTLE;\n    }\n    _updateEnPassantSquare() {\n        if (this._epSquare === $e1e1f1f3cd154daa$var$EMPTY) return;\n        const startSquare = this._epSquare + (this._turn === $e1e1f1f3cd154daa$export$29814851e0aa981f ? -16 : 16);\n        const currentSquare = this._epSquare + (this._turn === $e1e1f1f3cd154daa$export$29814851e0aa981f ? 16 : -16);\n        const attackers = [\n            currentSquare + 1,\n            currentSquare - 1\n        ];\n        if (this._board[startSquare] !== null || this._board[this._epSquare] !== null || this._board[currentSquare]?.color !== $e1e1f1f3cd154daa$var$swapColor(this._turn) || this._board[currentSquare]?.type !== $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0) {\n            this._epSquare = $e1e1f1f3cd154daa$var$EMPTY;\n            return;\n        }\n        const canCapture = (square)=>!(square & 0x88) && this._board[square]?.color === this._turn && this._board[square]?.type === $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0;\n        if (!attackers.some(canCapture)) this._epSquare = $e1e1f1f3cd154daa$var$EMPTY;\n    }\n    _attacked(color, square, verbose) {\n        const attackers = [];\n        for(let i = $e1e1f1f3cd154daa$var$Ox88.a8; i <= $e1e1f1f3cd154daa$var$Ox88.h1; i++){\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) continue;\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) continue;\n            const index = difference + 119;\n            if ($e1e1f1f3cd154daa$var$ATTACKS[index] & $e1e1f1f3cd154daa$var$PIECE_MASKS[piece.type]) {\n                if (piece.type === $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0) {\n                    if (difference > 0 && piece.color === $e1e1f1f3cd154daa$export$29814851e0aa981f || difference <= 0 && piece.color === $e1e1f1f3cd154daa$export$7a91b0fde7ec420f) {\n                        if (!verbose) return true;\n                        else attackers.push($e1e1f1f3cd154daa$var$algebraic(i));\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === 'n' || piece.type === 'k') {\n                    if (!verbose) return true;\n                    else {\n                        attackers.push($e1e1f1f3cd154daa$var$algebraic(i));\n                        continue;\n                    }\n                }\n                const offset = $e1e1f1f3cd154daa$var$RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while(j !== square){\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked) {\n                    if (!verbose) return true;\n                    else {\n                        attackers.push($e1e1f1f3cd154daa$var$algebraic(i));\n                        continue;\n                    }\n                }\n            }\n        }\n        if (verbose) return attackers;\n        else return false;\n    }\n    attackers(square, attackedBy) {\n        if (!attackedBy) return this._attacked(this._turn, $e1e1f1f3cd154daa$var$Ox88[square], true);\n        else return this._attacked(attackedBy, $e1e1f1f3cd154daa$var$Ox88[square], true);\n    }\n    _isKingAttacked(color) {\n        const square = this._kings[color];\n        return square === -1 ? false : this._attacked($e1e1f1f3cd154daa$var$swapColor(color), square);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, $e1e1f1f3cd154daa$var$Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */ const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for(let i = $e1e1f1f3cd154daa$var$Ox88.a8; i <= $e1e1f1f3cd154daa$var$Ox88.h1; i++){\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === $e1e1f1f3cd154daa$export$54a167f801c5dba3) bishops.push(squareColor);\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) return true;\n        else if (// k vs. kn .... or .... k vs. kb\n        numPieces === 3 && (pieces[$e1e1f1f3cd154daa$export$54a167f801c5dba3] === 1 || pieces[$e1e1f1f3cd154daa$export$ce32bc8c2a29bae6] === 1)) return true;\n        else if (numPieces === pieces[$e1e1f1f3cd154daa$export$54a167f801c5dba3] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for(let i = 0; i < len; i++)sum += bishops[i];\n            if (sum === 0 || sum === len) return true;\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        return this._getPositionCount(this.fen()) >= 3;\n    }\n    isDrawByFiftyMoves() {\n        return this._halfMoves >= 100; // 50 moves per side = 100 half moves\n    }\n    isDraw() {\n        return this.isDrawByFiftyMoves() || this.isStalemate() || this.isInsufficientMaterial() || this.isThreefoldRepetition();\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves({ verbose: verbose = false, square: square, piece: piece } = {}) {\n        const moves = this._moves({\n            square: square,\n            piece: piece\n        });\n        if (verbose) return moves.map((move)=>new $e1e1f1f3cd154daa$export$e49a5ad3dd6df925(this, move));\n        else return moves.map((move)=>this._moveToSan(move, moves));\n    }\n    _moves({ legal: legal = true, piece: piece, square: square } = {}) {\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece?.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = $e1e1f1f3cd154daa$var$swapColor(us);\n        let firstSquare = $e1e1f1f3cd154daa$var$Ox88.a8;\n        let lastSquare = $e1e1f1f3cd154daa$var$Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in $e1e1f1f3cd154daa$var$Ox88)) return [];\n            else {\n                firstSquare = lastSquare = $e1e1f1f3cd154daa$var$Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for(let from = firstSquare; from <= lastSquare; from++){\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) continue;\n            const { type: type } = this._board[from];\n            let to;\n            if (type === $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0) {\n                if (forPiece && forPiece !== type) continue;\n                // single square, non-capturing\n                to = from + $e1e1f1f3cd154daa$var$PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    $e1e1f1f3cd154daa$var$addMove(moves, us, from, to, $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0);\n                    // double square\n                    to = from + $e1e1f1f3cd154daa$var$PAWN_OFFSETS[us][1];\n                    if ($e1e1f1f3cd154daa$var$SECOND_RANK[us] === $e1e1f1f3cd154daa$var$rank(from) && !this._board[to]) $e1e1f1f3cd154daa$var$addMove(moves, us, from, to, $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0, undefined, $e1e1f1f3cd154daa$var$BITS.BIG_PAWN);\n                }\n                // pawn captures\n                for(let j = 2; j < 4; j++){\n                    to = from + $e1e1f1f3cd154daa$var$PAWN_OFFSETS[us][j];\n                    if (to & 0x88) continue;\n                    if (this._board[to]?.color === them) $e1e1f1f3cd154daa$var$addMove(moves, us, from, to, $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0, this._board[to].type, $e1e1f1f3cd154daa$var$BITS.CAPTURE);\n                    else if (to === this._epSquare) $e1e1f1f3cd154daa$var$addMove(moves, us, from, to, $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0, $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0, $e1e1f1f3cd154daa$var$BITS.EP_CAPTURE);\n                }\n            } else {\n                if (forPiece && forPiece !== type) continue;\n                for(let j = 0, len = $e1e1f1f3cd154daa$var$PIECE_OFFSETS[type].length; j < len; j++){\n                    const offset = $e1e1f1f3cd154daa$var$PIECE_OFFSETS[type][j];\n                    to = from;\n                    while(true){\n                        to += offset;\n                        if (to & 0x88) break;\n                        if (!this._board[to]) $e1e1f1f3cd154daa$var$addMove(moves, us, from, to, type);\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us) break;\n                            $e1e1f1f3cd154daa$var$addMove(moves, us, from, to, type, this._board[to].type, $e1e1f1f3cd154daa$var$BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */ if (type === $e1e1f1f3cd154daa$export$ce32bc8c2a29bae6 || type === $e1e1f1f3cd154daa$export$42387107bb0d6206) break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */ if (forPiece === undefined || forPiece === $e1e1f1f3cd154daa$export$42387107bb0d6206) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & $e1e1f1f3cd154daa$var$BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] && !this._board[castlingTo] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom + 1) && !this._attacked(them, castlingTo)) $e1e1f1f3cd154daa$var$addMove(moves, us, this._kings[us], castlingTo, $e1e1f1f3cd154daa$export$42387107bb0d6206, undefined, $e1e1f1f3cd154daa$var$BITS.KSIDE_CASTLE);\n                }\n                // queen-side castling\n                if (this._castling[us] & $e1e1f1f3cd154daa$var$BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] && !this._board[castlingFrom - 2] && !this._board[castlingFrom - 3] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom - 1) && !this._attacked(them, castlingTo)) $e1e1f1f3cd154daa$var$addMove(moves, us, this._kings[us], castlingTo, $e1e1f1f3cd154daa$export$42387107bb0d6206, undefined, $e1e1f1f3cd154daa$var$BITS.QSIDE_CASTLE);\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */ if (!legal || this._kings[us] === -1) return moves;\n        // filter out illegal moves\n        const legalMoves = [];\n        for(let i = 0, len = moves.length; i < len; i++){\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) legalMoves.push(moves[i]);\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { strict: strict = false } = {}) {\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */ let moveObj = null;\n        if (typeof move === 'string') moveObj = this._moveFromSan(move, strict);\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for(let i = 0, len = moves.length; i < len; i++)if (move.from === $e1e1f1f3cd154daa$var$algebraic(moves[i].from) && move.to === $e1e1f1f3cd154daa$var$algebraic(moves[i].to) && (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                moveObj = moves[i];\n                break;\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === 'string') throw new Error(`Invalid move: ${move}`);\n            else throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */ const prettyMove = new $e1e1f1f3cd154daa$export$e49a5ad3dd6df925(this, moveObj);\n        this._makeMove(moveObj);\n        this._incPositionCount(prettyMove.after);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move: move,\n            kings: {\n                b: this._kings.b,\n                w: this._kings.w\n            },\n            turn: this._turn,\n            castling: {\n                b: this._castling.b,\n                w: this._castling.w\n            },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = $e1e1f1f3cd154daa$var$swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        // if ep capture, remove the captured pawn\n        if (move.flags & $e1e1f1f3cd154daa$var$BITS.EP_CAPTURE) {\n            if (this._turn === $e1e1f1f3cd154daa$export$7a91b0fde7ec420f) delete this._board[move.to - 16];\n            else delete this._board[move.to + 16];\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) this._board[move.to] = {\n            type: move.promotion,\n            color: us\n        };\n        // if we moved the king\n        if (this._board[move.to].type === $e1e1f1f3cd154daa$export$42387107bb0d6206) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & $e1e1f1f3cd154daa$var$BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            } else if (move.flags & $e1e1f1f3cd154daa$var$BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for(let i = 0, len = $e1e1f1f3cd154daa$var$ROOKS[us].length; i < len; i++)if (move.from === $e1e1f1f3cd154daa$var$ROOKS[us][i].square && this._castling[us] & $e1e1f1f3cd154daa$var$ROOKS[us][i].flag) {\n                this._castling[us] ^= $e1e1f1f3cd154daa$var$ROOKS[us][i].flag;\n                break;\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for(let i = 0, len = $e1e1f1f3cd154daa$var$ROOKS[them].length; i < len; i++)if (move.to === $e1e1f1f3cd154daa$var$ROOKS[them][i].square && this._castling[them] & $e1e1f1f3cd154daa$var$ROOKS[them][i].flag) {\n                this._castling[them] ^= $e1e1f1f3cd154daa$var$ROOKS[them][i].flag;\n                break;\n            }\n        }\n        // if big pawn move, update the en passant square\n        if (move.flags & $e1e1f1f3cd154daa$var$BITS.BIG_PAWN) {\n            if (us === $e1e1f1f3cd154daa$export$7a91b0fde7ec420f) this._epSquare = move.to - 16;\n            else this._epSquare = move.to + 16;\n        } else this._epSquare = $e1e1f1f3cd154daa$var$EMPTY;\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0) this._halfMoves = 0;\n        else if (move.flags & ($e1e1f1f3cd154daa$var$BITS.CAPTURE | $e1e1f1f3cd154daa$var$BITS.EP_CAPTURE)) this._halfMoves = 0;\n        else this._halfMoves++;\n        if (us === $e1e1f1f3cd154daa$export$7a91b0fde7ec420f) this._moveNumber++;\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        if (move) {\n            const prettyMove = new $e1e1f1f3cd154daa$export$e49a5ad3dd6df925(this, move);\n            this._decPositionCount(prettyMove.after);\n            return prettyMove;\n        }\n        return null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) return null;\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = $e1e1f1f3cd154daa$var$swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & $e1e1f1f3cd154daa$var$BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === $e1e1f1f3cd154daa$export$7a91b0fde7ec420f) index = move.to - 16;\n                else index = move.to + 16;\n                this._board[index] = {\n                    type: $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0,\n                    color: them\n                };\n            } else // regular capture\n            this._board[move.to] = {\n                type: move.captured,\n                color: them\n            };\n        }\n        if (move.flags & ($e1e1f1f3cd154daa$var$BITS.KSIDE_CASTLE | $e1e1f1f3cd154daa$var$BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & $e1e1f1f3cd154daa$var$BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            } else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn({ newline: newline = '\\n', maxWidth: maxWidth = 0 } = {}) {\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */ const result = [];\n        let headerExists = false;\n        /* add the PGN header information */ for(const i in this._header){\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */ result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) result.push(newline);\n        const appendComment = (moveString)=>{\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while(this._history.length > 0)reversedHistory.push(this._undoMove());\n        const moves = [];\n        let moveString = '';\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) moves.push(appendComment(''));\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while(reversedHistory.length > 0){\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) break;\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                // is there a comment preceding the first move?\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            } else if (move.color === 'w') {\n                // store the previous generated move_string if we have one\n                if (moveString.length) moves.push(moveString);\n                moveString = this._moveNumber + '.';\n            }\n            moveString = moveString + ' ' + this._moveToSan(move, this._moves({\n                legal: true\n            }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) moves.push(appendComment(moveString));\n        // is there a result?\n        if (typeof this._header.Result !== 'undefined') moves.push(this._header.Result);\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */ if (maxWidth === 0) return result.join('') + moves.join(' ');\n        // TODO (jah): huh?\n        const strip = function() {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function(width, move) {\n            for (const token of move.split(' ')){\n                if (!token) continue;\n                if (width + token.length > maxWidth) {\n                    while(strip())width--;\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) width--;\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for(let i = 0; i < moves.length; i++){\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === ' ') result.pop();\n                result.push(newline);\n                currentWidth = 0;\n            } else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    /*\n     * @deprecated Use `setHeader` and `getHeaders` instead.\n     */ header(...args) {\n        for(let i = 0; i < args.length; i += 2)if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') this._header[args[i]] = args[i + 1];\n        return this._header;\n    }\n    setHeader(key, value) {\n        this._header[key] = value;\n        return this._header;\n    }\n    removeHeader(key) {\n        if (key in this._header) {\n            delete this._header[key];\n            return true;\n        }\n        return false;\n    }\n    getHeaders() {\n        return this._header;\n    }\n    loadPgn(pgn, { strict: strict = false, newlineChar: newlineChar = '\\r?\\n' } = {}) {\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = '';\n            let value = '';\n            for(let i = 0; i < headers.length; i++){\n                const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, '$1');\n                value = headers[i].replace(regex, '$2');\n                if (key.trim().length > 0) headerObj[key] = value;\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        /*\n         * RegExp to split header. Takes advantage of the fact that header and movetext\n         * will always have a blank line between them (ie, two newline_char's). Handles\n         * case where movetext is empty by matching newlineChar until end of string is\n         * matched - effectively trimming from the end extra newlineChar.\n         *\n         * With default newline_char, will equal:\n         * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n         */ const headerRegex = new RegExp('^(\\\\[((?:' + mask(newlineChar) + ')|.)*\\\\])' + '((?:\\\\s*' + mask(newlineChar) + '){2}|(?:\\\\s*' + mask(newlineChar) + ')*$)');\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults ? headerRegexResults.length >= 2 ? headerRegexResults[1] : '' : '';\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsePgnHeader(headerString);\n        let fen = '';\n        for(const key in headers){\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') fen = headers[key];\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */ if (!strict) {\n            if (fen) this.load(fen, {\n                preserveHeaders: true\n            });\n        } else /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */ if (headers['SetUp'] === '1') {\n            if (!('FEN' in headers)) throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n            // don't clear the headers when loading\n            this.load(headers['FEN'], {\n                preserveHeaders: true\n            });\n        }\n        /*\n         * NB: the regexes below that delete move numbers, recursive annotations,\n         * and numeric annotation glyphs may also match text in comments. To\n         * prevent this, we transform comments by hex-encoding them in place and\n         * decoding them again after the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded, we use\n         * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n         * for modern users\n         */ function toHex(s) {\n            return Array.from(s).map(function(c) {\n                /*\n                 * encodeURI doesn't transform most ASCII characters, so we handle\n                 * these ourselves\n                 */ return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n            }).join('');\n        }\n        function fromHex(s) {\n            return s.length == 0 ? '' : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n        }\n        const encodeComment = function(s) {\n            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n            return `{${toHex(s.slice(1, s.length - 1))}}`;\n        };\n        const decodeComment = function(s) {\n            if (s.startsWith('{') && s.endsWith('}')) return fromHex(s.slice(1, s.length - 1));\n        };\n        // delete header to get the moves\n        let ms = pgn.replace(headerString, '').replace(// encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function(_match, bracket, semicolon) {\n            return bracket !== undefined ? encodeComment(bracket) : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n        }).replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        // delete recursive annotation variations\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while(ravRegex.test(ms))ms = ms.replace(ravRegex, '');\n        // delete move numbers\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n        // delete ... indicating black to move\n        ms = ms.replace(/\\.\\.\\./g, '');\n        /* delete numeric annotation glyphs */ ms = ms.replace(/\\$\\d+/g, '');\n        // trim and get array of moves\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        // delete empty entries\n        moves = moves.filter((move)=>move !== '');\n        let result = '';\n        for(let halfMove = 0; halfMove < moves.length; halfMove++){\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], strict);\n            // invalid move\n            if (move == null) {\n                // was the move an end of game marker\n                if ($e1e1f1f3cd154daa$var$TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) result = moves[halfMove];\n                else throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n            } else {\n                // reset the end of game marker if making a valid move\n                result = '';\n                this._makeMove(move);\n                this._incPositionCount(this.fen());\n            }\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */ if (result && Object.keys(this._header).length && !this._header['Result']) this.header('Result', result);\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */ _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & $e1e1f1f3cd154daa$var$BITS.KSIDE_CASTLE) output = 'O-O';\n        else if (move.flags & $e1e1f1f3cd154daa$var$BITS.QSIDE_CASTLE) output = 'O-O-O';\n        else {\n            if (move.piece !== $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0) {\n                const disambiguator = $e1e1f1f3cd154daa$var$getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & ($e1e1f1f3cd154daa$var$BITS.CAPTURE | $e1e1f1f3cd154daa$var$BITS.EP_CAPTURE)) {\n                if (move.piece === $e1e1f1f3cd154daa$export$4c32fd1f222ff2b0) output += $e1e1f1f3cd154daa$var$algebraic(move.from)[0];\n                output += 'x';\n            }\n            output += $e1e1f1f3cd154daa$var$algebraic(move.to);\n            if (move.promotion) output += '=' + move.promotion.toUpperCase();\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) output += '#';\n            else output += '+';\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move, strict = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = $e1e1f1f3cd154daa$var$strippedSan(move);\n        let pieceType = $e1e1f1f3cd154daa$var$inferPieceType(cleanMove);\n        let moves = this._moves({\n            legal: true,\n            piece: pieceType\n        });\n        // strict parser\n        for(let i = 0, len = moves.length; i < len; i++){\n            if (cleanMove === $e1e1f1f3cd154daa$var$strippedSan(this._moveToSan(moves[i], moves))) return moves[i];\n        }\n        // the strict parser failed\n        if (strict) return null;\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */ let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) overlyDisambiguated = true;\n        } else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */ matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) overlyDisambiguated = true;\n            }\n        }\n        pieceType = $e1e1f1f3cd154daa$var$inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType\n        });\n        if (!to) return null;\n        for(let i = 0, len = moves.length; i < len; i++){\n            if (!from) {\n                // if there is no from square, it could be just 'x' missing from a capture\n                if (cleanMove === $e1e1f1f3cd154daa$var$strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) return moves[i];\n            // hand-compare move properties with the results from our permissive regex\n            } else if ((!piece || piece.toLowerCase() == moves[i].piece) && $e1e1f1f3cd154daa$var$Ox88[from] == moves[i].from && $e1e1f1f3cd154daa$var$Ox88[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) return moves[i];\n            else if (overlyDisambiguated) {\n                /*\n                 * SPECIAL CASE: we parsed a move string that may have an unneeded\n                 * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                 */ const square = $e1e1f1f3cd154daa$var$algebraic(moves[i].from);\n                if ((!piece || piece.toLowerCase() == moves[i].piece) && $e1e1f1f3cd154daa$var$Ox88[to] == moves[i].to && (from == square[0] || from == square[1]) && (!promotion || promotion.toLowerCase() == moves[i].promotion)) return moves[i];\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for(let i = $e1e1f1f3cd154daa$var$Ox88.a8; i <= $e1e1f1f3cd154daa$var$Ox88.h1; i++){\n            // display the rank\n            if ($e1e1f1f3cd154daa$var$file(i) === 0) s += ' ' + '87654321'[$e1e1f1f3cd154daa$var$rank(i)] + ' |';\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === $e1e1f1f3cd154daa$export$29814851e0aa981f ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            } else s += ' . ';\n            if (i + 1 & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({\n            legal: false\n        });\n        let nodes = 0;\n        const color = this._turn;\n        for(let i = 0, len = moves.length; i < len; i++){\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) nodes += this.perft(depth - 1);\n                else nodes++;\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for(let i = $e1e1f1f3cd154daa$var$Ox88.a8; i <= $e1e1f1f3cd154daa$var$Ox88.h1; i++){\n            if (this._board[i] == null) row.push(null);\n            else row.push({\n                square: $e1e1f1f3cd154daa$var$algebraic(i),\n                type: this._board[i].type,\n                color: this._board[i].color\n            });\n            if (i + 1 & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in $e1e1f1f3cd154daa$var$Ox88) {\n            const sq = $e1e1f1f3cd154daa$var$Ox88[square];\n            return ($e1e1f1f3cd154daa$var$rank(sq) + $e1e1f1f3cd154daa$var$file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose: verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while(this._history.length > 0)reversedHistory.push(this._undoMove());\n        while(true){\n            const move = reversedHistory.pop();\n            if (!move) break;\n            if (verbose) moveHistory.push(new $e1e1f1f3cd154daa$export$e49a5ad3dd6df925(this, move));\n            else moveHistory.push(this._moveToSan(move, this._moves()));\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    /*\n     * Keeps track of position occurrence counts for the purpose of repetition\n     * checking. All three methods (`_inc`, `_dec`, and `_get`) trim the\n     * irrelevent information from the fen, initialising new positions, and\n     * removing old positions from the record if their counts are reduced to 0.\n     */ _getPositionCount(fen) {\n        const trimmedFen = $e1e1f1f3cd154daa$var$trimFen(fen);\n        return this._positionCount[trimmedFen] || 0;\n    }\n    _incPositionCount(fen) {\n        const trimmedFen = $e1e1f1f3cd154daa$var$trimFen(fen);\n        if (this._positionCount[trimmedFen] === undefined) this._positionCount[trimmedFen] = 0;\n        this._positionCount[trimmedFen] += 1;\n    }\n    _decPositionCount(fen) {\n        const trimmedFen = $e1e1f1f3cd154daa$var$trimFen(fen);\n        if (this._positionCount[trimmedFen] === 1) delete this._positionCount[trimmedFen];\n        else this._positionCount[trimmedFen] -= 1;\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen)=>{\n            if (fen in this._comments) currentComments[fen] = this._comments[fen];\n        };\n        while(this._history.length > 0)reversedHistory.push(this._undoMove());\n        copyComment(this.fen());\n        while(true){\n            const move = reversedHistory.pop();\n            if (!move) break;\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    /**\n     * @deprecated Renamed to `removeComment` for consistency\n     */ deleteComment() {\n        return this.removeComment();\n    }\n    removeComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen)=>{\n            return {\n                fen: fen,\n                comment: this._comments[fen]\n            };\n        });\n    }\n    /**\n     * @deprecated Renamed to `removeComments` for consistency\n     */ deleteComments() {\n        return this.removeComments();\n    }\n    removeComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen)=>{\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return {\n                fen: fen,\n                comment: comment\n            };\n        });\n    }\n    setCastlingRights(color, rights) {\n        for (const side of [\n            $e1e1f1f3cd154daa$export$42387107bb0d6206,\n            $e1e1f1f3cd154daa$export$36a8946792f13ec9\n        ])if (rights[side] !== undefined) {\n            if (rights[side]) this._castling[color] |= $e1e1f1f3cd154daa$var$SIDES[side];\n            else this._castling[color] &= ~$e1e1f1f3cd154daa$var$SIDES[side];\n        }\n        this._updateCastlingRights();\n        const result = this.getCastlingRights(color);\n        return (rights[$e1e1f1f3cd154daa$export$42387107bb0d6206] === undefined || rights[$e1e1f1f3cd154daa$export$42387107bb0d6206] === result[$e1e1f1f3cd154daa$export$42387107bb0d6206]) && (rights[$e1e1f1f3cd154daa$export$36a8946792f13ec9] === undefined || rights[$e1e1f1f3cd154daa$export$36a8946792f13ec9] === result[$e1e1f1f3cd154daa$export$36a8946792f13ec9]);\n    }\n    getCastlingRights(color) {\n        return {\n            [$e1e1f1f3cd154daa$export$42387107bb0d6206]: (this._castling[color] & $e1e1f1f3cd154daa$var$SIDES[$e1e1f1f3cd154daa$export$42387107bb0d6206]) !== 0,\n            [$e1e1f1f3cd154daa$export$36a8946792f13ec9]: (this._castling[color] & $e1e1f1f3cd154daa$var$SIDES[$e1e1f1f3cd154daa$export$36a8946792f13ec9]) !== 0\n        };\n    }\n    moveNumber() {\n        return this._moveNumber;\n    }\n}\n\n\nconst $a9912b1579309d38$export$8f45430ccf837300 = [\n    'white',\n    'black'\n];\nconst $a9912b1579309d38$export$3a444357c5f65f65 = [\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h'\n];\nconst $a9912b1579309d38$export$d8e4e3952f325c95 = [\n    '1',\n    '2',\n    '3',\n    '4',\n    '5',\n    '6',\n    '7',\n    '8'\n];\n\n\nconst $e845129b04f677bd$export$978f7ef4c67d166e = [\n    ...$a9912b1579309d38$export$d8e4e3952f325c95\n].reverse();\nconst $e845129b04f677bd$export$ade7a30951d0bc54 = Array.prototype.concat(...$a9912b1579309d38$export$3a444357c5f65f65.map((c)=>$a9912b1579309d38$export$d8e4e3952f325c95.map((r)=>c + r)));\nconst $e845129b04f677bd$export$fe9f8b727818c0ae = (pos)=>$e845129b04f677bd$export$ade7a30951d0bc54[8 * pos[0] + pos[1]];\nconst $e845129b04f677bd$export$e2878eba51f22d11 = (k)=>[\n        k.charCodeAt(0) - 97,\n        k.charCodeAt(1) - 49\n    ];\nconst $e845129b04f677bd$export$ab796e79c29e0864 = (uci)=>{\n    if (!uci) return undefined;\n    if (uci[1] === '@') return [\n        uci.slice(2, 4)\n    ];\n    return [\n        uci.slice(0, 2),\n        uci.slice(2, 4)\n    ];\n};\nconst $e845129b04f677bd$export$26773b74d67e09c2 = $e845129b04f677bd$export$ade7a30951d0bc54.map($e845129b04f677bd$export$e2878eba51f22d11);\nfunction $e845129b04f677bd$export$7c73462e0d25e514(f) {\n    let v;\n    const ret = ()=>{\n        if (v === undefined) v = f();\n        return v;\n    };\n    ret.clear = ()=>{\n        v = undefined;\n    };\n    return ret;\n}\nconst $e845129b04f677bd$export$9dc4ecf953986f04 = ()=>{\n    let startAt;\n    return {\n        start () {\n            startAt = performance.now();\n        },\n        cancel () {\n            startAt = undefined;\n        },\n        stop () {\n            if (!startAt) return 0;\n            const time = performance.now() - startAt;\n            startAt = undefined;\n            return time;\n        }\n    };\n};\nconst $e845129b04f677bd$export$a27c3a1c44ba515b = (c)=>c === 'white' ? 'black' : 'white';\nconst $e845129b04f677bd$export$e4884e1734dcd545 = (pos1, pos2)=>{\n    const dx = pos1[0] - pos2[0], dy = pos1[1] - pos2[1];\n    return dx * dx + dy * dy;\n};\nconst $e845129b04f677bd$export$e329b1a538c004fa = (p1, p2)=>p1.role === p2.role && p1.color === p2.color;\nconst $e845129b04f677bd$export$2135ad75550a2ff4 = (bounds)=>(pos, asWhite)=>[\n            (asWhite ? pos[0] : 7 - pos[0]) * bounds.width / 8,\n            (asWhite ? 7 - pos[1] : pos[1]) * bounds.height / 8\n        ];\nconst $e845129b04f677bd$export$d73ee8ef04f5226a = (el, pos)=>{\n    el.style.transform = `translate(${pos[0]}px,${pos[1]}px)`;\n};\nconst $e845129b04f677bd$export$f8afaca97e230dc6 = (el, pos, scale = 1)=>{\n    el.style.transform = `translate(${pos[0]}px,${pos[1]}px) scale(${scale})`;\n};\nconst $e845129b04f677bd$export$8cb512849e51eaf5 = (el, v)=>{\n    el.style.visibility = v ? 'visible' : 'hidden';\n};\nconst $e845129b04f677bd$export$33052595192f7117 = (e)=>{\n    var _a;\n    if (e.clientX || e.clientX === 0) return [\n        e.clientX,\n        e.clientY\n    ];\n    if ((_a = e.targetTouches) === null || _a === void 0 ? void 0 : _a[0]) return [\n        e.targetTouches[0].clientX,\n        e.targetTouches[0].clientY\n    ];\n    return; // touchend has no position!\n};\nconst $e845129b04f677bd$export$947a472b5b3020ba = (e)=>e.button === 2;\nconst $e845129b04f677bd$export$3d7cd8ed57263b30 = (tagName, className)=>{\n    const el = document.createElement(tagName);\n    if (className) el.className = className;\n    return el;\n};\nfunction $e845129b04f677bd$export$1c17f680299a31f7(key, asWhite, bounds) {\n    const pos = $e845129b04f677bd$export$e2878eba51f22d11(key);\n    if (!asWhite) {\n        pos[0] = 7 - pos[0];\n        pos[1] = 7 - pos[1];\n    }\n    return [\n        bounds.left + bounds.width * pos[0] / 8 + bounds.width / 16,\n        bounds.top + bounds.height * (7 - pos[1]) / 8 + bounds.height / 16\n    ];\n}\n\n\n\nconst $6478a7cdda5927f6$var$diff = (a, b)=>Math.abs(a - b);\nconst $6478a7cdda5927f6$var$pawn = (color)=>(x1, y1, x2, y2)=>$6478a7cdda5927f6$var$diff(x1, x2) < 2 && (color === 'white' ? y2 === y1 + 1 || y1 <= 1 && y2 === y1 + 2 && x1 === x2 : y2 === y1 - 1 || y1 >= 6 && y2 === y1 - 2 && x1 === x2);\nconst $6478a7cdda5927f6$export$5584fb45fd3a6d08 = (x1, y1, x2, y2)=>{\n    const xd = $6478a7cdda5927f6$var$diff(x1, x2);\n    const yd = $6478a7cdda5927f6$var$diff(y1, y2);\n    return xd === 1 && yd === 2 || xd === 2 && yd === 1;\n};\nconst $6478a7cdda5927f6$var$bishop = (x1, y1, x2, y2)=>{\n    return $6478a7cdda5927f6$var$diff(x1, x2) === $6478a7cdda5927f6$var$diff(y1, y2);\n};\nconst $6478a7cdda5927f6$var$rook = (x1, y1, x2, y2)=>{\n    return x1 === x2 || y1 === y2;\n};\nconst $6478a7cdda5927f6$export$b9d1aa6d9cf991c6 = (x1, y1, x2, y2)=>{\n    return $6478a7cdda5927f6$var$bishop(x1, y1, x2, y2) || $6478a7cdda5927f6$var$rook(x1, y1, x2, y2);\n};\nconst $6478a7cdda5927f6$var$king = (color, rookFiles, canCastle)=>(x1, y1, x2, y2)=>$6478a7cdda5927f6$var$diff(x1, x2) < 2 && $6478a7cdda5927f6$var$diff(y1, y2) < 2 || canCastle && y1 === y2 && y1 === (color === 'white' ? 0 : 7) && (x1 === 4 && (x2 === 2 && rookFiles.includes(0) || x2 === 6 && rookFiles.includes(7)) || rookFiles.includes(x2));\nfunction $6478a7cdda5927f6$var$rookFilesOf(pieces, color) {\n    const backrank = color === 'white' ? '1' : '8';\n    const files = [];\n    for (const [key, piece] of pieces)if (key[1] === backrank && piece.color === color && piece.role === 'rook') files.push($e845129b04f677bd$export$e2878eba51f22d11(key)[0]);\n    return files;\n}\nfunction $6478a7cdda5927f6$export$99ff1a176ab1ff90(pieces, key, canCastle) {\n    const piece = pieces.get(key);\n    if (!piece) return [];\n    const pos = $e845129b04f677bd$export$e2878eba51f22d11(key), r = piece.role, mobility = r === 'pawn' ? $6478a7cdda5927f6$var$pawn(piece.color) : r === 'knight' ? $6478a7cdda5927f6$export$5584fb45fd3a6d08 : r === 'bishop' ? $6478a7cdda5927f6$var$bishop : r === 'rook' ? $6478a7cdda5927f6$var$rook : r === 'queen' ? $6478a7cdda5927f6$export$b9d1aa6d9cf991c6 : $6478a7cdda5927f6$var$king(piece.color, $6478a7cdda5927f6$var$rookFilesOf(pieces, piece.color), canCastle);\n    return $e845129b04f677bd$export$26773b74d67e09c2.filter((pos2)=>(pos[0] !== pos2[0] || pos[1] !== pos2[1]) && mobility(pos[0], pos[1], pos2[0], pos2[1])).map($e845129b04f677bd$export$fe9f8b727818c0ae);\n}\n\n\nfunction $362ede749680455b$export$6511920ae9f0cd34(f, ...args) {\n    if (f) setTimeout(()=>f(...args), 1);\n}\nfunction $362ede749680455b$export$e798007c48b456cd(state) {\n    state.orientation = (0, $e845129b04f677bd$export$a27c3a1c44ba515b)(state.orientation);\n    state.animation.current = state.draggable.current = state.selected = undefined;\n}\nfunction $362ede749680455b$export$aad8462122ac592b(state) {\n    state.lastMove = undefined;\n    $362ede749680455b$export$fe412c270a34f415(state);\n    $362ede749680455b$export$f92a111f74a3f7c7(state);\n    $362ede749680455b$export$9e6f418e5ea6b92c(state);\n}\nfunction $362ede749680455b$export$20a063d1402ff7ff(state, pieces) {\n    for (const [key, piece] of pieces)if (piece) state.pieces.set(key, piece);\n    else state.pieces.delete(key);\n}\nfunction $362ede749680455b$export$6503933b06013bb6(state, color) {\n    state.check = undefined;\n    if (color === true) color = state.turnColor;\n    if (color) {\n        for (const [k, p] of state.pieces)if (p.role === 'king' && p.color === color) state.check = k;\n    }\n}\nfunction $362ede749680455b$var$setPremove(state, orig, dest, meta) {\n    $362ede749680455b$export$9e6f418e5ea6b92c(state);\n    state.premovable.current = [\n        orig,\n        dest\n    ];\n    $362ede749680455b$export$6511920ae9f0cd34(state.premovable.events.set, orig, dest, meta);\n}\nfunction $362ede749680455b$export$f92a111f74a3f7c7(state) {\n    if (state.premovable.current) {\n        state.premovable.current = undefined;\n        $362ede749680455b$export$6511920ae9f0cd34(state.premovable.events.unset);\n    }\n}\nfunction $362ede749680455b$var$setPredrop(state, role, key) {\n    $362ede749680455b$export$f92a111f74a3f7c7(state);\n    state.predroppable.current = {\n        role: role,\n        key: key\n    };\n    $362ede749680455b$export$6511920ae9f0cd34(state.predroppable.events.set, role, key);\n}\nfunction $362ede749680455b$export$9e6f418e5ea6b92c(state) {\n    const pd = state.predroppable;\n    if (pd.current) {\n        pd.current = undefined;\n        $362ede749680455b$export$6511920ae9f0cd34(pd.events.unset);\n    }\n}\nfunction $362ede749680455b$var$tryAutoCastle(state, orig, dest) {\n    if (!state.autoCastle) return false;\n    const king = state.pieces.get(orig);\n    if (!king || king.role !== 'king') return false;\n    const origPos = (0, $e845129b04f677bd$export$e2878eba51f22d11)(orig);\n    const destPos = (0, $e845129b04f677bd$export$e2878eba51f22d11)(dest);\n    if (origPos[1] !== 0 && origPos[1] !== 7 || origPos[1] !== destPos[1]) return false;\n    if (origPos[0] === 4 && !state.pieces.has(dest)) {\n        if (destPos[0] === 6) dest = (0, $e845129b04f677bd$export$fe9f8b727818c0ae)([\n            7,\n            destPos[1]\n        ]);\n        else if (destPos[0] === 2) dest = (0, $e845129b04f677bd$export$fe9f8b727818c0ae)([\n            0,\n            destPos[1]\n        ]);\n    }\n    const rook = state.pieces.get(dest);\n    if (!rook || rook.color !== king.color || rook.role !== 'rook') return false;\n    state.pieces.delete(orig);\n    state.pieces.delete(dest);\n    if (origPos[0] < destPos[0]) {\n        state.pieces.set((0, $e845129b04f677bd$export$fe9f8b727818c0ae)([\n            6,\n            destPos[1]\n        ]), king);\n        state.pieces.set((0, $e845129b04f677bd$export$fe9f8b727818c0ae)([\n            5,\n            destPos[1]\n        ]), rook);\n    } else {\n        state.pieces.set((0, $e845129b04f677bd$export$fe9f8b727818c0ae)([\n            2,\n            destPos[1]\n        ]), king);\n        state.pieces.set((0, $e845129b04f677bd$export$fe9f8b727818c0ae)([\n            3,\n            destPos[1]\n        ]), rook);\n    }\n    return true;\n}\nfunction $362ede749680455b$export$13f6ca6271343510(state, orig, dest) {\n    const origPiece = state.pieces.get(orig), destPiece = state.pieces.get(dest);\n    if (orig === dest || !origPiece) return false;\n    const captured = destPiece && destPiece.color !== origPiece.color ? destPiece : undefined;\n    if (dest === state.selected) $362ede749680455b$export$fe412c270a34f415(state);\n    $362ede749680455b$export$6511920ae9f0cd34(state.events.move, orig, dest, captured);\n    if (!$362ede749680455b$var$tryAutoCastle(state, orig, dest)) {\n        state.pieces.set(dest, origPiece);\n        state.pieces.delete(orig);\n    }\n    state.lastMove = [\n        orig,\n        dest\n    ];\n    state.check = undefined;\n    $362ede749680455b$export$6511920ae9f0cd34(state.events.change);\n    return captured || true;\n}\nfunction $362ede749680455b$export$13886f9573facc29(state, piece, key, force) {\n    if (state.pieces.has(key)) {\n        if (force) state.pieces.delete(key);\n        else return false;\n    }\n    $362ede749680455b$export$6511920ae9f0cd34(state.events.dropNewPiece, piece, key);\n    state.pieces.set(key, piece);\n    state.lastMove = [\n        key\n    ];\n    state.check = undefined;\n    $362ede749680455b$export$6511920ae9f0cd34(state.events.change);\n    state.movable.dests = undefined;\n    state.turnColor = (0, $e845129b04f677bd$export$a27c3a1c44ba515b)(state.turnColor);\n    return true;\n}\nfunction $362ede749680455b$var$baseUserMove(state, orig, dest) {\n    const result = $362ede749680455b$export$13f6ca6271343510(state, orig, dest);\n    if (result) {\n        state.movable.dests = undefined;\n        state.turnColor = (0, $e845129b04f677bd$export$a27c3a1c44ba515b)(state.turnColor);\n        state.animation.current = undefined;\n    }\n    return result;\n}\nfunction $362ede749680455b$export$843c446e2e718822(state, orig, dest) {\n    if ($362ede749680455b$export$a4ef2b0c3fa55ad2(state, orig, dest)) {\n        const result = $362ede749680455b$var$baseUserMove(state, orig, dest);\n        if (result) {\n            const holdTime = state.hold.stop();\n            $362ede749680455b$export$fe412c270a34f415(state);\n            const metadata = {\n                premove: false,\n                ctrlKey: state.stats.ctrlKey,\n                holdTime: holdTime\n            };\n            if (result !== true) metadata.captured = result;\n            $362ede749680455b$export$6511920ae9f0cd34(state.movable.events.after, orig, dest, metadata);\n            return true;\n        }\n    } else if ($362ede749680455b$var$canPremove(state, orig, dest)) {\n        $362ede749680455b$var$setPremove(state, orig, dest, {\n            ctrlKey: state.stats.ctrlKey\n        });\n        $362ede749680455b$export$fe412c270a34f415(state);\n        return true;\n    }\n    $362ede749680455b$export$fe412c270a34f415(state);\n    return false;\n}\nfunction $362ede749680455b$export$b2b9f46b948033b0(state, orig, dest, force) {\n    const piece = state.pieces.get(orig);\n    if (piece && ($362ede749680455b$var$canDrop(state, orig, dest) || force)) {\n        state.pieces.delete(orig);\n        $362ede749680455b$export$13886f9573facc29(state, piece, dest, force);\n        $362ede749680455b$export$6511920ae9f0cd34(state.movable.events.afterNewPiece, piece.role, dest, {\n            premove: false,\n            predrop: false\n        });\n    } else if (piece && $362ede749680455b$var$canPredrop(state, orig, dest)) $362ede749680455b$var$setPredrop(state, piece.role, dest);\n    else {\n        $362ede749680455b$export$f92a111f74a3f7c7(state);\n        $362ede749680455b$export$9e6f418e5ea6b92c(state);\n    }\n    state.pieces.delete(orig);\n    $362ede749680455b$export$fe412c270a34f415(state);\n}\nfunction $362ede749680455b$export$6073914ea697a63e(state, key, force) {\n    $362ede749680455b$export$6511920ae9f0cd34(state.events.select, key);\n    if (state.selected) {\n        if (state.selected === key && !state.draggable.enabled) {\n            $362ede749680455b$export$fe412c270a34f415(state);\n            state.hold.cancel();\n            return;\n        } else if ((state.selectable.enabled || force) && state.selected !== key) {\n            if ($362ede749680455b$export$843c446e2e718822(state, state.selected, key)) {\n                state.stats.dragged = false;\n                return;\n            }\n        }\n    }\n    if ((state.selectable.enabled || state.draggable.enabled) && ($362ede749680455b$var$isMovable(state, key) || $362ede749680455b$var$isPremovable(state, key))) {\n        $362ede749680455b$export$5a4818cec1656a71(state, key);\n        state.hold.start();\n    }\n}\nfunction $362ede749680455b$export$5a4818cec1656a71(state, key) {\n    state.selected = key;\n    if ($362ede749680455b$var$isPremovable(state, key)) // calculate chess premoves if custom premoves are not passed\n    {\n        if (!state.premovable.customDests) state.premovable.dests = (0, $6478a7cdda5927f6$export$99ff1a176ab1ff90)(state.pieces, key, state.premovable.castle);\n    } else state.premovable.dests = undefined;\n}\nfunction $362ede749680455b$export$fe412c270a34f415(state) {\n    state.selected = undefined;\n    state.premovable.dests = undefined;\n    state.hold.cancel();\n}\nfunction $362ede749680455b$var$isMovable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return !!piece && (state.movable.color === 'both' || state.movable.color === piece.color && state.turnColor === piece.color);\n}\nconst $362ede749680455b$export$a4ef2b0c3fa55ad2 = (state, orig, dest)=>{\n    var _a, _b;\n    return orig !== dest && $362ede749680455b$var$isMovable(state, orig) && (state.movable.free || !!((_b = (_a = state.movable.dests) === null || _a === void 0 ? void 0 : _a.get(orig)) === null || _b === void 0 ? void 0 : _b.includes(dest)));\n};\nfunction $362ede749680455b$var$canDrop(state, orig, dest) {\n    const piece = state.pieces.get(orig);\n    return !!piece && (orig === dest || !state.pieces.has(dest)) && (state.movable.color === 'both' || state.movable.color === piece.color && state.turnColor === piece.color);\n}\nfunction $362ede749680455b$var$isPremovable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return !!piece && state.premovable.enabled && state.movable.color === piece.color && state.turnColor !== piece.color;\n}\nfunction $362ede749680455b$var$canPremove(state, orig, dest) {\n    var _a, _b;\n    const validPremoves = (_b = (_a = state.premovable.customDests) === null || _a === void 0 ? void 0 : _a.get(orig)) !== null && _b !== void 0 ? _b : (0, $6478a7cdda5927f6$export$99ff1a176ab1ff90)(state.pieces, orig, state.premovable.castle);\n    return orig !== dest && $362ede749680455b$var$isPremovable(state, orig) && validPremoves.includes(dest);\n}\nfunction $362ede749680455b$var$canPredrop(state, orig, dest) {\n    const piece = state.pieces.get(orig);\n    const destPiece = state.pieces.get(dest);\n    return !!piece && (!destPiece || destPiece.color !== state.movable.color) && state.predroppable.enabled && (piece.role !== 'pawn' || dest[1] !== '1' && dest[1] !== '8') && state.movable.color === piece.color && state.turnColor !== piece.color;\n}\nfunction $362ede749680455b$export$fe8f97248bbe2d04(state, orig) {\n    const piece = state.pieces.get(orig);\n    return !!piece && state.draggable.enabled && (state.movable.color === 'both' || state.movable.color === piece.color && (state.turnColor === piece.color || state.premovable.enabled));\n}\nfunction $362ede749680455b$export$d04320a93cdae73d(state) {\n    const move = state.premovable.current;\n    if (!move) return false;\n    const orig = move[0], dest = move[1];\n    let success = false;\n    if ($362ede749680455b$export$a4ef2b0c3fa55ad2(state, orig, dest)) {\n        const result = $362ede749680455b$var$baseUserMove(state, orig, dest);\n        if (result) {\n            const metadata = {\n                premove: true\n            };\n            if (result !== true) metadata.captured = result;\n            $362ede749680455b$export$6511920ae9f0cd34(state.movable.events.after, orig, dest, metadata);\n            success = true;\n        }\n    }\n    $362ede749680455b$export$f92a111f74a3f7c7(state);\n    return success;\n}\nfunction $362ede749680455b$export$8efa9460c0cedd9e(state, validate) {\n    const drop = state.predroppable.current;\n    let success = false;\n    if (!drop) return false;\n    if (validate(drop)) {\n        const piece = {\n            role: drop.role,\n            color: state.movable.color\n        };\n        if ($362ede749680455b$export$13886f9573facc29(state, piece, drop.key)) {\n            $362ede749680455b$export$6511920ae9f0cd34(state.movable.events.afterNewPiece, drop.role, drop.key, {\n                premove: false,\n                predrop: true\n            });\n            success = true;\n        }\n    }\n    $362ede749680455b$export$9e6f418e5ea6b92c(state);\n    return success;\n}\nfunction $362ede749680455b$export$e47a3d6268102bb5(state) {\n    $362ede749680455b$export$f92a111f74a3f7c7(state);\n    $362ede749680455b$export$9e6f418e5ea6b92c(state);\n    $362ede749680455b$export$fe412c270a34f415(state);\n}\nfunction $362ede749680455b$export$fa6813432f753b0d(state) {\n    state.movable.color = state.movable.dests = state.animation.current = undefined;\n    $362ede749680455b$export$e47a3d6268102bb5(state);\n}\nfunction $362ede749680455b$export$102bdd581884418b(pos, asWhite, bounds) {\n    let file = Math.floor(8 * (pos[0] - bounds.left) / bounds.width);\n    if (!asWhite) file = 7 - file;\n    let rank = 7 - Math.floor(8 * (pos[1] - bounds.top) / bounds.height);\n    if (!asWhite) rank = 7 - rank;\n    return file >= 0 && file < 8 && rank >= 0 && rank < 8 ? (0, $e845129b04f677bd$export$fe9f8b727818c0ae)([\n        file,\n        rank\n    ]) : undefined;\n}\nfunction $362ede749680455b$export$6ee499125a88eb43(orig, pos, asWhite, bounds) {\n    const origPos = (0, $e845129b04f677bd$export$e2878eba51f22d11)(orig);\n    const validSnapPos = (0, $e845129b04f677bd$export$26773b74d67e09c2).filter((pos2)=>(0, $6478a7cdda5927f6$export$b9d1aa6d9cf991c6)(origPos[0], origPos[1], pos2[0], pos2[1]) || (0, $6478a7cdda5927f6$export$5584fb45fd3a6d08)(origPos[0], origPos[1], pos2[0], pos2[1]));\n    const validSnapCenters = validSnapPos.map((pos2)=>(0, $e845129b04f677bd$export$1c17f680299a31f7)((0, $e845129b04f677bd$export$fe9f8b727818c0ae)(pos2), asWhite, bounds));\n    const validSnapDistances = validSnapCenters.map((pos2)=>(0, $e845129b04f677bd$export$e4884e1734dcd545)(pos, pos2));\n    const [, closestSnapIndex] = validSnapDistances.reduce((a, b, index)=>a[0] < b ? a : [\n            b,\n            index\n        ], [\n        validSnapDistances[0],\n        0\n    ]);\n    return (0, $e845129b04f677bd$export$fe9f8b727818c0ae)(validSnapPos[closestSnapIndex]);\n}\nconst $362ede749680455b$export$970133fdf67d86cb = (s)=>s.orientation === 'white';\n\n\n\n\nconst $283b3759973e0b3f$export$59ff82fc918bd7e3 = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\nconst $283b3759973e0b3f$var$roles = {\n    p: 'pawn',\n    r: 'rook',\n    n: 'knight',\n    b: 'bishop',\n    q: 'queen',\n    k: 'king'\n};\nconst $283b3759973e0b3f$var$letters = {\n    pawn: 'p',\n    rook: 'r',\n    knight: 'n',\n    bishop: 'b',\n    queen: 'q',\n    king: 'k'\n};\nfunction $283b3759973e0b3f$export$aafa59e2e03f2942(fen) {\n    if (fen === 'start') fen = $283b3759973e0b3f$export$59ff82fc918bd7e3;\n    const pieces = new Map();\n    let row = 7, col = 0;\n    for (const c of fen)switch(c){\n        case ' ':\n        case '[':\n            return pieces;\n        case '/':\n            --row;\n            if (row < 0) return pieces;\n            col = 0;\n            break;\n        case '~':\n            {\n                const piece = pieces.get((0, $e845129b04f677bd$export$fe9f8b727818c0ae)([\n                    col - 1,\n                    row\n                ]));\n                if (piece) piece.promoted = true;\n                break;\n            }\n        default:\n            {\n                const nb = c.charCodeAt(0);\n                if (nb < 57) col += nb - 48;\n                else {\n                    const role = c.toLowerCase();\n                    pieces.set((0, $e845129b04f677bd$export$fe9f8b727818c0ae)([\n                        col,\n                        row\n                    ]), {\n                        role: $283b3759973e0b3f$var$roles[role],\n                        color: c === role ? 'black' : 'white'\n                    });\n                    ++col;\n                }\n            }\n    }\n    return pieces;\n}\nfunction $283b3759973e0b3f$export$68d8715fc104d294(pieces) {\n    return (0, $e845129b04f677bd$export$978f7ef4c67d166e).map((y)=>$a9912b1579309d38$export$3a444357c5f65f65.map((x)=>{\n            const piece = pieces.get(x + y);\n            if (piece) {\n                let p = $283b3759973e0b3f$var$letters[piece.role];\n                if (piece.color === 'white') p = p.toUpperCase();\n                if (piece.promoted) p += '~';\n                return p;\n            } else return '1';\n        }).join('')).join('/').replace(/1{2,}/g, (s)=>s.length.toString());\n}\n\n\n\n\nfunction $d854d6e3b9054dcc$export$d771543c4ed87064(state, config) {\n    if (config.animation) {\n        $d854d6e3b9054dcc$var$deepMerge(state.animation, config.animation);\n        // no need for such short animations\n        if ((state.animation.duration || 0) < 70) state.animation.enabled = false;\n    }\n}\nfunction $d854d6e3b9054dcc$export$8d21e34596265fa2(state, config) {\n    var _a, _b, _c;\n    // don't merge destinations and autoShapes. Just override.\n    if ((_a = config.movable) === null || _a === void 0 ? void 0 : _a.dests) state.movable.dests = undefined;\n    if ((_b = config.drawable) === null || _b === void 0 ? void 0 : _b.autoShapes) state.drawable.autoShapes = [];\n    $d854d6e3b9054dcc$var$deepMerge(state, config);\n    // if a fen was provided, replace the pieces\n    if (config.fen) {\n        state.pieces = (0, $283b3759973e0b3f$export$aafa59e2e03f2942)(config.fen);\n        state.drawable.shapes = ((_c = config.drawable) === null || _c === void 0 ? void 0 : _c.shapes) || [];\n    }\n    // apply config values that could be undefined yet meaningful\n    if ('check' in config) (0, $362ede749680455b$export$6503933b06013bb6)(state, config.check || false);\n    if ('lastMove' in config && !config.lastMove) state.lastMove = undefined;\n    else if (config.lastMove) state.lastMove = config.lastMove;\n    // fix move/premove dests\n    if (state.selected) (0, $362ede749680455b$export$5a4818cec1656a71)(state, state.selected);\n    $d854d6e3b9054dcc$export$d771543c4ed87064(state, config);\n    if (!state.movable.rookCastle && state.movable.dests) {\n        const rank = state.movable.color === 'white' ? '1' : '8', kingStartPos = 'e' + rank, dests = state.movable.dests.get(kingStartPos), king = state.pieces.get(kingStartPos);\n        if (!dests || !king || king.role !== 'king') return;\n        state.movable.dests.set(kingStartPos, dests.filter((d)=>!(d === 'a' + rank && dests.includes('c' + rank)) && !(d === 'h' + rank && dests.includes('g' + rank))));\n    }\n}\nfunction $d854d6e3b9054dcc$var$deepMerge(base, extend) {\n    for(const key in extend)if (Object.prototype.hasOwnProperty.call(extend, key)) {\n        if (Object.prototype.hasOwnProperty.call(base, key) && $d854d6e3b9054dcc$var$isPlainObject(base[key]) && $d854d6e3b9054dcc$var$isPlainObject(extend[key])) $d854d6e3b9054dcc$var$deepMerge(base[key], extend[key]);\n        else base[key] = extend[key];\n    }\n}\nfunction $d854d6e3b9054dcc$var$isPlainObject(o) {\n    if (typeof o !== 'object' || o === null) return false;\n    const proto = Object.getPrototypeOf(o);\n    return proto === Object.prototype || proto === null;\n}\n\n\n\nconst $4862821e78925973$export$bd46b8ab3689edc4 = (mutation, state)=>state.animation.enabled ? $4862821e78925973$var$animate(mutation, state) : $4862821e78925973$export$b3890eb0ae9dca99(mutation, state);\nfunction $4862821e78925973$export$b3890eb0ae9dca99(mutation, state) {\n    const result = mutation(state);\n    state.dom.redraw();\n    return result;\n}\nconst $4862821e78925973$var$makePiece = (key, piece)=>({\n        key: key,\n        pos: $e845129b04f677bd$export$e2878eba51f22d11(key),\n        piece: piece\n    });\nconst $4862821e78925973$var$closer = (piece, pieces)=>pieces.sort((p1, p2)=>$e845129b04f677bd$export$e4884e1734dcd545(piece.pos, p1.pos) - $e845129b04f677bd$export$e4884e1734dcd545(piece.pos, p2.pos))[0];\nfunction $4862821e78925973$var$computePlan(prevPieces, current) {\n    const anims = new Map(), animedOrigs = [], fadings = new Map(), missings = [], news = [], prePieces = new Map();\n    let curP, preP, vector;\n    for (const [k, p] of prevPieces)prePieces.set(k, $4862821e78925973$var$makePiece(k, p));\n    for (const key of $e845129b04f677bd$export$ade7a30951d0bc54){\n        curP = current.pieces.get(key);\n        preP = prePieces.get(key);\n        if (curP) {\n            if (preP) {\n                if (!$e845129b04f677bd$export$e329b1a538c004fa(curP, preP.piece)) {\n                    missings.push(preP);\n                    news.push($4862821e78925973$var$makePiece(key, curP));\n                }\n            } else news.push($4862821e78925973$var$makePiece(key, curP));\n        } else if (preP) missings.push(preP);\n    }\n    for (const newP of news){\n        preP = $4862821e78925973$var$closer(newP, missings.filter((p)=>$e845129b04f677bd$export$e329b1a538c004fa(newP.piece, p.piece)));\n        if (preP) {\n            vector = [\n                preP.pos[0] - newP.pos[0],\n                preP.pos[1] - newP.pos[1]\n            ];\n            anims.set(newP.key, vector.concat(vector));\n            animedOrigs.push(preP.key);\n        }\n    }\n    for (const p of missings)if (!animedOrigs.includes(p.key)) fadings.set(p.key, p.piece);\n    return {\n        anims: anims,\n        fadings: fadings\n    };\n}\nfunction $4862821e78925973$var$step(state, now) {\n    const cur = state.animation.current;\n    if (cur === undefined) {\n        // animation was canceled :(\n        if (!state.dom.destroyed) state.dom.redrawNow();\n        return;\n    }\n    const rest = 1 - (now - cur.start) * cur.frequency;\n    if (rest <= 0) {\n        state.animation.current = undefined;\n        state.dom.redrawNow();\n    } else {\n        const ease = $4862821e78925973$var$easing(rest);\n        for (const cfg of cur.plan.anims.values()){\n            cfg[2] = cfg[0] * ease;\n            cfg[3] = cfg[1] * ease;\n        }\n        state.dom.redrawNow(true); // optimisation: don't render SVG changes during animations\n        requestAnimationFrame((now = performance.now())=>$4862821e78925973$var$step(state, now));\n    }\n}\nfunction $4862821e78925973$var$animate(mutation, state) {\n    // clone state before mutating it\n    const prevPieces = new Map(state.pieces);\n    const result = mutation(state);\n    const plan = $4862821e78925973$var$computePlan(prevPieces, state);\n    if (plan.anims.size || plan.fadings.size) {\n        const alreadyRunning = state.animation.current && state.animation.current.start;\n        state.animation.current = {\n            start: performance.now(),\n            frequency: 1 / state.animation.duration,\n            plan: plan\n        };\n        if (!alreadyRunning) $4862821e78925973$var$step(state, performance.now());\n    } else // don't animate, just render right away\n    state.dom.redraw();\n    return result;\n}\n// https://gist.github.com/gre/1650294\nconst $4862821e78925973$var$easing = (t)=>t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n\n\n\n\n\n\nconst $e4dfa114a4df3bca$var$brushes = [\n    'green',\n    'red',\n    'blue',\n    'yellow'\n];\nfunction $e4dfa114a4df3bca$export$b3571188c770cc5a(state, e) {\n    // support one finger touch only\n    if (e.touches && e.touches.length > 1) return;\n    e.stopPropagation();\n    e.preventDefault();\n    e.ctrlKey ? (0, $362ede749680455b$export$fe412c270a34f415)(state) : (0, $362ede749680455b$export$e47a3d6268102bb5)(state);\n    const pos = (0, $e845129b04f677bd$export$33052595192f7117)(e), orig = (0, $362ede749680455b$export$102bdd581884418b)(pos, (0, $362ede749680455b$export$970133fdf67d86cb)(state), state.dom.bounds());\n    if (!orig) return;\n    state.drawable.current = {\n        orig: orig,\n        pos: pos,\n        brush: $e4dfa114a4df3bca$var$eventBrush(e),\n        snapToValidMove: state.drawable.defaultSnapToValidMove\n    };\n    $e4dfa114a4df3bca$export$816e7b21815d9cf9(state);\n}\nfunction $e4dfa114a4df3bca$export$816e7b21815d9cf9(state) {\n    requestAnimationFrame(()=>{\n        const cur = state.drawable.current;\n        if (cur) {\n            const keyAtDomPos = (0, $362ede749680455b$export$102bdd581884418b)(cur.pos, (0, $362ede749680455b$export$970133fdf67d86cb)(state), state.dom.bounds());\n            if (!keyAtDomPos) cur.snapToValidMove = false;\n            const mouseSq = cur.snapToValidMove ? (0, $362ede749680455b$export$6ee499125a88eb43)(cur.orig, cur.pos, (0, $362ede749680455b$export$970133fdf67d86cb)(state), state.dom.bounds()) : keyAtDomPos;\n            if (mouseSq !== cur.mouseSq) {\n                cur.mouseSq = mouseSq;\n                cur.dest = mouseSq !== cur.orig ? mouseSq : undefined;\n                state.dom.redrawNow();\n            }\n            $e4dfa114a4df3bca$export$816e7b21815d9cf9(state);\n        }\n    });\n}\nfunction $e4dfa114a4df3bca$export$d947e5f4f4c48d48(state, e) {\n    if (state.drawable.current) state.drawable.current.pos = (0, $e845129b04f677bd$export$33052595192f7117)(e);\n}\nfunction $e4dfa114a4df3bca$export$bd5df0f255a350f8(state) {\n    const cur = state.drawable.current;\n    if (cur) {\n        if (cur.mouseSq) $e4dfa114a4df3bca$var$addShape(state.drawable, cur);\n        $e4dfa114a4df3bca$export$70b61ad426ddbe54(state);\n    }\n}\nfunction $e4dfa114a4df3bca$export$70b61ad426ddbe54(state) {\n    if (state.drawable.current) {\n        state.drawable.current = undefined;\n        state.dom.redraw();\n    }\n}\nfunction $e4dfa114a4df3bca$export$42ffd38884aecdac(state) {\n    if (state.drawable.shapes.length) {\n        state.drawable.shapes = [];\n        state.dom.redraw();\n        $e4dfa114a4df3bca$var$onChange(state.drawable);\n    }\n}\nfunction $e4dfa114a4df3bca$var$eventBrush(e) {\n    var _a;\n    const modA = (e.shiftKey || e.ctrlKey) && (0, $e845129b04f677bd$export$947a472b5b3020ba)(e);\n    const modB = e.altKey || e.metaKey || ((_a = e.getModifierState) === null || _a === void 0 ? void 0 : _a.call(e, 'AltGraph'));\n    return $e4dfa114a4df3bca$var$brushes[(modA ? 1 : 0) + (modB ? 2 : 0)];\n}\nfunction $e4dfa114a4df3bca$var$addShape(drawable, cur) {\n    const sameShape = (s)=>s.orig === cur.orig && s.dest === cur.dest;\n    const similar = drawable.shapes.find(sameShape);\n    if (similar) drawable.shapes = drawable.shapes.filter((s)=>!sameShape(s));\n    if (!similar || similar.brush !== cur.brush) drawable.shapes.push({\n        orig: cur.orig,\n        dest: cur.dest,\n        brush: cur.brush\n    });\n    $e4dfa114a4df3bca$var$onChange(drawable);\n}\nfunction $e4dfa114a4df3bca$var$onChange(drawable) {\n    if (drawable.onChange) drawable.onChange(drawable.shapes);\n}\n\n\n\nfunction $f0622fe2c415ff29$export$b3571188c770cc5a(s, e) {\n    if (!(s.trustAllEvents || e.isTrusted)) return; // only trust when trustAllEvents is enabled\n    if (e.buttons !== undefined && e.buttons > 1) return; // only touch or left click\n    if (e.touches && e.touches.length > 1) return; // support one finger touch only\n    const bounds = s.dom.bounds(), position = $e845129b04f677bd$export$33052595192f7117(e), orig = $362ede749680455b$export$102bdd581884418b(position, $362ede749680455b$export$970133fdf67d86cb(s), bounds);\n    if (!orig) return;\n    const piece = s.pieces.get(orig);\n    const previouslySelected = s.selected;\n    if (!previouslySelected && s.drawable.enabled && (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor)) (0, $e4dfa114a4df3bca$export$42ffd38884aecdac)(s);\n    // Prevent touch scroll and create no corresponding mouse event, if there\n    // is an intent to interact with the board.\n    if (e.cancelable !== false && (!e.touches || s.blockTouchScroll || piece || previouslySelected || $f0622fe2c415ff29$var$pieceCloseTo(s, position))) e.preventDefault();\n    else if (e.touches) return; // Handle only corresponding mouse event https://github.com/lichess-org/chessground/pull/268\n    const hadPremove = !!s.premovable.current;\n    const hadPredrop = !!s.predroppable.current;\n    s.stats.ctrlKey = e.ctrlKey;\n    if (s.selected && $362ede749680455b$export$a4ef2b0c3fa55ad2(s, s.selected, orig)) (0, $4862821e78925973$export$bd46b8ab3689edc4)((state)=>$362ede749680455b$export$6073914ea697a63e(state, orig), s);\n    else $362ede749680455b$export$6073914ea697a63e(s, orig);\n    const stillSelected = s.selected === orig;\n    const element = $f0622fe2c415ff29$var$pieceElementByKey(s, orig);\n    if (piece && element && stillSelected && $362ede749680455b$export$fe8f97248bbe2d04(s, orig)) {\n        s.draggable.current = {\n            orig: orig,\n            piece: piece,\n            origPos: position,\n            pos: position,\n            started: s.draggable.autoDistance && s.stats.dragged,\n            element: element,\n            previouslySelected: previouslySelected,\n            originTarget: e.target,\n            keyHasChanged: false\n        };\n        element.cgDragging = true;\n        element.classList.add('dragging');\n        // place ghost\n        const ghost = s.dom.elements.ghost;\n        if (ghost) {\n            ghost.className = `ghost ${piece.color} ${piece.role}`;\n            $e845129b04f677bd$export$d73ee8ef04f5226a(ghost, $e845129b04f677bd$export$2135ad75550a2ff4(bounds)($e845129b04f677bd$export$e2878eba51f22d11(orig), $362ede749680455b$export$970133fdf67d86cb(s)));\n            $e845129b04f677bd$export$8cb512849e51eaf5(ghost, true);\n        }\n        $f0622fe2c415ff29$var$processDrag(s);\n    } else {\n        if (hadPremove) $362ede749680455b$export$f92a111f74a3f7c7(s);\n        if (hadPredrop) $362ede749680455b$export$9e6f418e5ea6b92c(s);\n    }\n    s.dom.redraw();\n}\nfunction $f0622fe2c415ff29$var$pieceCloseTo(s, pos) {\n    const asWhite = $362ede749680455b$export$970133fdf67d86cb(s), bounds = s.dom.bounds(), radiusSq = Math.pow(bounds.width / 8, 2);\n    for (const key of s.pieces.keys()){\n        const center = $e845129b04f677bd$export$1c17f680299a31f7(key, asWhite, bounds);\n        if ($e845129b04f677bd$export$e4884e1734dcd545(center, pos) <= radiusSq) return true;\n    }\n    return false;\n}\nfunction $f0622fe2c415ff29$export$65771a6862d302e4(s, piece, e, force) {\n    const key = 'a0';\n    s.pieces.set(key, piece);\n    s.dom.redraw();\n    const position = $e845129b04f677bd$export$33052595192f7117(e);\n    s.draggable.current = {\n        orig: key,\n        piece: piece,\n        origPos: position,\n        pos: position,\n        started: true,\n        element: ()=>$f0622fe2c415ff29$var$pieceElementByKey(s, key),\n        originTarget: e.target,\n        newPiece: true,\n        force: !!force,\n        keyHasChanged: false\n    };\n    $f0622fe2c415ff29$var$processDrag(s);\n}\nfunction $f0622fe2c415ff29$var$processDrag(s) {\n    requestAnimationFrame(()=>{\n        var _a;\n        const cur = s.draggable.current;\n        if (!cur) return;\n        // cancel animations while dragging\n        if ((_a = s.animation.current) === null || _a === void 0 ? void 0 : _a.plan.anims.has(cur.orig)) s.animation.current = undefined;\n        // if moving piece is gone, cancel\n        const origPiece = s.pieces.get(cur.orig);\n        if (!origPiece || !$e845129b04f677bd$export$e329b1a538c004fa(origPiece, cur.piece)) $f0622fe2c415ff29$export$70b61ad426ddbe54(s);\n        else {\n            if (!cur.started && $e845129b04f677bd$export$e4884e1734dcd545(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2)) cur.started = true;\n            if (cur.started) {\n                // support lazy elements\n                if (typeof cur.element === 'function') {\n                    const found = cur.element();\n                    if (!found) return;\n                    found.cgDragging = true;\n                    found.classList.add('dragging');\n                    cur.element = found;\n                }\n                const bounds = s.dom.bounds();\n                $e845129b04f677bd$export$d73ee8ef04f5226a(cur.element, [\n                    cur.pos[0] - bounds.left - bounds.width / 16,\n                    cur.pos[1] - bounds.top - bounds.height / 16\n                ]);\n                cur.keyHasChanged || (cur.keyHasChanged = cur.orig !== $362ede749680455b$export$102bdd581884418b(cur.pos, $362ede749680455b$export$970133fdf67d86cb(s), bounds));\n            }\n        }\n        $f0622fe2c415ff29$var$processDrag(s);\n    });\n}\nfunction $f0622fe2c415ff29$export$d947e5f4f4c48d48(s, e) {\n    // support one finger touch only\n    if (s.draggable.current && (!e.touches || e.touches.length < 2)) s.draggable.current.pos = $e845129b04f677bd$export$33052595192f7117(e);\n}\nfunction $f0622fe2c415ff29$export$bd5df0f255a350f8(s, e) {\n    const cur = s.draggable.current;\n    if (!cur) return;\n    // create no corresponding mouse event\n    if (e.type === 'touchend' && e.cancelable !== false) e.preventDefault();\n    // comparing with the origin target is an easy way to test that the end event\n    // has the same touch origin\n    if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {\n        s.draggable.current = undefined;\n        return;\n    }\n    $362ede749680455b$export$f92a111f74a3f7c7(s);\n    $362ede749680455b$export$9e6f418e5ea6b92c(s);\n    // touchend has no position; so use the last touchmove position instead\n    const eventPos = $e845129b04f677bd$export$33052595192f7117(e) || cur.pos;\n    const dest = $362ede749680455b$export$102bdd581884418b(eventPos, $362ede749680455b$export$970133fdf67d86cb(s), s.dom.bounds());\n    if (dest && cur.started && cur.orig !== dest) {\n        if (cur.newPiece) $362ede749680455b$export$b2b9f46b948033b0(s, cur.orig, dest, cur.force);\n        else {\n            s.stats.ctrlKey = e.ctrlKey;\n            if ($362ede749680455b$export$843c446e2e718822(s, cur.orig, dest)) s.stats.dragged = true;\n        }\n    } else if (cur.newPiece) s.pieces.delete(cur.orig);\n    else if (s.draggable.deleteOnDropOff && !dest) {\n        s.pieces.delete(cur.orig);\n        $362ede749680455b$export$6511920ae9f0cd34(s.events.change);\n    }\n    if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest)) $362ede749680455b$export$fe412c270a34f415(s);\n    else if (!s.selectable.enabled) $362ede749680455b$export$fe412c270a34f415(s);\n    $f0622fe2c415ff29$var$removeDragElements(s);\n    s.draggable.current = undefined;\n    s.dom.redraw();\n}\nfunction $f0622fe2c415ff29$export$70b61ad426ddbe54(s) {\n    const cur = s.draggable.current;\n    if (cur) {\n        if (cur.newPiece) s.pieces.delete(cur.orig);\n        s.draggable.current = undefined;\n        $362ede749680455b$export$fe412c270a34f415(s);\n        $f0622fe2c415ff29$var$removeDragElements(s);\n        s.dom.redraw();\n    }\n}\nfunction $f0622fe2c415ff29$var$removeDragElements(s) {\n    const e = s.dom.elements;\n    if (e.ghost) $e845129b04f677bd$export$8cb512849e51eaf5(e.ghost, false);\n}\nfunction $f0622fe2c415ff29$var$pieceElementByKey(s, key) {\n    let el = s.dom.elements.board.firstChild;\n    while(el){\n        if (el.cgKey === key && el.tagName === 'PIECE') return el;\n        el = el.nextSibling;\n    }\n    return;\n}\n\n\nfunction $c20cd8d479dc62bc$export$4971bcc2704b21ab(state, keys) {\n    state.exploding = {\n        stage: 1,\n        keys: keys\n    };\n    state.dom.redraw();\n    setTimeout(()=>{\n        $c20cd8d479dc62bc$var$setStage(state, 2);\n        setTimeout(()=>$c20cd8d479dc62bc$var$setStage(state, undefined), 120);\n    }, 120);\n}\nfunction $c20cd8d479dc62bc$var$setStage(state, stage) {\n    if (state.exploding) {\n        if (stage) state.exploding.stage = stage;\n        else state.exploding = undefined;\n        state.dom.redraw();\n    }\n}\n\n\nfunction $33d6df4bf01d7e89$export$b3571188c770cc5a(state, redrawAll) {\n    function toggleOrientation() {\n        $362ede749680455b$export$e798007c48b456cd(state);\n        redrawAll();\n    }\n    return {\n        set (config) {\n            if (config.orientation && config.orientation !== state.orientation) toggleOrientation();\n            (0, $d854d6e3b9054dcc$export$d771543c4ed87064)(state, config);\n            (config.fen ? (0, $4862821e78925973$export$bd46b8ab3689edc4) : (0, $4862821e78925973$export$b3890eb0ae9dca99))((state)=>(0, $d854d6e3b9054dcc$export$8d21e34596265fa2)(state, config), state);\n        },\n        state: state,\n        getFen: ()=>(0, $283b3759973e0b3f$export$68d8715fc104d294)(state.pieces),\n        toggleOrientation: toggleOrientation,\n        setPieces (pieces) {\n            (0, $4862821e78925973$export$bd46b8ab3689edc4)((state)=>$362ede749680455b$export$20a063d1402ff7ff(state, pieces), state);\n        },\n        selectSquare (key, force) {\n            if (key) (0, $4862821e78925973$export$bd46b8ab3689edc4)((state)=>$362ede749680455b$export$6073914ea697a63e(state, key, force), state);\n            else if (state.selected) {\n                $362ede749680455b$export$fe412c270a34f415(state);\n                state.dom.redraw();\n            }\n        },\n        move (orig, dest) {\n            (0, $4862821e78925973$export$bd46b8ab3689edc4)((state)=>$362ede749680455b$export$13f6ca6271343510(state, orig, dest), state);\n        },\n        newPiece (piece, key) {\n            (0, $4862821e78925973$export$bd46b8ab3689edc4)((state)=>$362ede749680455b$export$13886f9573facc29(state, piece, key), state);\n        },\n        playPremove () {\n            if (state.premovable.current) {\n                if ((0, $4862821e78925973$export$bd46b8ab3689edc4)($362ede749680455b$export$d04320a93cdae73d, state)) return true;\n                // if the premove couldn't be played, redraw to clear it up\n                state.dom.redraw();\n            }\n            return false;\n        },\n        playPredrop (validate) {\n            if (state.predroppable.current) {\n                const result = $362ede749680455b$export$8efa9460c0cedd9e(state, validate);\n                state.dom.redraw();\n                return result;\n            }\n            return false;\n        },\n        cancelPremove () {\n            (0, $4862821e78925973$export$b3890eb0ae9dca99)($362ede749680455b$export$f92a111f74a3f7c7, state);\n        },\n        cancelPredrop () {\n            (0, $4862821e78925973$export$b3890eb0ae9dca99)($362ede749680455b$export$9e6f418e5ea6b92c, state);\n        },\n        cancelMove () {\n            (0, $4862821e78925973$export$b3890eb0ae9dca99)((state)=>{\n                $362ede749680455b$export$e47a3d6268102bb5(state);\n                (0, $f0622fe2c415ff29$export$70b61ad426ddbe54)(state);\n            }, state);\n        },\n        stop () {\n            (0, $4862821e78925973$export$b3890eb0ae9dca99)((state)=>{\n                $362ede749680455b$export$fa6813432f753b0d(state);\n                (0, $f0622fe2c415ff29$export$70b61ad426ddbe54)(state);\n            }, state);\n        },\n        explode (keys) {\n            (0, $c20cd8d479dc62bc$export$4971bcc2704b21ab)(state, keys);\n        },\n        setAutoShapes (shapes) {\n            (0, $4862821e78925973$export$b3890eb0ae9dca99)((state)=>state.drawable.autoShapes = shapes, state);\n        },\n        setShapes (shapes) {\n            (0, $4862821e78925973$export$b3890eb0ae9dca99)((state)=>state.drawable.shapes = shapes, state);\n        },\n        getKeyAtDomPos (pos) {\n            return $362ede749680455b$export$102bdd581884418b(pos, $362ede749680455b$export$970133fdf67d86cb(state), state.dom.bounds());\n        },\n        redrawAll: redrawAll,\n        dragNewPiece (piece, event, force) {\n            (0, $f0622fe2c415ff29$export$65771a6862d302e4)(state, piece, event, force);\n        },\n        destroy () {\n            $362ede749680455b$export$fa6813432f753b0d(state);\n            state.dom.unbind && state.dom.unbind();\n            state.dom.destroyed = true;\n        }\n    };\n}\n\n\n\n\n\nfunction $ae73148c37d59020$export$ebe90cb607ad99e() {\n    return {\n        pieces: $283b3759973e0b3f$export$aafa59e2e03f2942($283b3759973e0b3f$export$59ff82fc918bd7e3),\n        orientation: 'white',\n        turnColor: 'white',\n        coordinates: true,\n        coordinatesOnSquares: false,\n        ranksPosition: 'right',\n        autoCastle: true,\n        viewOnly: false,\n        disableContextMenu: false,\n        addPieceZIndex: false,\n        blockTouchScroll: false,\n        pieceKey: false,\n        trustAllEvents: false,\n        highlight: {\n            lastMove: true,\n            check: true\n        },\n        animation: {\n            enabled: true,\n            duration: 200\n        },\n        movable: {\n            free: true,\n            color: 'both',\n            showDests: true,\n            events: {},\n            rookCastle: true\n        },\n        premovable: {\n            enabled: true,\n            showDests: true,\n            castle: true,\n            events: {}\n        },\n        predroppable: {\n            enabled: false,\n            events: {}\n        },\n        draggable: {\n            enabled: true,\n            distance: 3,\n            autoDistance: true,\n            showGhost: true,\n            deleteOnDropOff: false\n        },\n        dropmode: {\n            active: false\n        },\n        selectable: {\n            enabled: true\n        },\n        stats: {\n            // on touchscreen, default to \"tap-tap\" moves\n            // instead of drag\n            dragged: !('ontouchstart' in window)\n        },\n        events: {},\n        drawable: {\n            enabled: true,\n            visible: true,\n            defaultSnapToValidMove: true,\n            eraseOnClick: true,\n            shapes: [],\n            autoShapes: [],\n            brushes: {\n                green: {\n                    key: 'g',\n                    color: '#15781B',\n                    opacity: 1,\n                    lineWidth: 10\n                },\n                red: {\n                    key: 'r',\n                    color: '#882020',\n                    opacity: 1,\n                    lineWidth: 10\n                },\n                blue: {\n                    key: 'b',\n                    color: '#003088',\n                    opacity: 1,\n                    lineWidth: 10\n                },\n                yellow: {\n                    key: 'y',\n                    color: '#e68f00',\n                    opacity: 1,\n                    lineWidth: 10\n                },\n                paleBlue: {\n                    key: 'pb',\n                    color: '#003088',\n                    opacity: 0.4,\n                    lineWidth: 15\n                },\n                paleGreen: {\n                    key: 'pg',\n                    color: '#15781B',\n                    opacity: 0.4,\n                    lineWidth: 15\n                },\n                paleRed: {\n                    key: 'pr',\n                    color: '#882020',\n                    opacity: 0.4,\n                    lineWidth: 15\n                },\n                paleGrey: {\n                    key: 'pgr',\n                    color: '#4a4a4a',\n                    opacity: 0.35,\n                    lineWidth: 15\n                },\n                purple: {\n                    key: 'purple',\n                    color: '#68217a',\n                    opacity: 0.65,\n                    lineWidth: 10\n                },\n                pink: {\n                    key: 'pink',\n                    color: '#ee2080',\n                    opacity: 0.5,\n                    lineWidth: 10\n                },\n                white: {\n                    key: 'white',\n                    color: 'white',\n                    opacity: 1,\n                    lineWidth: 10\n                }\n            },\n            prevSvgHash: ''\n        },\n        hold: (0, $e845129b04f677bd$export$9dc4ecf953986f04)()\n    };\n}\n\n\n\n\n\nconst $624548787bc3efbc$var$hilites = {\n    hilitePrimary: {\n        key: 'hilitePrimary',\n        color: '#3291ff',\n        opacity: 1,\n        lineWidth: 1\n    },\n    hiliteWhite: {\n        key: 'hiliteWhite',\n        color: '#ffffff',\n        opacity: 1,\n        lineWidth: 1\n    }\n};\nfunction $624548787bc3efbc$export$a529cedf94de8dc() {\n    const defs = $624548787bc3efbc$export$c8a8987d4410bf2d('defs');\n    const filter = $624548787bc3efbc$export$74da2cba014bdc09($624548787bc3efbc$export$c8a8987d4410bf2d('filter'), {\n        id: 'cg-filter-blur'\n    });\n    filter.appendChild($624548787bc3efbc$export$74da2cba014bdc09($624548787bc3efbc$export$c8a8987d4410bf2d('feGaussianBlur'), {\n        stdDeviation: '0.019'\n    }));\n    defs.appendChild(filter);\n    return defs;\n}\nfunction $624548787bc3efbc$export$fb80b1b7d7777ee5(state, shapesEl, customsEl) {\n    var _a;\n    const d = state.drawable, curD = d.current, cur = curD && curD.mouseSq ? curD : undefined, dests = new Map(), bounds = state.dom.bounds(), nonPieceAutoShapes = d.autoShapes.filter((autoShape)=>!autoShape.piece);\n    for (const s of d.shapes.concat(nonPieceAutoShapes).concat(cur ? [\n        cur\n    ] : [])){\n        if (!s.dest) continue;\n        const sources = (_a = dests.get(s.dest)) !== null && _a !== void 0 ? _a : new Set(), from = $624548787bc3efbc$var$pos2user($624548787bc3efbc$var$orient((0, $e845129b04f677bd$export$e2878eba51f22d11)(s.orig), state.orientation), bounds), to = $624548787bc3efbc$var$pos2user($624548787bc3efbc$var$orient((0, $e845129b04f677bd$export$e2878eba51f22d11)(s.dest), state.orientation), bounds);\n        sources.add($624548787bc3efbc$var$moveAngle(from, to));\n        dests.set(s.dest, sources);\n    }\n    const shapes = d.shapes.concat(nonPieceAutoShapes).map((s)=>{\n        return {\n            shape: s,\n            current: false,\n            hash: $624548787bc3efbc$var$shapeHash(s, $624548787bc3efbc$var$isShort(s.dest, dests), false, bounds)\n        };\n    });\n    if (cur) shapes.push({\n        shape: cur,\n        current: true,\n        hash: $624548787bc3efbc$var$shapeHash(cur, $624548787bc3efbc$var$isShort(cur.dest, dests), true, bounds)\n    });\n    const fullHash = shapes.map((sc)=>sc.hash).join(';');\n    if (fullHash === state.drawable.prevSvgHash) return;\n    state.drawable.prevSvgHash = fullHash;\n    /*\n      -- DOM hierarchy --\n      <svg class=\"cg-shapes\">      (<= svg)\n        <defs>\n          ...(for brushes)...\n        </defs>\n        <g>\n          ...(for arrows and circles)...\n        </g>\n      </svg>\n      <svg class=\"cg-custom-svgs\"> (<= customSvg)\n        <g>\n          ...(for custom svgs)...\n        </g>\n      </svg>\n    */ const defsEl = shapesEl.querySelector('defs');\n    $624548787bc3efbc$var$syncDefs(d, shapes, defsEl);\n    $624548787bc3efbc$var$syncShapes(shapes, shapesEl.querySelector('g'), customsEl.querySelector('g'), (s)=>$624548787bc3efbc$var$renderShape(state, s, d.brushes, dests, bounds));\n}\n// append only. Don't try to update/remove.\nfunction $624548787bc3efbc$var$syncDefs(d, shapes, defsEl) {\n    var _a;\n    const brushes = new Map();\n    let brush;\n    for (const s of shapes.filter((s)=>s.shape.dest && s.shape.brush)){\n        brush = $624548787bc3efbc$var$makeCustomBrush(d.brushes[s.shape.brush], s.shape.modifiers);\n        if ((_a = s.shape.modifiers) === null || _a === void 0 ? void 0 : _a.hilite) brushes.set($624548787bc3efbc$var$hilite(brush).key, $624548787bc3efbc$var$hilite(brush));\n        brushes.set(brush.key, brush);\n    }\n    const keysInDom = new Set();\n    let el = defsEl.firstElementChild;\n    while(el){\n        keysInDom.add(el.getAttribute('cgKey'));\n        el = el.nextElementSibling;\n    }\n    for (const [key, brush] of brushes.entries())if (!keysInDom.has(key)) defsEl.appendChild($624548787bc3efbc$var$renderMarker(brush));\n}\nfunction $624548787bc3efbc$var$syncShapes(syncables, shapes, customs, renderShape) {\n    const hashesInDom = new Map();\n    for (const sc of syncables)hashesInDom.set(sc.hash, false);\n    for (const root of [\n        shapes,\n        customs\n    ]){\n        const toRemove = [];\n        let el = root.firstElementChild, elHash;\n        while(el){\n            elHash = el.getAttribute('cgHash');\n            if (hashesInDom.has(elHash)) hashesInDom.set(elHash, true);\n            else toRemove.push(el);\n            el = el.nextElementSibling;\n        }\n        for (const el of toRemove)root.removeChild(el);\n    }\n    // insert shapes that are not yet in dom\n    for (const sc of syncables.filter((s)=>!hashesInDom.get(s.hash))){\n        for (const svg of renderShape(sc))if (svg.isCustom) customs.appendChild(svg.el);\n        else shapes.appendChild(svg.el);\n    }\n}\nfunction $624548787bc3efbc$var$shapeHash({ orig: orig, dest: dest, brush: brush, piece: piece, modifiers: modifiers, customSvg: customSvg, label: label }, shorten, current, bounds) {\n    var _a, _b;\n    // a shape and an overlay svg share a lifetime and have the same cgHash attribute\n    return [\n        bounds.width,\n        bounds.height,\n        current,\n        orig,\n        dest,\n        brush,\n        shorten && '-',\n        piece && $624548787bc3efbc$var$pieceHash(piece),\n        modifiers && $624548787bc3efbc$var$modifiersHash(modifiers),\n        customSvg && `custom-${$624548787bc3efbc$var$textHash(customSvg.html)},${(_b = (_a = customSvg.center) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'o'}`,\n        label && `label-${$624548787bc3efbc$var$textHash(label.text)}`\n    ].filter((x)=>x).join(',');\n}\nfunction $624548787bc3efbc$var$pieceHash(piece) {\n    return [\n        piece.color,\n        piece.role,\n        piece.scale\n    ].filter((x)=>x).join(',');\n}\nfunction $624548787bc3efbc$var$modifiersHash(m) {\n    return [\n        m.lineWidth,\n        m.hilite && '*'\n    ].filter((x)=>x).join(',');\n}\nfunction $624548787bc3efbc$var$textHash(s) {\n    // Rolling hash with base 31 (cf. https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript)\n    let h = 0;\n    for(let i = 0; i < s.length; i++)h = (h << 5) - h + s.charCodeAt(i) >>> 0;\n    return h.toString();\n}\nfunction $624548787bc3efbc$var$renderShape(state, { shape: shape, current: current, hash: hash }, brushes, dests, bounds) {\n    var _a, _b;\n    const from = $624548787bc3efbc$var$pos2user($624548787bc3efbc$var$orient((0, $e845129b04f677bd$export$e2878eba51f22d11)(shape.orig), state.orientation), bounds), to = shape.dest ? $624548787bc3efbc$var$pos2user($624548787bc3efbc$var$orient((0, $e845129b04f677bd$export$e2878eba51f22d11)(shape.dest), state.orientation), bounds) : from, brush = shape.brush && $624548787bc3efbc$var$makeCustomBrush(brushes[shape.brush], shape.modifiers), slots = dests.get(shape.dest), svgs = [];\n    if (brush) {\n        const el = $624548787bc3efbc$export$74da2cba014bdc09($624548787bc3efbc$export$c8a8987d4410bf2d('g'), {\n            cgHash: hash\n        });\n        svgs.push({\n            el: el\n        });\n        if (from[0] !== to[0] || from[1] !== to[1]) el.appendChild($624548787bc3efbc$var$renderArrow(shape, brush, from, to, current, $624548787bc3efbc$var$isShort(shape.dest, dests)));\n        else el.appendChild($624548787bc3efbc$var$renderCircle(brushes[shape.brush], from, current, bounds));\n    }\n    if (shape.label) {\n        const label = shape.label;\n        (_a = label.fill) !== null && _a !== void 0 ? _a : label.fill = shape.brush && brushes[shape.brush].color;\n        const corner = shape.brush ? undefined : 'tr';\n        svgs.push({\n            el: $624548787bc3efbc$var$renderLabel(label, hash, from, to, slots, corner),\n            isCustom: true\n        });\n    }\n    if (shape.customSvg) {\n        const on = (_b = shape.customSvg.center) !== null && _b !== void 0 ? _b : 'orig';\n        const [x, y] = on === 'label' ? $624548787bc3efbc$var$labelCoords(from, to, slots).map((c)=>c - 0.5) : on === 'dest' ? to : from;\n        const el = $624548787bc3efbc$export$74da2cba014bdc09($624548787bc3efbc$export$c8a8987d4410bf2d('g'), {\n            transform: `translate(${x},${y})`,\n            cgHash: hash\n        });\n        el.innerHTML = `<svg width=\"1\" height=\"1\" viewBox=\"0 0 100 100\">${shape.customSvg.html}</svg>`;\n        svgs.push({\n            el: el,\n            isCustom: true\n        });\n    }\n    return svgs;\n}\nfunction $624548787bc3efbc$var$renderCircle(brush, at, current, bounds) {\n    const widths = $624548787bc3efbc$var$circleWidth(), radius = (bounds.width + bounds.height) / (4 * Math.max(bounds.width, bounds.height));\n    return $624548787bc3efbc$export$74da2cba014bdc09($624548787bc3efbc$export$c8a8987d4410bf2d('circle'), {\n        stroke: brush.color,\n        'stroke-width': widths[current ? 0 : 1],\n        fill: 'none',\n        opacity: $624548787bc3efbc$var$opacity(brush, current),\n        cx: at[0],\n        cy: at[1],\n        r: radius - widths[1] / 2\n    });\n}\nfunction $624548787bc3efbc$var$hilite(brush) {\n    return [\n        '#ffffff',\n        '#fff',\n        'white'\n    ].includes(brush.color) ? $624548787bc3efbc$var$hilites['hilitePrimary'] : $624548787bc3efbc$var$hilites['hiliteWhite'];\n}\nfunction $624548787bc3efbc$var$renderArrow(s, brush, from, to, current, shorten) {\n    var _a;\n    function renderLine(isHilite) {\n        var _a;\n        const m = $624548787bc3efbc$var$arrowMargin(shorten && !current), dx = to[0] - from[0], dy = to[1] - from[1], angle = Math.atan2(dy, dx), xo = Math.cos(angle) * m, yo = Math.sin(angle) * m;\n        return $624548787bc3efbc$export$74da2cba014bdc09($624548787bc3efbc$export$c8a8987d4410bf2d('line'), {\n            stroke: isHilite ? $624548787bc3efbc$var$hilite(brush).color : brush.color,\n            'stroke-width': $624548787bc3efbc$var$lineWidth(brush, current) + (isHilite ? 0.04 : 0),\n            'stroke-linecap': 'round',\n            'marker-end': `url(#arrowhead-${isHilite ? $624548787bc3efbc$var$hilite(brush).key : brush.key})`,\n            opacity: ((_a = s.modifiers) === null || _a === void 0 ? void 0 : _a.hilite) ? 1 : $624548787bc3efbc$var$opacity(brush, current),\n            x1: from[0],\n            y1: from[1],\n            x2: to[0] - xo,\n            y2: to[1] - yo\n        });\n    }\n    if (!((_a = s.modifiers) === null || _a === void 0 ? void 0 : _a.hilite)) return renderLine(false);\n    const g = $624548787bc3efbc$export$c8a8987d4410bf2d('g');\n    const blurred = $624548787bc3efbc$export$74da2cba014bdc09($624548787bc3efbc$export$c8a8987d4410bf2d('g'), {\n        filter: 'url(#cg-filter-blur)'\n    });\n    blurred.appendChild($624548787bc3efbc$var$filterBox(from, to));\n    blurred.appendChild(renderLine(true));\n    g.appendChild(blurred);\n    g.appendChild(renderLine(false));\n    return g;\n}\nfunction $624548787bc3efbc$var$renderMarker(brush) {\n    const marker = $624548787bc3efbc$export$74da2cba014bdc09($624548787bc3efbc$export$c8a8987d4410bf2d('marker'), {\n        id: 'arrowhead-' + brush.key,\n        orient: 'auto',\n        overflow: 'visible',\n        markerWidth: 4,\n        markerHeight: 4,\n        refX: brush.key.startsWith('hilite') ? 1.86 : 2.05,\n        refY: 2\n    });\n    marker.appendChild($624548787bc3efbc$export$74da2cba014bdc09($624548787bc3efbc$export$c8a8987d4410bf2d('path'), {\n        d: 'M0,0 V4 L3,2 Z',\n        fill: brush.color\n    }));\n    marker.setAttribute('cgKey', brush.key);\n    return marker;\n}\nfunction $624548787bc3efbc$var$renderLabel(label, hash, from, to, slots, corner) {\n    var _a;\n    const labelSize = 0.4, fontSize = labelSize * 0.75 ** label.text.length, at = $624548787bc3efbc$var$labelCoords(from, to, slots), cornerOff = corner === 'tr' ? 0.4 : 0, g = $624548787bc3efbc$export$74da2cba014bdc09($624548787bc3efbc$export$c8a8987d4410bf2d('g'), {\n        transform: `translate(${at[0] + cornerOff},${at[1] - cornerOff})`,\n        cgHash: hash\n    });\n    g.appendChild($624548787bc3efbc$export$74da2cba014bdc09($624548787bc3efbc$export$c8a8987d4410bf2d('circle'), {\n        r: labelSize / 2,\n        'fill-opacity': corner ? 1.0 : 0.8,\n        'stroke-opacity': corner ? 1.0 : 0.7,\n        'stroke-width': 0.03,\n        fill: (_a = label.fill) !== null && _a !== void 0 ? _a : '#666',\n        stroke: 'white'\n    }));\n    const labelEl = $624548787bc3efbc$export$74da2cba014bdc09($624548787bc3efbc$export$c8a8987d4410bf2d('text'), {\n        'font-size': fontSize,\n        'font-family': 'Noto Sans',\n        'text-anchor': 'middle',\n        fill: 'white',\n        y: 0.13 * 0.75 ** label.text.length\n    });\n    labelEl.innerHTML = label.text;\n    g.appendChild(labelEl);\n    return g;\n}\nfunction $624548787bc3efbc$var$orient(pos, color) {\n    return color === 'white' ? pos : [\n        7 - pos[0],\n        7 - pos[1]\n    ];\n}\nfunction $624548787bc3efbc$var$isShort(dest, dests) {\n    return true === (dest && dests.has(dest) && dests.get(dest).size > 1);\n}\nfunction $624548787bc3efbc$export$c8a8987d4410bf2d(tagName) {\n    return document.createElementNS('http://www.w3.org/2000/svg', tagName);\n}\nfunction $624548787bc3efbc$export$74da2cba014bdc09(el, attrs) {\n    for(const key in attrs)if (Object.prototype.hasOwnProperty.call(attrs, key)) el.setAttribute(key, attrs[key]);\n    return el;\n}\nfunction $624548787bc3efbc$var$makeCustomBrush(base, modifiers) {\n    return !modifiers ? base : {\n        color: base.color,\n        opacity: Math.round(base.opacity * 10) / 10,\n        lineWidth: Math.round(modifiers.lineWidth || base.lineWidth),\n        key: [\n            base.key,\n            modifiers.lineWidth\n        ].filter((x)=>x).join('')\n    };\n}\nfunction $624548787bc3efbc$var$circleWidth() {\n    return [\n        3 / 64,\n        4 / 64\n    ];\n}\nfunction $624548787bc3efbc$var$lineWidth(brush, current) {\n    return (brush.lineWidth || 10) * (current ? 0.85 : 1) / 64;\n}\nfunction $624548787bc3efbc$var$opacity(brush, current) {\n    return (brush.opacity || 1) * (current ? 0.9 : 1);\n}\nfunction $624548787bc3efbc$var$arrowMargin(shorten) {\n    return (shorten ? 20 : 10) / 64;\n}\nfunction $624548787bc3efbc$var$pos2user(pos, bounds) {\n    const xScale = Math.min(1, bounds.width / bounds.height);\n    const yScale = Math.min(1, bounds.height / bounds.width);\n    return [\n        (pos[0] - 3.5) * xScale,\n        (3.5 - pos[1]) * yScale\n    ];\n}\nfunction $624548787bc3efbc$var$filterBox(from, to) {\n    // lines/arrows are considered to be one dimensional for the purposes of SVG filters,\n    // so we add a transparent bounding box to ensure they apply to the 2nd dimension\n    const box = {\n        from: [\n            Math.floor(Math.min(from[0], to[0])),\n            Math.floor(Math.min(from[1], to[1]))\n        ],\n        to: [\n            Math.ceil(Math.max(from[0], to[0])),\n            Math.ceil(Math.max(from[1], to[1]))\n        ]\n    };\n    return $624548787bc3efbc$export$74da2cba014bdc09($624548787bc3efbc$export$c8a8987d4410bf2d('rect'), {\n        x: box.from[0],\n        y: box.from[1],\n        width: box.to[0] - box.from[0],\n        height: box.to[1] - box.from[1],\n        fill: 'none',\n        stroke: 'none'\n    });\n}\nfunction $624548787bc3efbc$var$moveAngle(from, to, asSlot = true) {\n    const angle = Math.atan2(to[1] - from[1], to[0] - from[0]) + Math.PI;\n    return asSlot ? (Math.round(angle * 8 / Math.PI) + 16) % 16 : angle;\n}\nfunction $624548787bc3efbc$var$dist(from, to) {\n    return Math.sqrt([\n        from[0] - to[0],\n        from[1] - to[1]\n    ].reduce((acc, x)=>acc + x * x, 0));\n}\n/*\n try to place label at the junction of the destination shaft and arrowhead. if there's more than\n 1 arrow pointing to a square, the arrow shortens by 10 / 64 units so the label must move as well.\n \n if the angle between two incoming arrows is pi / 8, such as when an adjacent knight and bishop\n attack the same square, the knight's label is slid further down the shaft by an amount equal to\n our label size to avoid collision\n*/ function $624548787bc3efbc$var$labelCoords(from, to, slots) {\n    let mag = $624548787bc3efbc$var$dist(from, to);\n    //if (mag === 0) return [from[0], from[1]];\n    const angle = $624548787bc3efbc$var$moveAngle(from, to, false);\n    if (slots) {\n        mag -= 33 / 64; // reduce by arrowhead length\n        if (slots.size > 1) {\n            mag -= 10 / 64; // reduce by shortening factor\n            const slot = $624548787bc3efbc$var$moveAngle(from, to);\n            if (slots.has((slot + 1) % 16) || slots.has((slot + 15) % 16)) {\n                if (slot & 1) mag -= 0.4;\n            }\n        }\n    }\n    return [\n        from[0] - Math.cos(angle) * mag,\n        from[1] - Math.sin(angle) * mag\n    ].map((c)=>c + 0.5);\n}\n\n\nfunction $d0202f5e455c071c$export$79188534738a92bf(element, s) {\n    // .cg-wrap (element passed to Chessground)\n    //   cg-container\n    //     cg-board\n    //     svg.cg-shapes\n    //       defs\n    //       g\n    //     svg.cg-custom-svgs\n    //       g\n    //     cg-auto-pieces\n    //     coords.ranks\n    //     coords.files\n    //     piece.ghost\n    element.innerHTML = '';\n    // ensure the cg-wrap class is set\n    // so bounds calculation can use the CSS width/height values\n    // add that class yourself to the element before calling chessground\n    // for a slight performance improvement! (avoids recomputing style)\n    element.classList.add('cg-wrap');\n    for (const c of (0, $a9912b1579309d38$export$8f45430ccf837300))element.classList.toggle('orientation-' + c, s.orientation === c);\n    element.classList.toggle('manipulable', !s.viewOnly);\n    const container = (0, $e845129b04f677bd$export$3d7cd8ed57263b30)('cg-container');\n    element.appendChild(container);\n    const board = (0, $e845129b04f677bd$export$3d7cd8ed57263b30)('cg-board');\n    container.appendChild(board);\n    let svg;\n    let customSvg;\n    let autoPieces;\n    if (s.drawable.visible) {\n        svg = (0, $624548787bc3efbc$export$74da2cba014bdc09)((0, $624548787bc3efbc$export$c8a8987d4410bf2d)('svg'), {\n            class: 'cg-shapes',\n            viewBox: '-4 -4 8 8',\n            preserveAspectRatio: 'xMidYMid slice'\n        });\n        svg.appendChild((0, $624548787bc3efbc$export$a529cedf94de8dc)());\n        svg.appendChild((0, $624548787bc3efbc$export$c8a8987d4410bf2d)('g'));\n        customSvg = (0, $624548787bc3efbc$export$74da2cba014bdc09)((0, $624548787bc3efbc$export$c8a8987d4410bf2d)('svg'), {\n            class: 'cg-custom-svgs',\n            viewBox: '-3.5 -3.5 8 8',\n            preserveAspectRatio: 'xMidYMid slice'\n        });\n        customSvg.appendChild((0, $624548787bc3efbc$export$c8a8987d4410bf2d)('g'));\n        autoPieces = (0, $e845129b04f677bd$export$3d7cd8ed57263b30)('cg-auto-pieces');\n        container.appendChild(svg);\n        container.appendChild(customSvg);\n        container.appendChild(autoPieces);\n    }\n    if (s.coordinates) {\n        const orientClass = s.orientation === 'black' ? ' black' : '';\n        const ranksPositionClass = s.ranksPosition === 'left' ? ' left' : '';\n        if (s.coordinatesOnSquares) {\n            const rankN = s.orientation === 'white' ? (i)=>i + 1 : (i)=>8 - i;\n            (0, $a9912b1579309d38$export$3a444357c5f65f65).forEach((f, i)=>container.appendChild($d0202f5e455c071c$var$renderCoords((0, $a9912b1579309d38$export$d8e4e3952f325c95).map((r)=>f + r), 'squares rank' + rankN(i) + orientClass + ranksPositionClass)));\n        } else {\n            container.appendChild($d0202f5e455c071c$var$renderCoords((0, $a9912b1579309d38$export$d8e4e3952f325c95), 'ranks' + orientClass + ranksPositionClass));\n            container.appendChild($d0202f5e455c071c$var$renderCoords((0, $a9912b1579309d38$export$3a444357c5f65f65), 'files' + orientClass));\n        }\n    }\n    let ghost;\n    if (s.draggable.enabled && s.draggable.showGhost) {\n        ghost = (0, $e845129b04f677bd$export$3d7cd8ed57263b30)('piece', 'ghost');\n        (0, $e845129b04f677bd$export$8cb512849e51eaf5)(ghost, false);\n        container.appendChild(ghost);\n    }\n    return {\n        board: board,\n        container: container,\n        wrap: element,\n        ghost: ghost,\n        svg: svg,\n        customSvg: customSvg,\n        autoPieces: autoPieces\n    };\n}\nfunction $d0202f5e455c071c$var$renderCoords(elems, className) {\n    const el = (0, $e845129b04f677bd$export$3d7cd8ed57263b30)('coords', className);\n    let f;\n    for (const elem of elems){\n        f = (0, $e845129b04f677bd$export$3d7cd8ed57263b30)('coord');\n        f.textContent = elem;\n        el.appendChild(f);\n    }\n    return el;\n}\n\n\n\n\n\n\n\nfunction $efc4553d5ca4e4fa$export$af7814416196c9de(s, piece) {\n    s.dropmode = {\n        active: true,\n        piece: piece\n    };\n    (0, $f0622fe2c415ff29$export$70b61ad426ddbe54)(s);\n}\nfunction $efc4553d5ca4e4fa$export$3bf31ae3228aa49e(s) {\n    s.dropmode = {\n        active: false\n    };\n}\nfunction $efc4553d5ca4e4fa$export$663103110d94aac9(s, e) {\n    if (!s.dropmode.active) return;\n    $362ede749680455b$export$f92a111f74a3f7c7(s);\n    $362ede749680455b$export$9e6f418e5ea6b92c(s);\n    const piece = s.dropmode.piece;\n    if (piece) {\n        s.pieces.set('a0', piece);\n        const position = $e845129b04f677bd$export$33052595192f7117(e);\n        const dest = position && $362ede749680455b$export$102bdd581884418b(position, $362ede749680455b$export$970133fdf67d86cb(s), s.dom.bounds());\n        if (dest) $362ede749680455b$export$b2b9f46b948033b0(s, 'a0', dest);\n    }\n    s.dom.redraw();\n}\n\n\n\nfunction $d8436509f6a2172f$export$fc48d2ed06541843(s, onResize) {\n    const boardEl = s.dom.elements.board;\n    if ('ResizeObserver' in window) new ResizeObserver(onResize).observe(s.dom.elements.wrap);\n    if (s.disableContextMenu || s.drawable.enabled) boardEl.addEventListener('contextmenu', (e)=>e.preventDefault());\n    if (s.viewOnly) return;\n    // Cannot be passive, because we prevent touch scrolling and dragging of\n    // selected elements.\n    const onStart = $d8436509f6a2172f$var$startDragOrDraw(s);\n    boardEl.addEventListener('touchstart', onStart, {\n        passive: false\n    });\n    boardEl.addEventListener('mousedown', onStart, {\n        passive: false\n    });\n}\nfunction $d8436509f6a2172f$export$fdc77453278b0fa9(s, onResize) {\n    const unbinds = [];\n    // Old versions of Edge and Safari do not support ResizeObserver. Send\n    // chessground.resize if a user action has changed the bounds of the board.\n    if (!('ResizeObserver' in window)) unbinds.push($d8436509f6a2172f$var$unbindable(document.body, 'chessground.resize', onResize));\n    if (!s.viewOnly) {\n        const onmove = $d8436509f6a2172f$var$dragOrDraw(s, $f0622fe2c415ff29$export$d947e5f4f4c48d48, $e4dfa114a4df3bca$export$d947e5f4f4c48d48);\n        const onend = $d8436509f6a2172f$var$dragOrDraw(s, $f0622fe2c415ff29$export$bd5df0f255a350f8, $e4dfa114a4df3bca$export$bd5df0f255a350f8);\n        for (const ev of [\n            'touchmove',\n            'mousemove'\n        ])unbinds.push($d8436509f6a2172f$var$unbindable(document, ev, onmove));\n        for (const ev of [\n            'touchend',\n            'mouseup'\n        ])unbinds.push($d8436509f6a2172f$var$unbindable(document, ev, onend));\n        const onScroll = ()=>s.dom.bounds.clear();\n        unbinds.push($d8436509f6a2172f$var$unbindable(document, 'scroll', onScroll, {\n            capture: true,\n            passive: true\n        }));\n        unbinds.push($d8436509f6a2172f$var$unbindable(window, 'resize', onScroll, {\n            passive: true\n        }));\n    }\n    return ()=>unbinds.forEach((f)=>f());\n}\nfunction $d8436509f6a2172f$var$unbindable(el, eventName, callback, options) {\n    el.addEventListener(eventName, callback, options);\n    return ()=>el.removeEventListener(eventName, callback, options);\n}\nconst $d8436509f6a2172f$var$startDragOrDraw = (s)=>(e)=>{\n        if (s.draggable.current) $f0622fe2c415ff29$export$70b61ad426ddbe54(s);\n        else if (s.drawable.current) $e4dfa114a4df3bca$export$70b61ad426ddbe54(s);\n        else if (e.shiftKey || (0, $e845129b04f677bd$export$947a472b5b3020ba)(e)) {\n            if (s.drawable.enabled) $e4dfa114a4df3bca$export$b3571188c770cc5a(s, e);\n        } else if (!s.viewOnly) {\n            if (s.dropmode.active) (0, $efc4553d5ca4e4fa$export$663103110d94aac9)(s, e);\n            else $f0622fe2c415ff29$export$b3571188c770cc5a(s, e);\n        }\n    };\nconst $d8436509f6a2172f$var$dragOrDraw = (s, withDrag, withDraw)=>(e)=>{\n        if (s.drawable.current) {\n            if (s.drawable.enabled) withDraw(s, e);\n        } else if (!s.viewOnly) withDrag(s, e);\n    };\n\n\n\n\nfunction $676ff861fa9fc211$export$b3890eb0ae9dca99(s) {\n    const asWhite = (0, $362ede749680455b$export$970133fdf67d86cb)(s), posToTranslate = (0, $e845129b04f677bd$export$2135ad75550a2ff4)(s.dom.bounds()), boardEl = s.dom.elements.board, pieces = s.pieces, curAnim = s.animation.current, anims = curAnim ? curAnim.plan.anims : new Map(), fadings = curAnim ? curAnim.plan.fadings : new Map(), curDrag = s.draggable.current, squares = $676ff861fa9fc211$var$computeSquareClasses(s), samePieces = new Set(), sameSquares = new Set(), movedPieces = new Map(), movedSquares = new Map(); // by class name\n    let k, el, pieceAtKey, elPieceName, anim, fading, pMvdset, pMvd, sMvdset, sMvd;\n    // walk over all board dom elements, apply animations and flag moved pieces\n    el = boardEl.firstChild;\n    while(el){\n        k = el.cgKey;\n        if ($676ff861fa9fc211$var$isPieceNode(el)) {\n            pieceAtKey = pieces.get(k);\n            anim = anims.get(k);\n            fading = fadings.get(k);\n            elPieceName = el.cgPiece;\n            // if piece not being dragged anymore, remove dragging style\n            if (el.cgDragging && (!curDrag || curDrag.orig !== k)) {\n                el.classList.remove('dragging');\n                (0, $e845129b04f677bd$export$d73ee8ef04f5226a)(el, posToTranslate((0, $e845129b04f677bd$export$e2878eba51f22d11)(k), asWhite));\n                el.cgDragging = false;\n            }\n            // remove fading class if it still remains\n            if (!fading && el.cgFading) {\n                el.cgFading = false;\n                el.classList.remove('fading');\n            }\n            // there is now a piece at this dom key\n            if (pieceAtKey) {\n                // continue animation if already animating and same piece\n                // (otherwise it could animate a captured piece)\n                if (anim && el.cgAnimating && elPieceName === $676ff861fa9fc211$var$pieceNameOf(pieceAtKey)) {\n                    const pos = (0, $e845129b04f677bd$export$e2878eba51f22d11)(k);\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                    el.classList.add('anim');\n                    (0, $e845129b04f677bd$export$d73ee8ef04f5226a)(el, posToTranslate(pos, asWhite));\n                } else if (el.cgAnimating) {\n                    el.cgAnimating = false;\n                    el.classList.remove('anim');\n                    (0, $e845129b04f677bd$export$d73ee8ef04f5226a)(el, posToTranslate((0, $e845129b04f677bd$export$e2878eba51f22d11)(k), asWhite));\n                    if (s.addPieceZIndex) el.style.zIndex = $676ff861fa9fc211$var$posZIndex((0, $e845129b04f677bd$export$e2878eba51f22d11)(k), asWhite);\n                }\n                // same piece: flag as same\n                if (elPieceName === $676ff861fa9fc211$var$pieceNameOf(pieceAtKey) && (!fading || !el.cgFading)) samePieces.add(k);\n                else if (fading && elPieceName === $676ff861fa9fc211$var$pieceNameOf(fading)) {\n                    el.classList.add('fading');\n                    el.cgFading = true;\n                } else $676ff861fa9fc211$var$appendValue(movedPieces, elPieceName, el);\n            } else $676ff861fa9fc211$var$appendValue(movedPieces, elPieceName, el);\n        } else if ($676ff861fa9fc211$var$isSquareNode(el)) {\n            const cn = el.className;\n            if (squares.get(k) === cn) sameSquares.add(k);\n            else $676ff861fa9fc211$var$appendValue(movedSquares, cn, el);\n        }\n        el = el.nextSibling;\n    }\n    // walk over all squares in current set, apply dom changes to moved squares\n    // or append new squares\n    for (const [sk, className] of squares)if (!sameSquares.has(sk)) {\n        sMvdset = movedSquares.get(className);\n        sMvd = sMvdset && sMvdset.pop();\n        const translation = posToTranslate((0, $e845129b04f677bd$export$e2878eba51f22d11)(sk), asWhite);\n        if (sMvd) {\n            sMvd.cgKey = sk;\n            (0, $e845129b04f677bd$export$d73ee8ef04f5226a)(sMvd, translation);\n        } else {\n            const squareNode = (0, $e845129b04f677bd$export$3d7cd8ed57263b30)('square', className);\n            squareNode.cgKey = sk;\n            (0, $e845129b04f677bd$export$d73ee8ef04f5226a)(squareNode, translation);\n            boardEl.insertBefore(squareNode, boardEl.firstChild);\n        }\n    }\n    // walk over all pieces in current set, apply dom changes to moved pieces\n    // or append new pieces\n    for (const [k, p] of pieces){\n        anim = anims.get(k);\n        if (!samePieces.has(k)) {\n            pMvdset = movedPieces.get($676ff861fa9fc211$var$pieceNameOf(p));\n            pMvd = pMvdset && pMvdset.pop();\n            // a same piece was moved\n            if (pMvd) {\n                // apply dom changes\n                pMvd.cgKey = k;\n                if (pMvd.cgFading) {\n                    pMvd.classList.remove('fading');\n                    pMvd.cgFading = false;\n                }\n                const pos = (0, $e845129b04f677bd$export$e2878eba51f22d11)(k);\n                if (s.addPieceZIndex) pMvd.style.zIndex = $676ff861fa9fc211$var$posZIndex(pos, asWhite);\n                if (anim) {\n                    pMvd.cgAnimating = true;\n                    pMvd.classList.add('anim');\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                }\n                (0, $e845129b04f677bd$export$d73ee8ef04f5226a)(pMvd, posToTranslate(pos, asWhite));\n            } else {\n                const pieceName = $676ff861fa9fc211$var$pieceNameOf(p), pieceNode = (0, $e845129b04f677bd$export$3d7cd8ed57263b30)('piece', pieceName), pos = (0, $e845129b04f677bd$export$e2878eba51f22d11)(k);\n                pieceNode.cgPiece = pieceName;\n                pieceNode.cgKey = k;\n                if (anim) {\n                    pieceNode.cgAnimating = true;\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                }\n                (0, $e845129b04f677bd$export$d73ee8ef04f5226a)(pieceNode, posToTranslate(pos, asWhite));\n                if (s.addPieceZIndex) pieceNode.style.zIndex = $676ff861fa9fc211$var$posZIndex(pos, asWhite);\n                boardEl.appendChild(pieceNode);\n            }\n        }\n    }\n    // remove any element that remains in the moved sets\n    for (const nodes of movedPieces.values())$676ff861fa9fc211$var$removeNodes(s, nodes);\n    for (const nodes of movedSquares.values())$676ff861fa9fc211$var$removeNodes(s, nodes);\n}\nfunction $676ff861fa9fc211$export$d62f185fd39aa98c(s) {\n    const asWhite = (0, $362ede749680455b$export$970133fdf67d86cb)(s), posToTranslate = (0, $e845129b04f677bd$export$2135ad75550a2ff4)(s.dom.bounds());\n    let el = s.dom.elements.board.firstChild;\n    while(el){\n        if ($676ff861fa9fc211$var$isPieceNode(el) && !el.cgAnimating || $676ff861fa9fc211$var$isSquareNode(el)) (0, $e845129b04f677bd$export$d73ee8ef04f5226a)(el, posToTranslate((0, $e845129b04f677bd$export$e2878eba51f22d11)(el.cgKey), asWhite));\n        el = el.nextSibling;\n    }\n}\nfunction $676ff861fa9fc211$export$f4467a4f41373bc7(s) {\n    var _a, _b;\n    const bounds = s.dom.elements.wrap.getBoundingClientRect();\n    const container = s.dom.elements.container;\n    const ratio = bounds.height / bounds.width;\n    const width = Math.floor(bounds.width * window.devicePixelRatio / 8) * 8 / window.devicePixelRatio;\n    const height = width * ratio;\n    container.style.width = width + 'px';\n    container.style.height = height + 'px';\n    s.dom.bounds.clear();\n    (_a = s.addDimensionsCssVarsTo) === null || _a === void 0 || _a.style.setProperty('---cg-width', width + 'px');\n    (_b = s.addDimensionsCssVarsTo) === null || _b === void 0 || _b.style.setProperty('---cg-height', height + 'px');\n}\nconst $676ff861fa9fc211$var$isPieceNode = (el)=>el.tagName === 'PIECE';\nconst $676ff861fa9fc211$var$isSquareNode = (el)=>el.tagName === 'SQUARE';\nfunction $676ff861fa9fc211$var$removeNodes(s, nodes) {\n    for (const node of nodes)s.dom.elements.board.removeChild(node);\n}\nfunction $676ff861fa9fc211$var$posZIndex(pos, asWhite) {\n    const minZ = 3;\n    const rank = pos[1];\n    const z = asWhite ? minZ + 7 - rank : minZ + rank;\n    return `${z}`;\n}\nconst $676ff861fa9fc211$var$pieceNameOf = (piece)=>`${piece.color} ${piece.role}`;\nfunction $676ff861fa9fc211$var$computeSquareClasses(s) {\n    var _a, _b, _c;\n    const squares = new Map();\n    if (s.lastMove && s.highlight.lastMove) for (const k of s.lastMove)$676ff861fa9fc211$var$addSquare(squares, k, 'last-move');\n    if (s.check && s.highlight.check) $676ff861fa9fc211$var$addSquare(squares, s.check, 'check');\n    if (s.selected) {\n        $676ff861fa9fc211$var$addSquare(squares, s.selected, 'selected');\n        if (s.movable.showDests) {\n            const dests = (_a = s.movable.dests) === null || _a === void 0 ? void 0 : _a.get(s.selected);\n            if (dests) for (const k of dests)$676ff861fa9fc211$var$addSquare(squares, k, 'move-dest' + (s.pieces.has(k) ? ' oc' : ''));\n            const pDests = (_c = (_b = s.premovable.customDests) === null || _b === void 0 ? void 0 : _b.get(s.selected)) !== null && _c !== void 0 ? _c : s.premovable.dests;\n            if (pDests) for (const k of pDests)$676ff861fa9fc211$var$addSquare(squares, k, 'premove-dest' + (s.pieces.has(k) ? ' oc' : ''));\n        }\n    }\n    const premove = s.premovable.current;\n    if (premove) for (const k of premove)$676ff861fa9fc211$var$addSquare(squares, k, 'current-premove');\n    else if (s.predroppable.current) $676ff861fa9fc211$var$addSquare(squares, s.predroppable.current.key, 'current-premove');\n    const o = s.exploding;\n    if (o) for (const k of o.keys)$676ff861fa9fc211$var$addSquare(squares, k, 'exploding' + o.stage);\n    if (s.highlight.custom) s.highlight.custom.forEach((v, k)=>{\n        $676ff861fa9fc211$var$addSquare(squares, k, v);\n    });\n    return squares;\n}\nfunction $676ff861fa9fc211$var$addSquare(squares, key, klass) {\n    const classes = squares.get(key);\n    if (classes) squares.set(key, `${classes} ${klass}`);\n    else squares.set(key, klass);\n}\nfunction $676ff861fa9fc211$var$appendValue(map, key, value) {\n    const arr = map.get(key);\n    if (arr) arr.push(value);\n    else map.set(key, [\n        value\n    ]);\n}\n\n\n\n\n// append and remove only. No updates.\nfunction $cd7a2ab50ed83487$export$eb48cb918245ce33(shapes, root, renderShape) {\n    const hashesInDom = new Map(), toRemove = [];\n    for (const sc of shapes)hashesInDom.set(sc.hash, false);\n    let el = root.firstElementChild, elHash;\n    while(el){\n        elHash = el.getAttribute('cgHash');\n        // found a shape element that's here to stay\n        if (hashesInDom.has(elHash)) hashesInDom.set(elHash, true);\n        else toRemove.push(el);\n        el = el.nextElementSibling;\n    }\n    // remove old shapes\n    for (const el of toRemove)root.removeChild(el);\n    // insert shapes that are not yet in dom\n    for (const sc of shapes)if (!hashesInDom.get(sc.hash)) root.appendChild(renderShape(sc));\n}\n\n\nfunction $7d4b88c0b296489d$export$b3890eb0ae9dca99(state, autoPieceEl) {\n    const autoPieces = state.drawable.autoShapes.filter((autoShape)=>autoShape.piece);\n    const autoPieceShapes = autoPieces.map((s)=>{\n        return {\n            shape: s,\n            hash: $7d4b88c0b296489d$var$hash(s),\n            current: false\n        };\n    });\n    (0, $cd7a2ab50ed83487$export$eb48cb918245ce33)(autoPieceShapes, autoPieceEl, (shape)=>$7d4b88c0b296489d$var$renderShape(state, shape, state.dom.bounds()));\n}\nfunction $7d4b88c0b296489d$export$d62f185fd39aa98c(state) {\n    var _a;\n    const asWhite = (0, $362ede749680455b$export$970133fdf67d86cb)(state), posToTranslate = (0, $e845129b04f677bd$export$2135ad75550a2ff4)(state.dom.bounds());\n    let el = (_a = state.dom.elements.autoPieces) === null || _a === void 0 ? void 0 : _a.firstChild;\n    while(el){\n        (0, $e845129b04f677bd$export$f8afaca97e230dc6)(el, posToTranslate((0, $e845129b04f677bd$export$e2878eba51f22d11)(el.cgKey), asWhite), el.cgScale);\n        el = el.nextSibling;\n    }\n}\nfunction $7d4b88c0b296489d$var$renderShape(state, { shape: shape, hash: hash }, bounds) {\n    var _a, _b, _c;\n    const orig = shape.orig;\n    const role = (_a = shape.piece) === null || _a === void 0 ? void 0 : _a.role;\n    const color = (_b = shape.piece) === null || _b === void 0 ? void 0 : _b.color;\n    const scale = (_c = shape.piece) === null || _c === void 0 ? void 0 : _c.scale;\n    const pieceEl = (0, $e845129b04f677bd$export$3d7cd8ed57263b30)('piece', `${role} ${color}`);\n    pieceEl.setAttribute('cgHash', hash);\n    pieceEl.cgKey = orig;\n    pieceEl.cgScale = scale;\n    (0, $e845129b04f677bd$export$f8afaca97e230dc6)(pieceEl, (0, $e845129b04f677bd$export$2135ad75550a2ff4)(bounds)((0, $e845129b04f677bd$export$e2878eba51f22d11)(orig), (0, $362ede749680455b$export$970133fdf67d86cb)(state)), scale);\n    return pieceEl;\n}\nconst $7d4b88c0b296489d$var$hash = (autoPiece)=>{\n    var _a, _b, _c;\n    return [\n        autoPiece.orig,\n        (_a = autoPiece.piece) === null || _a === void 0 ? void 0 : _a.role,\n        (_b = autoPiece.piece) === null || _b === void 0 ? void 0 : _b.color,\n        (_c = autoPiece.piece) === null || _c === void 0 ? void 0 : _c.scale\n    ].join(',');\n};\n\n\n\n\nfunction $b6d1e46f6b28eb6d$export$7e59435764664c61({ el: el, config: config }) {\n    return $b6d1e46f6b28eb6d$export$6aaf0e4db08ad996(el, config);\n}\nfunction $b6d1e46f6b28eb6d$export$6aaf0e4db08ad996(element, config) {\n    const maybeState = (0, $ae73148c37d59020$export$ebe90cb607ad99e)();\n    (0, $d854d6e3b9054dcc$export$8d21e34596265fa2)(maybeState, config || {});\n    function redrawAll() {\n        const prevUnbind = 'dom' in maybeState ? maybeState.dom.unbind : undefined;\n        // compute bounds from existing board element if possible\n        // this allows non-square boards from CSS to be handled (for 3D)\n        const elements = (0, $d0202f5e455c071c$export$79188534738a92bf)(element, maybeState), bounds = $e845129b04f677bd$export$7c73462e0d25e514(()=>elements.board.getBoundingClientRect()), redrawNow = (skipSvg)=>{\n            (0, $676ff861fa9fc211$export$b3890eb0ae9dca99)(state);\n            if (elements.autoPieces) $7d4b88c0b296489d$export$b3890eb0ae9dca99(state, elements.autoPieces);\n            if (!skipSvg && elements.svg) $624548787bc3efbc$export$fb80b1b7d7777ee5(state, elements.svg, elements.customSvg);\n        }, onResize = ()=>{\n            (0, $676ff861fa9fc211$export$f4467a4f41373bc7)(state);\n            (0, $676ff861fa9fc211$export$d62f185fd39aa98c)(state);\n            if (elements.autoPieces) $7d4b88c0b296489d$export$d62f185fd39aa98c(state);\n        };\n        const state = maybeState;\n        state.dom = {\n            elements: elements,\n            bounds: bounds,\n            redraw: $b6d1e46f6b28eb6d$var$debounceRedraw(redrawNow),\n            redrawNow: redrawNow,\n            unbind: prevUnbind\n        };\n        state.drawable.prevSvgHash = '';\n        (0, $676ff861fa9fc211$export$f4467a4f41373bc7)(state);\n        redrawNow(false);\n        $d8436509f6a2172f$export$fc48d2ed06541843(state, onResize);\n        if (!prevUnbind) state.dom.unbind = $d8436509f6a2172f$export$fdc77453278b0fa9(state, onResize);\n        state.events.insert && state.events.insert(elements);\n        return state;\n    }\n    return (0, $33d6df4bf01d7e89$export$b3571188c770cc5a)(redrawAll(), redrawAll);\n}\nfunction $b6d1e46f6b28eb6d$var$debounceRedraw(redrawNow) {\n    let redrawing = false;\n    return ()=>{\n        if (redrawing) return;\n        redrawing = true;\n        requestAnimationFrame(()=>{\n            redrawNow();\n            redrawing = false;\n        });\n    };\n}\n\n\n// Stateful chess\nconst $36d5a33d9da87b96$var$chess = new (0, $e1e1f1f3cd154daa$export$a4d6ea685c300d39)();\n// Chess UI\nconst $36d5a33d9da87b96$var$board = (0, $b6d1e46f6b28eb6d$export$6aaf0e4db08ad996)(document.getElementById(\"board\"), {\n    movable: {\n        events: {\n            after: (from, to)=>{\n                try {\n                    // An illegal move throws an error\n                    $36d5a33d9da87b96$var$chess.move({\n                        from: from,\n                        to: to,\n                        promotion: \"q\"\n                    });\n                } catch (error) {\n                    console.error(error);\n                } finally{\n                    // Either chess was legally updated or not,\n                    // either way this updates the UI accordingly\n                    $36d5a33d9da87b96$var$board.set({\n                        fen: $36d5a33d9da87b96$var$chess.fen()\n                    });\n                }\n            }\n        }\n    }\n});\n\n\n//# sourceMappingURL=index.47963c1a.js.map\n","import { Chess } from \"chess.js\";\nimport { Chessground } from \"chessground\";\n\n// Stateful chess\nconst chess = new Chess();\n\n// Chess UI\nconst board = Chessground(document.getElementById(\"board\")!, {\n  movable: {\n    events: {\n      after: (from, to) => {\n        try {\n          // An illegal move throws an error\n          chess.move({ from, to, promotion: \"q\" });\n        } catch (error) {\n          console.error(error);\n        } finally {\n          // Either chess was legally updated or not,\n          // either way this updates the UI accordingly\n          board.set({ fen: chess.fen() });\n        }\n      },\n    },\n  },\n});\n","/**\n * @license\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nexport const WHITE = 'w';\nexport const BLACK = 'b';\nexport const PAWN = 'p';\nexport const KNIGHT = 'n';\nexport const BISHOP = 'b';\nexport const ROOK = 'r';\nexport const QUEEN = 'q';\nexport const KING = 'k';\nexport const DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nexport class Move {\n    color;\n    from;\n    to;\n    piece;\n    captured;\n    promotion;\n    /**\n     * @deprecated This field is deprecated and will be removed in version 2.0.0.\n     * Please use move descriptor functions instead: `isCapture`, `isPromotion`,\n     * `isEnPassant`, `isKingsideCastle`, `isQueensideCastle`, `isCastle`, and\n     * `isBigPawn`\n     */\n    flags;\n    san;\n    lan;\n    before;\n    after;\n    constructor(chess, internal) {\n        const { color, piece, from, to, flags, captured, promotion } = internal;\n        const fromAlgebraic = algebraic(from);\n        const toAlgebraic = algebraic(to);\n        this.color = color;\n        this.piece = piece;\n        this.from = fromAlgebraic;\n        this.to = toAlgebraic;\n        /*\n         * HACK: The chess['_method']() calls below invoke private methods in the\n         * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\n         * code cleaner elsewhere.\n         */\n        this.san = chess['_moveToSan'](internal, chess['_moves']({ legal: true }));\n        this.lan = fromAlgebraic + toAlgebraic;\n        this.before = chess.fen();\n        // Generate the FEN for the 'after' key\n        chess['_makeMove'](internal);\n        this.after = chess.fen();\n        chess['_undoMove']();\n        // Build the text representation of the move flags\n        this.flags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                this.flags += FLAGS[flag];\n            }\n        }\n        if (captured) {\n            this.captured = captured;\n        }\n        if (promotion) {\n            this.promotion = promotion;\n            this.lan += promotion;\n        }\n    }\n    isCapture() {\n        return this.flags.indexOf(FLAGS['CAPTURE']) > -1;\n    }\n    isPromotion() {\n        return this.flags.indexOf(FLAGS['PROMOTION']) > -1;\n    }\n    isEnPassant() {\n        return this.flags.indexOf(FLAGS['EP_CAPTURE']) > -1;\n    }\n    isKingsideCastle() {\n        return this.flags.indexOf(FLAGS['KSIDE_CASTLE']) > -1;\n    }\n    isQueensideCastle() {\n        return this.flags.indexOf(FLAGS['QSIDE_CASTLE']) > -1;\n    }\n    isBigPawn() {\n        return this.flags.indexOf(FLAGS['BIG_PAWN']) > -1;\n    }\n}\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n};\n// prettier-ignore\nexport const SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n    [KING]: BITS.KSIDE_CASTLE,\n    [QUEEN]: BITS.QSIDE_CASTLE,\n};\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === WHITE ? BLACK : WHITE;\n}\nexport function validateFen(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: must contain six space-delimited fields',\n        };\n    }\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: move number must be a positive integer',\n        };\n    }\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: half move counter number must be a non-negative integer',\n        };\n    }\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };\n    }\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) {\n        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };\n    }\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };\n    }\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n        };\n    }\n    // 8th criterion: every row is valid?\n    for (let i = 0; i < rows.length; i++) {\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (consecutive number)',\n                    };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (invalid piece)',\n                    };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return {\n                ok: false,\n                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n            };\n        }\n    }\n    // 9th criterion: is en-passant square legal?\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };\n    }\n    // 10th criterion: does chess position contain exact two kings?\n    const kings = [\n        { color: 'white', regex: /K/g },\n        { color: 'black', regex: /k/g },\n    ];\n    for (const { color, regex } of kings) {\n        if (!regex.test(tokens[0])) {\n            return { ok: false, error: `Invalid FEN: missing ${color} king` };\n        }\n        if ((tokens[0].match(regex) || []).length > 1) {\n            return { ok: false, error: `Invalid FEN: too many ${color} kings` };\n        }\n    }\n    // 11th criterion: are any pawns on the first or eighth rows?\n    if (Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: some pawns are on the edge rows',\n        };\n    }\n    return { ok: true };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) {\n            /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            // else use the file symbol\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nfunction trimFen(fen) {\n    /*\n     * remove last two fields in FEN string as they're not needed when checking\n     * for repetition\n     */\n    return fen.split(' ').slice(0, 4).join(' ');\n}\nexport class Chess {\n    _board = new Array(128);\n    _turn = WHITE;\n    _header = {};\n    _kings = { w: EMPTY, b: EMPTY };\n    _epSquare = -1;\n    _halfMoves = 0;\n    _moveNumber = 0;\n    _history = [];\n    _comments = {};\n    _castling = { w: 0, b: 0 };\n    // tracks number of times a position has been seen for repetition checking\n    _positionCount = {};\n    constructor(fen = DEFAULT_POSITION) {\n        this.load(fen);\n    }\n    clear({ preserveHeaders = false } = {}) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = preserveHeaders ? this._header : {};\n        this._positionCount = {};\n        /*\n         * Delete the SetUp and FEN headers (if preserved), the board is empty and\n         * these headers don't make sense in this state. They'll get added later\n         * via .load() or .put()\n         */\n        delete this._header['SetUp'];\n        delete this._header['FEN'];\n    }\n    load(fen, { skipValidation = false, preserveHeaders = false } = {}) {\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = ['-', '-', '0', '1'];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n        }\n        tokens = fen.split(/\\s+/);\n        if (!skipValidation) {\n            const { ok, error } = validateFen(fen);\n            if (!ok) {\n                throw new Error(error);\n            }\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear({ preserveHeaders });\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? WHITE : BLACK;\n                this._put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(fen);\n        this._incPositionCount(fen);\n    }\n    fen() {\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = '';\n        if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n            castling += 'K';\n        }\n        if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n            castling += 'Q';\n        }\n        if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n            castling += 'k';\n        }\n        if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n            castling += 'q';\n        }\n        // do we have an empty castling flag?\n        castling = castling || '-';\n        let epSquare = '-';\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */\n        if (this._epSquare !== EMPTY) {\n            const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n            const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n            for (const square of squares) {\n                // is the square off the board?\n                if (square & 0x88) {\n                    continue;\n                }\n                const color = this._turn;\n                // is there a pawn that can capture the epSquare?\n                if (this._board[square]?.color === color &&\n                    this._board[square]?.type === PAWN) {\n                    // if the pawn makes an ep capture, does it leave it's king in check?\n                    this._makeMove({\n                        color,\n                        from: square,\n                        to: this._epSquare,\n                        piece: PAWN,\n                        captured: PAWN,\n                        flags: BITS.EP_CAPTURE,\n                    });\n                    const isLegal = !this._isKingAttacked(color);\n                    this._undoMove();\n                    // if ep is legal, break and set the ep square in the FEN output\n                    if (isLegal) {\n                        epSquare = algebraic(this._epSquare);\n                        break;\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            delete this._header['SetUp'];\n            delete this._header['FEN'];\n        }\n    }\n    reset() {\n        this.load(DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]];\n    }\n    put({ type, color }, square) {\n        if (this._put({ type, color }, square)) {\n            this._updateCastlingRights();\n            this._updateEnPassantSquare();\n            this._updateSetup(this.fen());\n            return true;\n        }\n        return false;\n    }\n    _put({ type, color }, square) {\n        // check for piece\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        // check for valid square\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        // don't let the user place more than one king\n        if (type == KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        const currentPieceOnSquare = this._board[sq];\n        // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n        if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n            this._kings[currentPieceOnSquare.color] = EMPTY;\n        }\n        this._board[sq] = { type: type, color: color };\n        if (type === KING) {\n            this._kings[color] = sq;\n        }\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[Ox88[square]];\n        if (piece && piece.type === KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateCastlingRights();\n        this._updateEnPassantSquare();\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _updateCastlingRights() {\n        const whiteKingInPlace = this._board[Ox88.e1]?.type === KING &&\n            this._board[Ox88.e1]?.color === WHITE;\n        const blackKingInPlace = this._board[Ox88.e8]?.type === KING &&\n            this._board[Ox88.e8]?.color === BLACK;\n        if (!whiteKingInPlace ||\n            this._board[Ox88.a1]?.type !== ROOK ||\n            this._board[Ox88.a1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!whiteKingInPlace ||\n            this._board[Ox88.h1]?.type !== ROOK ||\n            this._board[Ox88.h1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.KSIDE_CASTLE;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.a8]?.type !== ROOK ||\n            this._board[Ox88.a8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.h8]?.type !== ROOK ||\n            this._board[Ox88.h8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.KSIDE_CASTLE;\n        }\n    }\n    _updateEnPassantSquare() {\n        if (this._epSquare === EMPTY) {\n            return;\n        }\n        const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n        const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n        const attackers = [currentSquare + 1, currentSquare - 1];\n        if (this._board[startSquare] !== null ||\n            this._board[this._epSquare] !== null ||\n            this._board[currentSquare]?.color !== swapColor(this._turn) ||\n            this._board[currentSquare]?.type !== PAWN) {\n            this._epSquare = EMPTY;\n            return;\n        }\n        const canCapture = (square) => !(square & 0x88) &&\n            this._board[square]?.color === this._turn &&\n            this._board[square]?.type === PAWN;\n        if (!attackers.some(canCapture)) {\n            this._epSquare = EMPTY;\n        }\n    }\n    _attacked(color, square, verbose) {\n        const attackers = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) {\n                continue;\n            }\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === PAWN) {\n                    if ((difference > 0 && piece.color === WHITE) ||\n                        (difference <= 0 && piece.color === BLACK)) {\n                        if (!verbose) {\n                            return true;\n                        }\n                        else {\n                            attackers.push(algebraic(i));\n                        }\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === 'n' || piece.type === 'k') {\n                    if (!verbose) {\n                        return true;\n                    }\n                    else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked) {\n                    if (!verbose) {\n                        return true;\n                    }\n                    else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n            }\n        }\n        if (verbose) {\n            return attackers;\n        }\n        else {\n            return false;\n        }\n    }\n    attackers(square, attackedBy) {\n        if (!attackedBy) {\n            return this._attacked(this._turn, Ox88[square], true);\n        }\n        else {\n            return this._attacked(attackedBy, Ox88[square], true);\n        }\n    }\n    _isKingAttacked(color) {\n        const square = this._kings[color];\n        return square === -1 ? false : this._attacked(swapColor(color), square);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        return this._getPositionCount(this.fen()) >= 3;\n    }\n    isDrawByFiftyMoves() {\n        return this._halfMoves >= 100; // 50 moves per side = 100 half moves\n    }\n    isDraw() {\n        return (this.isDrawByFiftyMoves() ||\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, piece = undefined, } = {}) {\n        const moves = this._moves({ square, piece });\n        if (verbose) {\n            return moves.map((move) => new Move(this, move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece?.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                // single square, non-capturing\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, PAWN);\n                    // double square\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                // pawn captures\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (this._board[to]?.color === them) {\n                        addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === KNIGHT || type === KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                // queen-side castling\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal || this._kings[us] === -1) {\n            return moves;\n        }\n        // filter out illegal moves\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { strict = false } = {}) {\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, strict);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === 'string') {\n                throw new Error(`Invalid move: ${move}`);\n            }\n            else {\n                throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n            }\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */\n        const prettyMove = new Move(this, moveObj);\n        this._makeMove(moveObj);\n        this._incPositionCount(prettyMove.after);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        // if ep capture, remove the captured pawn\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === BLACK) {\n                delete this._board[move.to - 16];\n            }\n            else {\n                delete this._board[move.to + 16];\n            }\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) {\n            this._board[move.to] = { type: move.promotion, color: us };\n        }\n        // if we moved the king\n        if (this._board[move.to].type === KING) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        // if big pawn move, update the en passant square\n        if (move.flags & BITS.BIG_PAWN) {\n            if (us === BLACK) {\n                this._epSquare = move.to - 16;\n            }\n            else {\n                this._epSquare = move.to + 16;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        if (move) {\n            const prettyMove = new Move(this, move);\n            this._decPositionCount(prettyMove.after);\n            return prettyMove;\n        }\n        return null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._board[index] = { type: PAWN, color: them };\n            }\n            else {\n                // regular capture\n                this._board[move.to] = { type: move.captured, color: them };\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */\n            result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                // is there a comment preceding the first move?\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                // store the previous generated move_string if we have one\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        // is there a result?\n        if (typeof this._header.Result !== 'undefined') {\n            moves.push(this._header.Result);\n        }\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // TODO (jah): huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    /*\n     * @deprecated Use `setHeader` and `getHeaders` instead.\n     */\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    setHeader(key, value) {\n        this._header[key] = value;\n        return this._header;\n    }\n    removeHeader(key) {\n        if (key in this._header) {\n            delete this._header[key];\n            return true;\n        }\n        return false;\n    }\n    getHeaders() {\n        return this._header;\n    }\n    loadPgn(pgn, { strict = false, newlineChar = '\\r?\\n', } = {}) {\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = '';\n            let value = '';\n            for (let i = 0; i < headers.length; i++) {\n                const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, '$1');\n                value = headers[i].replace(regex, '$2');\n                if (key.trim().length > 0) {\n                    headerObj[key] = value;\n                }\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        /*\n         * RegExp to split header. Takes advantage of the fact that header and movetext\n         * will always have a blank line between them (ie, two newline_char's). Handles\n         * case where movetext is empty by matching newlineChar until end of string is\n         * matched - effectively trimming from the end extra newlineChar.\n         *\n         * With default newline_char, will equal:\n         * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n         */\n        const headerRegex = new RegExp('^(\\\\[((?:' +\n            mask(newlineChar) +\n            ')|.)*\\\\])' +\n            '((?:\\\\s*' +\n            mask(newlineChar) +\n            '){2}|(?:\\\\s*' +\n            mask(newlineChar) +\n            ')*$)');\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults\n            ? headerRegexResults.length >= 2\n                ? headerRegexResults[1]\n                : ''\n            : '';\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsePgnHeader(headerString);\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */\n        if (!strict) {\n            if (fen) {\n                this.load(fen, { preserveHeaders: true });\n            }\n        }\n        else {\n            /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers)) {\n                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n                }\n                // don't clear the headers when loading\n                this.load(headers['FEN'], { preserveHeaders: true });\n            }\n        }\n        /*\n         * NB: the regexes below that delete move numbers, recursive annotations,\n         * and numeric annotation glyphs may also match text in comments. To\n         * prevent this, we transform comments by hex-encoding them in place and\n         * decoding them again after the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded, we use\n         * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n         * for modern users\n         */\n        function toHex(s) {\n            return Array.from(s)\n                .map(function (c) {\n                /*\n                 * encodeURI doesn't transform most ASCII characters, so we handle\n                 * these ourselves\n                 */\n                return c.charCodeAt(0) < 128\n                    ? c.charCodeAt(0).toString(16)\n                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n            })\n                .join('');\n        }\n        function fromHex(s) {\n            return s.length == 0\n                ? ''\n                : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n        }\n        const encodeComment = function (s) {\n            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n            return `{${toHex(s.slice(1, s.length - 1))}}`;\n        };\n        const decodeComment = function (s) {\n            if (s.startsWith('{') && s.endsWith('}')) {\n                return fromHex(s.slice(1, s.length - 1));\n            }\n        };\n        // delete header to get the moves\n        let ms = pgn\n            .replace(headerString, '')\n            .replace(\n        // encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n            return bracket !== undefined\n                ? encodeComment(bracket)\n                : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n        })\n            .replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        // delete recursive annotation variations\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while (ravRegex.test(ms)) {\n            ms = ms.replace(ravRegex, '');\n        }\n        // delete move numbers\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n        // delete ... indicating black to move\n        ms = ms.replace(/\\.\\.\\./g, '');\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n        // trim and get array of moves\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        // delete empty entries\n        moves = moves.filter((move) => move !== '');\n        let result = '';\n        for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], strict);\n            // invalid move\n            if (move == null) {\n                // was the move an end of game marker\n                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n                    result = moves[halfMove];\n                }\n                else {\n                    throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n                }\n            }\n            else {\n                // reset the end of game marker if making a valid move\n                result = '';\n                this._makeMove(move);\n                this._incPositionCount(this.fen());\n            }\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */\n        if (result && Object.keys(this._header).length && !this._header['Result']) {\n            this.header('Result', result);\n        }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else {\n            if (move.piece !== PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move, strict = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = strippedSan(move);\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // the strict parser failed\n        if (strict) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        if (!to) {\n            return null;\n        }\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (!from) {\n                // if there is no from square, it could be just 'x' missing from a capture\n                if (cleanMove ===\n                    strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n                    return moves[i];\n                }\n                // hand-compare move properties with the results from our permissive regex\n            }\n            else if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                Ox88[from] == moves[i].from &&\n                Ox88[to] == moves[i].to &&\n                (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                return moves[i];\n            }\n            else if (overlyDisambiguated) {\n                /*\n                 * SPECIAL CASE: we parsed a move string that may have an unneeded\n                 * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                 */\n                const square = algebraic(moves[i].from);\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[to] == moves[i].to &&\n                    (from == square[0] || from == square[1]) &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // display the rank\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(new Move(this, move));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    /*\n     * Keeps track of position occurrence counts for the purpose of repetition\n     * checking. All three methods (`_inc`, `_dec`, and `_get`) trim the\n     * irrelevent information from the fen, initialising new positions, and\n     * removing old positions from the record if their counts are reduced to 0.\n     */\n    _getPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        return this._positionCount[trimmedFen] || 0;\n    }\n    _incPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === undefined) {\n            this._positionCount[trimmedFen] = 0;\n        }\n        this._positionCount[trimmedFen] += 1;\n    }\n    _decPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === 1) {\n            delete this._positionCount[trimmedFen];\n        }\n        else {\n            this._positionCount[trimmedFen] -= 1;\n        }\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    /**\n     * @deprecated Renamed to `removeComment` for consistency\n     */\n    deleteComment() {\n        return this.removeComment();\n    }\n    removeComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    /**\n     * @deprecated Renamed to `removeComments` for consistency\n     */\n    deleteComments() {\n        return this.removeComments();\n    }\n    removeComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n    setCastlingRights(color, rights) {\n        for (const side of [KING, QUEEN]) {\n            if (rights[side] !== undefined) {\n                if (rights[side]) {\n                    this._castling[color] |= SIDES[side];\n                }\n                else {\n                    this._castling[color] &= ~SIDES[side];\n                }\n            }\n        }\n        this._updateCastlingRights();\n        const result = this.getCastlingRights(color);\n        return ((rights[KING] === undefined || rights[KING] === result[KING]) &&\n            (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]));\n    }\n    getCastlingRights(color) {\n        return {\n            [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n            [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n        };\n    }\n    moveNumber() {\n        return this._moveNumber;\n    }\n}\n//# sourceMappingURL=chess.js.map","/**\n * @license\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nexport const WHITE = 'w'\nexport const BLACK = 'b'\n\nexport const PAWN = 'p'\nexport const KNIGHT = 'n'\nexport const BISHOP = 'b'\nexport const ROOK = 'r'\nexport const QUEEN = 'q'\nexport const KING = 'k'\n\nexport type Color = 'w' | 'b'\nexport type PieceSymbol = 'p' | 'n' | 'b' | 'r' | 'q' | 'k'\n\n// prettier-ignore\nexport type Square =\n    'a8' | 'b8' | 'c8' | 'd8' | 'e8' | 'f8' | 'g8' | 'h8' |\n    'a7' | 'b7' | 'c7' | 'd7' | 'e7' | 'f7' | 'g7' | 'h7' |\n    'a6' | 'b6' | 'c6' | 'd6' | 'e6' | 'f6' | 'g6' | 'h6' |\n    'a5' | 'b5' | 'c5' | 'd5' | 'e5' | 'f5' | 'g5' | 'h5' |\n    'a4' | 'b4' | 'c4' | 'd4' | 'e4' | 'f4' | 'g4' | 'h4' |\n    'a3' | 'b3' | 'c3' | 'd3' | 'e3' | 'f3' | 'g3' | 'h3' |\n    'a2' | 'b2' | 'c2' | 'd2' | 'e2' | 'f2' | 'g2' | 'h2' |\n    'a1' | 'b1' | 'c1' | 'd1' | 'e1' | 'f1' | 'g1' | 'h1'\n\nexport const DEFAULT_POSITION =\n  'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n\nexport type Piece = {\n  color: Color\n  type: PieceSymbol\n}\n\ntype InternalMove = {\n  color: Color\n  from: number\n  to: number\n  piece: PieceSymbol\n  captured?: PieceSymbol\n  promotion?: PieceSymbol\n  flags: number\n}\n\ninterface History {\n  move: InternalMove\n  kings: Record<Color, number>\n  turn: Color\n  castling: Record<Color, number>\n  epSquare: number\n  halfMoves: number\n  moveNumber: number\n}\n\nexport class Move {\n  color: Color\n  from: Square\n  to: Square\n  piece: PieceSymbol\n  captured?: PieceSymbol\n  promotion?: PieceSymbol\n\n  /**\n   * @deprecated This field is deprecated and will be removed in version 2.0.0.\n   * Please use move descriptor functions instead: `isCapture`, `isPromotion`,\n   * `isEnPassant`, `isKingsideCastle`, `isQueensideCastle`, `isCastle`, and\n   * `isBigPawn`\n   */\n  flags: string\n\n  san: string\n  lan: string\n  before: string\n  after: string\n\n  constructor(chess: Chess, internal: InternalMove) {\n    const { color, piece, from, to, flags, captured, promotion } = internal\n\n    const fromAlgebraic = algebraic(from)\n    const toAlgebraic = algebraic(to)\n\n    this.color = color\n    this.piece = piece\n    this.from = fromAlgebraic\n    this.to = toAlgebraic\n\n    /*\n     * HACK: The chess['_method']() calls below invoke private methods in the\n     * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\n     * code cleaner elsewhere.\n     */\n\n    this.san = chess['_moveToSan'](internal, chess['_moves']({ legal: true }))\n    this.lan = fromAlgebraic + toAlgebraic\n    this.before = chess.fen()\n\n    // Generate the FEN for the 'after' key\n    chess['_makeMove'](internal)\n    this.after = chess.fen()\n    chess['_undoMove']()\n\n    // Build the text representation of the move flags\n    this.flags = ''\n    for (const flag in BITS) {\n      if (BITS[flag] & flags) {\n        this.flags += FLAGS[flag]\n      }\n    }\n\n    if (captured) {\n      this.captured = captured\n    }\n\n    if (promotion) {\n      this.promotion = promotion\n      this.lan += promotion\n    }\n  }\n\n  isCapture() {\n    return this.flags.indexOf(FLAGS['CAPTURE']) > -1\n  }\n\n  isPromotion() {\n    return this.flags.indexOf(FLAGS['PROMOTION']) > -1\n  }\n\n  isEnPassant() {\n    return this.flags.indexOf(FLAGS['EP_CAPTURE']) > -1\n  }\n\n  isKingsideCastle() {\n    return this.flags.indexOf(FLAGS['KSIDE_CASTLE']) > -1\n  }\n\n  isQueensideCastle() {\n    return this.flags.indexOf(FLAGS['QSIDE_CASTLE']) > -1\n  }\n\n  isBigPawn() {\n    return this.flags.indexOf(FLAGS['BIG_PAWN']) > -1\n  }\n}\n\nconst EMPTY = -1\n\nconst FLAGS: Record<string, string> = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q',\n}\n\n// prettier-ignore\nexport const SQUARES: Square[] = [\n  'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n  'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n  'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n  'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n  'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n  'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n  'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n  'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n]\n\nconst BITS: Record<string, number> = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64,\n}\n\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88: Record<Square, number> = {\n  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\n  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\n  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\n  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\n  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\n  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\n  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\n  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n}\n\nconst PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15],\n}\n\nconst PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1],\n}\n\n// prettier-ignore\nconst ATTACKS = [\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n  24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\n];\n\n// prettier-ignore\nconst RAYS = [\n   17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\n    0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\n    0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\n    0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\n    0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\n    1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\n    0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\n    0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\n    0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\n    0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\n  -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\n];\n\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 }\n\nconst SYMBOLS = 'pnbrqkPNBRQK'\n\nconst PROMOTIONS: PieceSymbol[] = [KNIGHT, BISHOP, ROOK, QUEEN]\n\nconst RANK_1 = 7\nconst RANK_2 = 6\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1\nconst RANK_8 = 0\n\nconst SIDES = {\n  [KING]: BITS.KSIDE_CASTLE,\n  [QUEEN]: BITS.QSIDE_CASTLE,\n}\n\nconst ROOKS = {\n  w: [\n    { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n    { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n  ],\n  b: [\n    { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n    { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n  ],\n}\n\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 }\n\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*']\n\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square: number): number {\n  return square >> 4\n}\n\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square: number): number {\n  return square & 0xf\n}\n\nfunction isDigit(c: string): boolean {\n  return '0123456789'.indexOf(c) !== -1\n}\n\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square: number): Square {\n  const f = file(square)\n  const r = rank(square)\n  return ('abcdefgh'.substring(f, f + 1) +\n    '87654321'.substring(r, r + 1)) as Square\n}\n\nfunction swapColor(color: Color): Color {\n  return color === WHITE ? BLACK : WHITE\n}\n\nexport function validateFen(fen: string): { ok: boolean; error?: string } {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/)\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields',\n    }\n  }\n\n  // 2nd criterion: move number field is a integer value > 0?\n  const moveNumber = parseInt(tokens[5], 10)\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer',\n    }\n  }\n\n  // 3rd criterion: half move counter is an integer >= 0?\n  const halfMoves = parseInt(tokens[4], 10)\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error:\n        'Invalid FEN: half move counter number must be a non-negative integer',\n    }\n  }\n\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return { ok: false, error: 'Invalid FEN: en-passant square is invalid' }\n  }\n\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return { ok: false, error: 'Invalid FEN: castling availability is invalid' }\n  }\n\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return { ok: false, error: 'Invalid FEN: side-to-move is invalid' }\n  }\n\n  // 7th criterion: 1st field contains 8 rows?\n  const rows = tokens[0].split('/')\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n    }\n  }\n\n  // 8th criterion: every row is valid?\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0\n    let previousWasNumber = false\n\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)',\n          }\n        }\n        sumFields += parseInt(rows[i][k], 10)\n        previousWasNumber = true\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)',\n          }\n        }\n        sumFields += 1\n        previousWasNumber = false\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n      }\n    }\n  }\n\n  // 9th criterion: is en-passant square legal?\n  if (\n    (tokens[3][1] == '3' && tokens[1] == 'w') ||\n    (tokens[3][1] == '6' && tokens[1] == 'b')\n  ) {\n    return { ok: false, error: 'Invalid FEN: illegal en-passant square' }\n  }\n\n  // 10th criterion: does chess position contain exact two kings?\n  const kings = [\n    { color: 'white', regex: /K/g },\n    { color: 'black', regex: /k/g },\n  ]\n\n  for (const { color, regex } of kings) {\n    if (!regex.test(tokens[0])) {\n      return { ok: false, error: `Invalid FEN: missing ${color} king` }\n    }\n\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return { ok: false, error: `Invalid FEN: too many ${color} kings` }\n    }\n  }\n\n  // 11th criterion: are any pawns on the first or eighth rows?\n  if (\n    Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')\n  ) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: some pawns are on the edge rows',\n    }\n  }\n\n  return { ok: true }\n}\n\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move: InternalMove, moves: InternalMove[]): string {\n  const from = move.from\n  const to = move.to\n  const piece = move.piece\n\n  let ambiguities = 0\n  let sameRank = 0\n  let sameFile = 0\n\n  for (let i = 0, len = moves.length; i < len; i++) {\n    const ambigFrom = moves[i].from\n    const ambigTo = moves[i].to\n    const ambigPiece = moves[i].piece\n\n    /*\n     * if a move of the same piece type ends on the same to square, we'll need\n     * to add a disambiguator to the algebraic notation\n     */\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n      ambiguities++\n\n      if (rank(from) === rank(ambigFrom)) {\n        sameRank++\n      }\n\n      if (file(from) === file(ambigFrom)) {\n        sameFile++\n      }\n    }\n  }\n\n  if (ambiguities > 0) {\n    if (sameRank > 0 && sameFile > 0) {\n      /*\n       * if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      return algebraic(from)\n    } else if (sameFile > 0) {\n      /*\n       * if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      return algebraic(from).charAt(1)\n    } else {\n      // else use the file symbol\n      return algebraic(from).charAt(0)\n    }\n  }\n\n  return ''\n}\n\nfunction addMove(\n  moves: InternalMove[],\n  color: Color,\n  from: number,\n  to: number,\n  piece: PieceSymbol,\n  captured: PieceSymbol | undefined = undefined,\n  flags: number = BITS.NORMAL,\n) {\n  const r = rank(to)\n\n  if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n    for (let i = 0; i < PROMOTIONS.length; i++) {\n      const promotion = PROMOTIONS[i]\n      moves.push({\n        color,\n        from,\n        to,\n        piece,\n        captured,\n        promotion,\n        flags: flags | BITS.PROMOTION,\n      })\n    }\n  } else {\n    moves.push({\n      color,\n      from,\n      to,\n      piece,\n      captured,\n      flags,\n    })\n  }\n}\n\nfunction inferPieceType(san: string): PieceSymbol | undefined {\n  let pieceType = san.charAt(0)\n  if (pieceType >= 'a' && pieceType <= 'h') {\n    const matches = san.match(/[a-h]\\d.*[a-h]\\d/)\n    if (matches) {\n      return undefined\n    }\n    return PAWN\n  }\n  pieceType = pieceType.toLowerCase()\n  if (pieceType === 'o') {\n    return KING\n  }\n  return pieceType as PieceSymbol\n}\n\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move: string): string {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n}\n\nfunction trimFen(fen: string): string {\n  /*\n   * remove last two fields in FEN string as they're not needed when checking\n   * for repetition\n   */\n  return fen.split(' ').slice(0, 4).join(' ')\n}\n\nexport class Chess {\n  private _board = new Array<Piece>(128)\n  private _turn: Color = WHITE\n  private _header: Record<string, string> = {}\n  private _kings: Record<Color, number> = { w: EMPTY, b: EMPTY }\n  private _epSquare = -1\n  private _halfMoves = 0\n  private _moveNumber = 0\n  private _history: History[] = []\n  private _comments: Record<string, string> = {}\n  private _castling: Record<Color, number> = { w: 0, b: 0 }\n\n  // tracks number of times a position has been seen for repetition checking\n  private _positionCount: Record<string, number> = {}\n\n  constructor(fen = DEFAULT_POSITION) {\n    this.load(fen)\n  }\n\n  clear({ preserveHeaders = false } = {}) {\n    this._board = new Array<Piece>(128)\n    this._kings = { w: EMPTY, b: EMPTY }\n    this._turn = WHITE\n    this._castling = { w: 0, b: 0 }\n    this._epSquare = EMPTY\n    this._halfMoves = 0\n    this._moveNumber = 1\n    this._history = []\n    this._comments = {}\n    this._header = preserveHeaders ? this._header : {}\n    this._positionCount = {}\n\n    /*\n     * Delete the SetUp and FEN headers (if preserved), the board is empty and\n     * these headers don't make sense in this state. They'll get added later\n     * via .load() or .put()\n     */\n    delete this._header['SetUp']\n    delete this._header['FEN']\n  }\n\n  load(fen: string, { skipValidation = false, preserveHeaders = false } = {}) {\n    let tokens = fen.split(/\\s+/)\n\n    // append commonly omitted fen tokens\n    if (tokens.length >= 2 && tokens.length < 6) {\n      const adjustments = ['-', '-', '0', '1']\n      fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ')\n    }\n\n    tokens = fen.split(/\\s+/)\n\n    if (!skipValidation) {\n      const { ok, error } = validateFen(fen)\n      if (!ok) {\n        throw new Error(error)\n      }\n    }\n\n    const position = tokens[0]\n    let square = 0\n\n    this.clear({ preserveHeaders })\n\n    for (let i = 0; i < position.length; i++) {\n      const piece = position.charAt(i)\n\n      if (piece === '/') {\n        square += 8\n      } else if (isDigit(piece)) {\n        square += parseInt(piece, 10)\n      } else {\n        const color = piece < 'a' ? WHITE : BLACK\n        this._put(\n          { type: piece.toLowerCase() as PieceSymbol, color },\n          algebraic(square),\n        )\n        square++\n      }\n    }\n\n    this._turn = tokens[1] as Color\n\n    if (tokens[2].indexOf('K') > -1) {\n      this._castling.w |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      this._castling.w |= BITS.QSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      this._castling.b |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      this._castling.b |= BITS.QSIDE_CASTLE\n    }\n\n    this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3] as Square]\n    this._halfMoves = parseInt(tokens[4], 10)\n    this._moveNumber = parseInt(tokens[5], 10)\n\n    this._updateSetup(fen)\n    this._incPositionCount(fen)\n  }\n\n  fen() {\n    let empty = 0\n    let fen = ''\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i]) {\n        if (empty > 0) {\n          fen += empty\n          empty = 0\n        }\n        const { color, type: piece } = this._board[i]\n\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n      } else {\n        empty++\n      }\n\n      if ((i + 1) & 0x88) {\n        if (empty > 0) {\n          fen += empty\n        }\n\n        if (i !== Ox88.h1) {\n          fen += '/'\n        }\n\n        empty = 0\n        i += 8\n      }\n    }\n\n    let castling = ''\n    if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n      castling += 'K'\n    }\n    if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n      castling += 'Q'\n    }\n    if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n      castling += 'k'\n    }\n    if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n      castling += 'q'\n    }\n\n    // do we have an empty castling flag?\n    castling = castling || '-'\n\n    let epSquare = '-'\n    /*\n     * only print the ep square if en passant is a valid move (pawn is present\n     * and ep capture is not pinned)\n     */\n    if (this._epSquare !== EMPTY) {\n      const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\n      const squares = [bigPawnSquare + 1, bigPawnSquare - 1]\n\n      for (const square of squares) {\n        // is the square off the board?\n        if (square & 0x88) {\n          continue\n        }\n\n        const color = this._turn\n\n        // is there a pawn that can capture the epSquare?\n        if (\n          this._board[square]?.color === color &&\n          this._board[square]?.type === PAWN\n        ) {\n          // if the pawn makes an ep capture, does it leave it's king in check?\n          this._makeMove({\n            color,\n            from: square,\n            to: this._epSquare,\n            piece: PAWN,\n            captured: PAWN,\n            flags: BITS.EP_CAPTURE,\n          })\n          const isLegal = !this._isKingAttacked(color)\n          this._undoMove()\n\n          // if ep is legal, break and set the ep square in the FEN output\n          if (isLegal) {\n            epSquare = algebraic(this._epSquare)\n            break\n          }\n        }\n      }\n    }\n\n    return [\n      fen,\n      this._turn,\n      castling,\n      epSquare,\n      this._halfMoves,\n      this._moveNumber,\n    ].join(' ')\n  }\n\n  /*\n   * Called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object. If the FEN\n   * is equal to the default position, the SetUp and FEN are deleted the setup\n   * is only updated if history.length is zero, ie moves haven't been made.\n   */\n  private _updateSetup(fen: string) {\n    if (this._history.length > 0) return\n\n    if (fen !== DEFAULT_POSITION) {\n      this._header['SetUp'] = '1'\n      this._header['FEN'] = fen\n    } else {\n      delete this._header['SetUp']\n      delete this._header['FEN']\n    }\n  }\n\n  reset() {\n    this.load(DEFAULT_POSITION)\n  }\n\n  get(square: Square): Piece | undefined {\n    return this._board[Ox88[square]]\n  }\n\n  put(\n    { type, color }: { type: PieceSymbol; color: Color },\n    square: Square,\n  ): boolean {\n    if (this._put({ type, color }, square)) {\n      this._updateCastlingRights()\n      this._updateEnPassantSquare()\n      this._updateSetup(this.fen())\n      return true\n    }\n    return false\n  }\n\n  private _put(\n    { type, color }: { type: PieceSymbol; color: Color },\n    square: Square,\n  ): boolean {\n    // check for piece\n    if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n      return false\n    }\n\n    // check for valid square\n    if (!(square in Ox88)) {\n      return false\n    }\n\n    const sq = Ox88[square]\n\n    // don't let the user place more than one king\n    if (\n      type == KING &&\n      !(this._kings[color] == EMPTY || this._kings[color] == sq)\n    ) {\n      return false\n    }\n\n    const currentPieceOnSquare = this._board[sq]\n\n    // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n    if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n      this._kings[currentPieceOnSquare.color] = EMPTY\n    }\n\n    this._board[sq] = { type: type as PieceSymbol, color: color as Color }\n\n    if (type === KING) {\n      this._kings[color] = sq\n    }\n\n    return true\n  }\n\n  remove(square: Square): Piece | undefined {\n    const piece = this.get(square)\n    delete this._board[Ox88[square]]\n    if (piece && piece.type === KING) {\n      this._kings[piece.color] = EMPTY\n    }\n\n    this._updateCastlingRights()\n    this._updateEnPassantSquare()\n    this._updateSetup(this.fen())\n\n    return piece\n  }\n\n  private _updateCastlingRights() {\n    const whiteKingInPlace =\n      this._board[Ox88.e1]?.type === KING &&\n      this._board[Ox88.e1]?.color === WHITE\n    const blackKingInPlace =\n      this._board[Ox88.e8]?.type === KING &&\n      this._board[Ox88.e8]?.color === BLACK\n\n    if (\n      !whiteKingInPlace ||\n      this._board[Ox88.a1]?.type !== ROOK ||\n      this._board[Ox88.a1]?.color !== WHITE\n    ) {\n      this._castling.w &= ~BITS.QSIDE_CASTLE\n    }\n\n    if (\n      !whiteKingInPlace ||\n      this._board[Ox88.h1]?.type !== ROOK ||\n      this._board[Ox88.h1]?.color !== WHITE\n    ) {\n      this._castling.w &= ~BITS.KSIDE_CASTLE\n    }\n\n    if (\n      !blackKingInPlace ||\n      this._board[Ox88.a8]?.type !== ROOK ||\n      this._board[Ox88.a8]?.color !== BLACK\n    ) {\n      this._castling.b &= ~BITS.QSIDE_CASTLE\n    }\n\n    if (\n      !blackKingInPlace ||\n      this._board[Ox88.h8]?.type !== ROOK ||\n      this._board[Ox88.h8]?.color !== BLACK\n    ) {\n      this._castling.b &= ~BITS.KSIDE_CASTLE\n    }\n  }\n\n  private _updateEnPassantSquare() {\n    if (this._epSquare === EMPTY) {\n      return\n    }\n\n    const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16)\n    const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\n    const attackers = [currentSquare + 1, currentSquare - 1]\n\n    if (\n      this._board[startSquare] !== null ||\n      this._board[this._epSquare] !== null ||\n      this._board[currentSquare]?.color !== swapColor(this._turn) ||\n      this._board[currentSquare]?.type !== PAWN\n    ) {\n      this._epSquare = EMPTY\n      return\n    }\n\n    const canCapture = (square: number) =>\n      !(square & 0x88) &&\n      this._board[square]?.color === this._turn &&\n      this._board[square]?.type === PAWN\n\n    if (!attackers.some(canCapture)) {\n      this._epSquare = EMPTY\n    }\n  }\n\n  private _attacked(color: Color, square: number): boolean\n  private _attacked(color: Color, square: number, verbose: false): boolean\n  private _attacked(color: Color, square: number, verbose: true): Square[]\n  private _attacked(color: Color, square: number, verbose?: boolean) {\n    const attackers: Square[] = []\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      // if empty square or wrong color\n      if (this._board[i] === undefined || this._board[i].color !== color) {\n        continue\n      }\n\n      const piece = this._board[i]\n      const difference = i - square\n\n      // skip - to/from square are the same\n      if (difference === 0) {\n        continue\n      }\n\n      const index = difference + 119\n\n      if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n        if (piece.type === PAWN) {\n          if (\n            (difference > 0 && piece.color === WHITE) ||\n            (difference <= 0 && piece.color === BLACK)\n          ) {\n            if (!verbose) {\n              return true\n            } else {\n              attackers.push(algebraic(i))\n            }\n          }\n          continue\n        }\n\n        // if the piece is a knight or a king\n        if (piece.type === 'n' || piece.type === 'k') {\n          if (!verbose) {\n            return true\n          } else {\n            attackers.push(algebraic(i))\n            continue\n          }\n        }\n\n        const offset = RAYS[index]\n        let j = i + offset\n\n        let blocked = false\n        while (j !== square) {\n          if (this._board[j] != null) {\n            blocked = true\n            break\n          }\n          j += offset\n        }\n\n        if (!blocked) {\n          if (!verbose) {\n            return true\n          } else {\n            attackers.push(algebraic(i))\n            continue\n          }\n        }\n      }\n    }\n\n    if (verbose) {\n      return attackers\n    } else {\n      return false\n    }\n  }\n\n  attackers(square: Square, attackedBy?: Color): Square[] {\n    if (!attackedBy) {\n      return this._attacked(this._turn, Ox88[square], true)\n    } else {\n      return this._attacked(attackedBy, Ox88[square], true)\n    }\n  }\n\n  private _isKingAttacked(color: Color): boolean {\n    const square = this._kings[color]\n    return square === -1 ? false : this._attacked(swapColor(color), square)\n  }\n\n  isAttacked(square: Square, attackedBy: Color): boolean {\n    return this._attacked(attackedBy, Ox88[square])\n  }\n\n  isCheck(): boolean {\n    return this._isKingAttacked(this._turn)\n  }\n\n  inCheck(): boolean {\n    return this.isCheck()\n  }\n\n  isCheckmate(): boolean {\n    return this.isCheck() && this._moves().length === 0\n  }\n\n  isStalemate(): boolean {\n    return !this.isCheck() && this._moves().length === 0\n  }\n\n  isInsufficientMaterial(): boolean {\n    /*\n     * k.b. vs k.b. (of opposite colors) with mate in 1:\n     * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n     *\n     * k.b. vs k.n. with mate in 1:\n     * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n     */\n    const pieces: Record<PieceSymbol, number> = {\n      b: 0,\n      n: 0,\n      r: 0,\n      q: 0,\n      k: 0,\n      p: 0,\n    }\n    const bishops = []\n    let numPieces = 0\n    let squareColor = 0\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      squareColor = (squareColor + 1) % 2\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      const piece = this._board[i]\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\n        if (piece.type === BISHOP) {\n          bishops.push(squareColor)\n        }\n        numPieces++\n      }\n    }\n\n    // k vs. k\n    if (numPieces === 2) {\n      return true\n    } else if (\n      // k vs. kn .... or .... k vs. kb\n      numPieces === 3 &&\n      (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\n    ) {\n      return true\n    } else if (numPieces === pieces[BISHOP] + 2) {\n      // kb vs. kb where any number of bishops are all on the same color\n      let sum = 0\n      const len = bishops.length\n      for (let i = 0; i < len; i++) {\n        sum += bishops[i]\n      }\n      if (sum === 0 || sum === len) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  isThreefoldRepetition(): boolean {\n    return this._getPositionCount(this.fen()) >= 3\n  }\n\n  isDrawByFiftyMoves(): boolean {\n    return this._halfMoves >= 100 // 50 moves per side = 100 half moves\n  }\n\n  isDraw(): boolean {\n    return (\n      this.isDrawByFiftyMoves() ||\n      this.isStalemate() ||\n      this.isInsufficientMaterial() ||\n      this.isThreefoldRepetition()\n    )\n  }\n\n  isGameOver(): boolean {\n    return this.isCheckmate() || this.isStalemate() || this.isDraw()\n  }\n\n  moves(): string[]\n  moves({ square }: { square: Square }): string[]\n  moves({ piece }: { piece: PieceSymbol }): string[]\n\n  moves({ square, piece }: { square: Square; piece: PieceSymbol }): string[]\n\n  moves({ verbose, square }: { verbose: true; square?: Square }): Move[]\n  moves({ verbose, square }: { verbose: false; square?: Square }): string[]\n  moves({\n    verbose,\n    square,\n  }: {\n    verbose?: boolean\n    square?: Square\n  }): string[] | Move[]\n\n  moves({ verbose, piece }: { verbose: true; piece?: PieceSymbol }): Move[]\n  moves({ verbose, piece }: { verbose: false; piece?: PieceSymbol }): string[]\n  moves({\n    verbose,\n    piece,\n  }: {\n    verbose?: boolean\n    piece?: PieceSymbol\n  }): string[] | Move[]\n\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose: true\n    square?: Square\n    piece?: PieceSymbol\n  }): Move[]\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose: false\n    square?: Square\n    piece?: PieceSymbol\n  }): string[]\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose?: boolean\n    square?: Square\n    piece?: PieceSymbol\n  }): string[] | Move[]\n\n  moves({ square, piece }: { square?: Square; piece?: PieceSymbol }): Move[]\n\n  moves({\n    verbose = false,\n    square = undefined,\n    piece = undefined,\n  }: { verbose?: boolean; square?: Square; piece?: PieceSymbol } = {}) {\n    const moves = this._moves({ square, piece })\n\n    if (verbose) {\n      return moves.map((move) => new Move(this, move))\n    } else {\n      return moves.map((move) => this._moveToSan(move, moves))\n    }\n  }\n\n  private _moves({\n    legal = true,\n    piece = undefined,\n    square = undefined,\n  }: {\n    legal?: boolean\n    piece?: PieceSymbol\n    square?: Square\n  } = {}): InternalMove[] {\n    const forSquare = square ? (square.toLowerCase() as Square) : undefined\n    const forPiece = piece?.toLowerCase()\n\n    const moves: InternalMove[] = []\n    const us = this._turn\n    const them = swapColor(us)\n\n    let firstSquare = Ox88.a8\n    let lastSquare = Ox88.h1\n    let singleSquare = false\n\n    // are we generating moves for a single square?\n    if (forSquare) {\n      // illegal square, return empty moves\n      if (!(forSquare in Ox88)) {\n        return []\n      } else {\n        firstSquare = lastSquare = Ox88[forSquare]\n        singleSquare = true\n      }\n    }\n\n    for (let from = firstSquare; from <= lastSquare; from++) {\n      // did we run off the end of the board\n      if (from & 0x88) {\n        from += 7\n        continue\n      }\n\n      // empty square or opponent, skip\n      if (!this._board[from] || this._board[from].color === them) {\n        continue\n      }\n      const { type } = this._board[from]\n\n      let to: number\n      if (type === PAWN) {\n        if (forPiece && forPiece !== type) continue\n\n        // single square, non-capturing\n        to = from + PAWN_OFFSETS[us][0]\n        if (!this._board[to]) {\n          addMove(moves, us, from, to, PAWN)\n\n          // double square\n          to = from + PAWN_OFFSETS[us][1]\n          if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n            addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN)\n          }\n        }\n\n        // pawn captures\n        for (let j = 2; j < 4; j++) {\n          to = from + PAWN_OFFSETS[us][j]\n          if (to & 0x88) continue\n\n          if (this._board[to]?.color === them) {\n            addMove(\n              moves,\n              us,\n              from,\n              to,\n              PAWN,\n              this._board[to].type,\n              BITS.CAPTURE,\n            )\n          } else if (to === this._epSquare) {\n            addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE)\n          }\n        }\n      } else {\n        if (forPiece && forPiece !== type) continue\n\n        for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n          const offset = PIECE_OFFSETS[type][j]\n          to = from\n\n          while (true) {\n            to += offset\n            if (to & 0x88) break\n\n            if (!this._board[to]) {\n              addMove(moves, us, from, to, type)\n            } else {\n              // own color, stop loop\n              if (this._board[to].color === us) break\n\n              addMove(\n                moves,\n                us,\n                from,\n                to,\n                type,\n                this._board[to].type,\n                BITS.CAPTURE,\n              )\n              break\n            }\n\n            /* break, if knight or king */\n            if (type === KNIGHT || type === KING) break\n          }\n        }\n      }\n    }\n\n    /*\n     * check for castling if we're:\n     *   a) generating all moves, or\n     *   b) doing single square move generation on the king's square\n     */\n\n    if (forPiece === undefined || forPiece === KING) {\n      if (!singleSquare || lastSquare === this._kings[us]) {\n        // king-side castling\n        if (this._castling[us] & BITS.KSIDE_CASTLE) {\n          const castlingFrom = this._kings[us]\n          const castlingTo = castlingFrom + 2\n\n          if (\n            !this._board[castlingFrom + 1] &&\n            !this._board[castlingTo] &&\n            !this._attacked(them, this._kings[us]) &&\n            !this._attacked(them, castlingFrom + 1) &&\n            !this._attacked(them, castlingTo)\n          ) {\n            addMove(\n              moves,\n              us,\n              this._kings[us],\n              castlingTo,\n              KING,\n              undefined,\n              BITS.KSIDE_CASTLE,\n            )\n          }\n        }\n\n        // queen-side castling\n        if (this._castling[us] & BITS.QSIDE_CASTLE) {\n          const castlingFrom = this._kings[us]\n          const castlingTo = castlingFrom - 2\n\n          if (\n            !this._board[castlingFrom - 1] &&\n            !this._board[castlingFrom - 2] &&\n            !this._board[castlingFrom - 3] &&\n            !this._attacked(them, this._kings[us]) &&\n            !this._attacked(them, castlingFrom - 1) &&\n            !this._attacked(them, castlingTo)\n          ) {\n            addMove(\n              moves,\n              us,\n              this._kings[us],\n              castlingTo,\n              KING,\n              undefined,\n              BITS.QSIDE_CASTLE,\n            )\n          }\n        }\n      }\n    }\n\n    /*\n     * return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal || this._kings[us] === -1) {\n      return moves\n    }\n\n    // filter out illegal moves\n    const legalMoves = []\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i])\n      if (!this._isKingAttacked(us)) {\n        legalMoves.push(moves[i])\n      }\n      this._undoMove()\n    }\n\n    return legalMoves\n  }\n\n  move(\n    move: string | { from: string; to: string; promotion?: string },\n    { strict = false }: { strict?: boolean } = {},\n  ): Move {\n    /*\n     * The move function can be called with in the following parameters:\n     *\n     * .move('Nxb7')       <- argument is a case-sensitive SAN string\n     *\n     * .move({ from: 'h7', <- argument is a move object\n     *         to :'h8',\n     *         promotion: 'q' })\n     *\n     *\n     * An optional strict argument may be supplied to tell chess.js to\n     * strictly follow the SAN specification.\n     */\n\n    let moveObj = null\n\n    if (typeof move === 'string') {\n      moveObj = this._moveFromSan(move, strict)\n    } else if (typeof move === 'object') {\n      const moves = this._moves()\n\n      // convert the pretty move object to an ugly move object\n      for (let i = 0, len = moves.length; i < len; i++) {\n        if (\n          move.from === algebraic(moves[i].from) &&\n          move.to === algebraic(moves[i].to) &&\n          (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)\n        ) {\n          moveObj = moves[i]\n          break\n        }\n      }\n    }\n\n    // failed to find move\n    if (!moveObj) {\n      if (typeof move === 'string') {\n        throw new Error(`Invalid move: ${move}`)\n      } else {\n        throw new Error(`Invalid move: ${JSON.stringify(move)}`)\n      }\n    }\n\n    /*\n     * need to make a copy of move because we can't generate SAN after the move\n     * is made\n     */\n    const prettyMove = new Move(this, moveObj)\n\n    this._makeMove(moveObj)\n    this._incPositionCount(prettyMove.after)\n    return prettyMove\n  }\n\n  private _push(move: InternalMove) {\n    this._history.push({\n      move,\n      kings: { b: this._kings.b, w: this._kings.w },\n      turn: this._turn,\n      castling: { b: this._castling.b, w: this._castling.w },\n      epSquare: this._epSquare,\n      halfMoves: this._halfMoves,\n      moveNumber: this._moveNumber,\n    })\n  }\n\n  private _makeMove(move: InternalMove) {\n    const us = this._turn\n    const them = swapColor(us)\n    this._push(move)\n\n    this._board[move.to] = this._board[move.from]\n    delete this._board[move.from]\n\n    // if ep capture, remove the captured pawn\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (this._turn === BLACK) {\n        delete this._board[move.to - 16]\n      } else {\n        delete this._board[move.to + 16]\n      }\n    }\n\n    // if pawn promotion, replace with new piece\n    if (move.promotion) {\n      this._board[move.to] = { type: move.promotion, color: us }\n    }\n\n    // if we moved the king\n    if (this._board[move.to].type === KING) {\n      this._kings[us] = move.to\n\n      // if we castled, move the rook next to the king\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        const castlingTo = move.to - 1\n        const castlingFrom = move.to + 1\n        this._board[castlingTo] = this._board[castlingFrom]\n        delete this._board[castlingFrom]\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        const castlingTo = move.to + 1\n        const castlingFrom = move.to - 2\n        this._board[castlingTo] = this._board[castlingFrom]\n        delete this._board[castlingFrom]\n      }\n\n      // turn off castling\n      this._castling[us] = 0\n    }\n\n    // turn off castling if we move a rook\n    if (this._castling[us]) {\n      for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (\n          move.from === ROOKS[us][i].square &&\n          this._castling[us] & ROOKS[us][i].flag\n        ) {\n          this._castling[us] ^= ROOKS[us][i].flag\n          break\n        }\n      }\n    }\n\n    // turn off castling if we capture a rook\n    if (this._castling[them]) {\n      for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (\n          move.to === ROOKS[them][i].square &&\n          this._castling[them] & ROOKS[them][i].flag\n        ) {\n          this._castling[them] ^= ROOKS[them][i].flag\n          break\n        }\n      }\n    }\n\n    // if big pawn move, update the en passant square\n    if (move.flags & BITS.BIG_PAWN) {\n      if (us === BLACK) {\n        this._epSquare = move.to - 16\n      } else {\n        this._epSquare = move.to + 16\n      }\n    } else {\n      this._epSquare = EMPTY\n    }\n\n    // reset the 50 move counter if a pawn is moved or a piece is captured\n    if (move.piece === PAWN) {\n      this._halfMoves = 0\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      this._halfMoves = 0\n    } else {\n      this._halfMoves++\n    }\n\n    if (us === BLACK) {\n      this._moveNumber++\n    }\n\n    this._turn = them\n  }\n\n  undo(): Move | null {\n    const move = this._undoMove()\n    if (move) {\n      const prettyMove = new Move(this, move)\n      this._decPositionCount(prettyMove.after)\n      return prettyMove\n    }\n    return null\n  }\n\n  private _undoMove(): InternalMove | null {\n    const old = this._history.pop()\n    if (old === undefined) {\n      return null\n    }\n\n    const move = old.move\n\n    this._kings = old.kings\n    this._turn = old.turn\n    this._castling = old.castling\n    this._epSquare = old.epSquare\n    this._halfMoves = old.halfMoves\n    this._moveNumber = old.moveNumber\n\n    const us = this._turn\n    const them = swapColor(us)\n\n    this._board[move.from] = this._board[move.to]\n    this._board[move.from].type = move.piece // to undo any promotions\n    delete this._board[move.to]\n\n    if (move.captured) {\n      if (move.flags & BITS.EP_CAPTURE) {\n        // en passant capture\n        let index: number\n        if (us === BLACK) {\n          index = move.to - 16\n        } else {\n          index = move.to + 16\n        }\n        this._board[index] = { type: PAWN, color: them }\n      } else {\n        // regular capture\n        this._board[move.to] = { type: move.captured, color: them }\n      }\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      let castlingTo: number, castlingFrom: number\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castlingTo = move.to + 1\n        castlingFrom = move.to - 1\n      } else {\n        castlingTo = move.to - 2\n        castlingFrom = move.to + 1\n      }\n\n      this._board[castlingTo] = this._board[castlingFrom]\n      delete this._board[castlingFrom]\n    }\n\n    return move\n  }\n\n  pgn({\n    newline = '\\n',\n    maxWidth = 0,\n  }: { newline?: string; maxWidth?: number } = {}): string {\n    /*\n     * using the specification from http://www.chessclub.com/help/PGN-spec\n     * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n     */\n\n    const result: string[] = []\n    let headerExists = false\n\n    /* add the PGN header information */\n    for (const i in this._header) {\n      /*\n       * TODO: order of enumerated properties in header object is not\n       * guaranteed, see ECMA-262 spec (section 12.6.4)\n       */\n      result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline)\n      headerExists = true\n    }\n\n    if (headerExists && this._history.length) {\n      result.push(newline)\n    }\n\n    const appendComment = (moveString: string) => {\n      const comment = this._comments[this.fen()]\n      if (typeof comment !== 'undefined') {\n        const delimiter = moveString.length > 0 ? ' ' : ''\n        moveString = `${moveString}${delimiter}{${comment}}`\n      }\n      return moveString\n    }\n\n    // pop all of history onto reversed_history\n    const reversedHistory = []\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    const moves = []\n    let moveString = ''\n\n    // special case of a commented starting position with no moves\n    if (reversedHistory.length === 0) {\n      moves.push(appendComment(''))\n    }\n\n    // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n    while (reversedHistory.length > 0) {\n      moveString = appendComment(moveString)\n      const move = reversedHistory.pop()\n\n      // make TypeScript stop complaining about move being undefined\n      if (!move) {\n        break\n      }\n\n      // if the position started with black to move, start PGN with #. ...\n      if (!this._history.length && move.color === 'b') {\n        const prefix = `${this._moveNumber}. ...`\n        // is there a comment preceding the first move?\n        moveString = moveString ? `${moveString} ${prefix}` : prefix\n      } else if (move.color === 'w') {\n        // store the previous generated move_string if we have one\n        if (moveString.length) {\n          moves.push(moveString)\n        }\n        moveString = this._moveNumber + '.'\n      }\n\n      moveString =\n        moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }))\n      this._makeMove(move)\n    }\n\n    // are there any other leftover moves?\n    if (moveString.length) {\n      moves.push(appendComment(moveString))\n    }\n\n    // is there a result?\n    if (typeof this._header.Result !== 'undefined') {\n      moves.push(this._header.Result)\n    }\n\n    /*\n     * history should be back to what it was before we started generating PGN,\n     * so join together moves\n     */\n    if (maxWidth === 0) {\n      return result.join('') + moves.join(' ')\n    }\n\n    // TODO (jah): huh?\n    const strip = function () {\n      if (result.length > 0 && result[result.length - 1] === ' ') {\n        result.pop()\n        return true\n      }\n      return false\n    }\n\n    // NB: this does not preserve comment whitespace.\n    const wrapComment = function (width: number, move: string) {\n      for (const token of move.split(' ')) {\n        if (!token) {\n          continue\n        }\n        if (width + token.length > maxWidth) {\n          while (strip()) {\n            width--\n          }\n          result.push(newline)\n          width = 0\n        }\n        result.push(token)\n        width += token.length\n        result.push(' ')\n        width++\n      }\n      if (strip()) {\n        width--\n      }\n      return width\n    }\n\n    // wrap the PGN output at max_width\n    let currentWidth = 0\n    for (let i = 0; i < moves.length; i++) {\n      if (currentWidth + moves[i].length > maxWidth) {\n        if (moves[i].includes('{')) {\n          currentWidth = wrapComment(currentWidth, moves[i])\n          continue\n        }\n      }\n      // if the current move will push past max_width\n      if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n        // don't end the line with whitespace\n        if (result[result.length - 1] === ' ') {\n          result.pop()\n        }\n\n        result.push(newline)\n        currentWidth = 0\n      } else if (i !== 0) {\n        result.push(' ')\n        currentWidth++\n      }\n      result.push(moves[i])\n      currentWidth += moves[i].length\n    }\n\n    return result.join('')\n  }\n\n  /*\n   * @deprecated Use `setHeader` and `getHeaders` instead.\n   */\n  header(...args: string[]): Record<string, string> {\n    for (let i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        this._header[args[i]] = args[i + 1]\n      }\n    }\n    return this._header\n  }\n\n  setHeader(key: string, value: string): Record<string, string> {\n    this._header[key] = value\n    return this._header\n  }\n\n  removeHeader(key: string): boolean {\n    if (key in this._header) {\n      delete this._header[key]\n      return true\n    }\n    return false\n  }\n\n  getHeaders(): Record<string, string> {\n    return this._header\n  }\n\n  loadPgn(\n    pgn: string,\n    {\n      strict = false,\n      newlineChar = '\\r?\\n',\n    }: { strict?: boolean; newlineChar?: string } = {},\n  ) {\n    function mask(str: string): string {\n      return str.replace(/\\\\/g, '\\\\')\n    }\n\n    function parsePgnHeader(header: string): { [key: string]: string } {\n      const headerObj: Record<string, string> = {}\n      const headers = header.split(new RegExp(mask(newlineChar)))\n      let key = ''\n      let value = ''\n\n      for (let i = 0; i < headers.length; i++) {\n        const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/\n        key = headers[i].replace(regex, '$1')\n        value = headers[i].replace(regex, '$2')\n        if (key.trim().length > 0) {\n          headerObj[key] = value\n        }\n      }\n\n      return headerObj\n    }\n\n    // strip whitespace from head/tail of PGN block\n    pgn = pgn.trim()\n\n    /*\n     * RegExp to split header. Takes advantage of the fact that header and movetext\n     * will always have a blank line between them (ie, two newline_char's). Handles\n     * case where movetext is empty by matching newlineChar until end of string is\n     * matched - effectively trimming from the end extra newlineChar.\n     *\n     * With default newline_char, will equal:\n     * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n     */\n    const headerRegex = new RegExp(\n      '^(\\\\[((?:' +\n        mask(newlineChar) +\n        ')|.)*\\\\])' +\n        '((?:\\\\s*' +\n        mask(newlineChar) +\n        '){2}|(?:\\\\s*' +\n        mask(newlineChar) +\n        ')*$)',\n    )\n\n    // If no header given, begin with moves.\n    const headerRegexResults = headerRegex.exec(pgn)\n    const headerString = headerRegexResults\n      ? headerRegexResults.length >= 2\n        ? headerRegexResults[1]\n        : ''\n      : ''\n\n    // Put the board in the starting position\n    this.reset()\n\n    // parse PGN header\n    const headers = parsePgnHeader(headerString)\n    let fen = ''\n\n    for (const key in headers) {\n      // check to see user is including fen (possibly with wrong tag case)\n      if (key.toLowerCase() === 'fen') {\n        fen = headers[key]\n      }\n\n      this.header(key, headers[key])\n    }\n\n    /*\n     * the permissive parser should attempt to load a fen tag, even if it's the\n     * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n     */\n    if (!strict) {\n      if (fen) {\n        this.load(fen, { preserveHeaders: true })\n      }\n    } else {\n      /*\n       * strict parser - load the starting position indicated by [Setup '1']\n       * and [FEN position]\n       */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers)) {\n          throw new Error(\n            'Invalid PGN: FEN tag must be supplied with SetUp tag',\n          )\n        }\n        // don't clear the headers when loading\n        this.load(headers['FEN'], { preserveHeaders: true })\n      }\n    }\n\n    /*\n     * NB: the regexes below that delete move numbers, recursive annotations,\n     * and numeric annotation glyphs may also match text in comments. To\n     * prevent this, we transform comments by hex-encoding them in place and\n     * decoding them again after the other tokens have been deleted.\n     *\n     * While the spec states that PGN files should be ASCII encoded, we use\n     * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n     * for modern users\n     */\n\n    function toHex(s: string): string {\n      return Array.from(s)\n        .map(function (c) {\n          /*\n           * encodeURI doesn't transform most ASCII characters, so we handle\n           * these ourselves\n           */\n          return c.charCodeAt(0) < 128\n            ? c.charCodeAt(0).toString(16)\n            : encodeURIComponent(c).replace(/%/g, '').toLowerCase()\n        })\n        .join('')\n    }\n\n    function fromHex(s: string): string {\n      return s.length == 0\n        ? ''\n        : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'))\n    }\n\n    const encodeComment = function (s: string): string {\n      s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ')\n      return `{${toHex(s.slice(1, s.length - 1))}}`\n    }\n\n    const decodeComment = function (s: string) {\n      if (s.startsWith('{') && s.endsWith('}')) {\n        return fromHex(s.slice(1, s.length - 1))\n      }\n    }\n\n    // delete header to get the moves\n    let ms = pgn\n      .replace(headerString, '')\n      .replace(\n        // encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'),\n        function (_match, bracket, semicolon) {\n          return bracket !== undefined\n            ? encodeComment(bracket)\n            : ' ' + encodeComment(`{${semicolon.slice(1)}}`)\n        },\n      )\n      .replace(new RegExp(mask(newlineChar), 'g'), ' ')\n\n    // delete recursive annotation variations\n    const ravRegex = /(\\([^()]+\\))+?/g\n    while (ravRegex.test(ms)) {\n      ms = ms.replace(ravRegex, '')\n    }\n\n    // delete move numbers\n    ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\n\n    // delete ... indicating black to move\n    ms = ms.replace(/\\.\\.\\./g, '')\n\n    /* delete numeric annotation glyphs */\n    ms = ms.replace(/\\$\\d+/g, '')\n\n    // trim and get array of moves\n    let moves = ms.trim().split(new RegExp(/\\s+/))\n\n    // delete empty entries\n    moves = moves.filter((move) => move !== '')\n\n    let result = ''\n\n    for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n      const comment = decodeComment(moves[halfMove])\n      if (comment !== undefined) {\n        this._comments[this.fen()] = comment\n        continue\n      }\n\n      const move = this._moveFromSan(moves[halfMove], strict)\n\n      // invalid move\n      if (move == null) {\n        // was the move an end of game marker\n        if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n          result = moves[halfMove]\n        } else {\n          throw new Error(`Invalid move in PGN: ${moves[halfMove]}`)\n        }\n      } else {\n        // reset the end of game marker if making a valid move\n        result = ''\n        this._makeMove(move)\n        this._incPositionCount(this.fen())\n      }\n    }\n\n    /*\n     * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n     * the termination marker. Only do this when headers are present, but the\n     * result tag is missing\n     */\n\n    if (result && Object.keys(this._header).length && !this._header['Result']) {\n      this.header('Result', result)\n    }\n  }\n\n  /*\n   * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} strict Use the strict SAN parser. It will throw errors\n   * on overly disambiguated moves (see below):\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n\n  private _moveToSan(move: InternalMove, moves: InternalMove[]): string {\n    let output = ''\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O'\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O'\n    } else {\n      if (move.piece !== PAWN) {\n        const disambiguator = getDisambiguator(move, moves)\n        output += move.piece.toUpperCase() + disambiguator\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0]\n        }\n        output += 'x'\n      }\n\n      output += algebraic(move.to)\n\n      if (move.promotion) {\n        output += '=' + move.promotion.toUpperCase()\n      }\n    }\n\n    this._makeMove(move)\n    if (this.isCheck()) {\n      if (this.isCheckmate()) {\n        output += '#'\n      } else {\n        output += '+'\n      }\n    }\n    this._undoMove()\n\n    return output\n  }\n\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  private _moveFromSan(move: string, strict = false): InternalMove | null {\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    const cleanMove = strippedSan(move)\n\n    let pieceType = inferPieceType(cleanMove)\n    let moves = this._moves({ legal: true, piece: pieceType })\n\n    // strict parser\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n        return moves[i]\n      }\n    }\n\n    // the strict parser failed\n    if (strict) {\n      return null\n    }\n\n    let piece = undefined\n    let matches = undefined\n    let from = undefined\n    let to = undefined\n    let promotion = undefined\n\n    /*\n     * The default permissive (non-strict) parser allows the user to parse\n     * non-standard chess notations. This parser is only run after the strict\n     * Standard Algebraic Notation (SAN) parser has failed.\n     *\n     * When running the permissive parser, we'll run a regex to grab the piece, the\n     * to/from square, and an optional promotion piece. This regex will\n     * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n     * f7f8q, b1c3\n     *\n     * NOTE: Some positions and moves may be ambiguous when using the permissive\n     * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n     * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n     * move). In these cases, the permissive parser will default to the most\n     * basic interpretation (which is b1c3 parsing to Nc3).\n     */\n\n    let overlyDisambiguated = false\n\n    matches = cleanMove.match(\n      /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/,\n      //     piece         from              to       promotion\n    )\n\n    if (matches) {\n      piece = matches[1]\n      from = matches[2] as Square\n      to = matches[3] as Square\n      promotion = matches[4]\n\n      if (from.length == 1) {\n        overlyDisambiguated = true\n      }\n    } else {\n      /*\n       * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n       * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n       * there is one legal knight move to e7). In this case, the value of\n       * 'from' variable will be a rank or file, not a square.\n       */\n\n      matches = cleanMove.match(\n        /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/,\n      )\n\n      if (matches) {\n        piece = matches[1]\n        from = matches[2] as Square\n        to = matches[3] as Square\n        promotion = matches[4]\n\n        if (from.length == 1) {\n          overlyDisambiguated = true\n        }\n      }\n    }\n\n    pieceType = inferPieceType(cleanMove)\n    moves = this._moves({\n      legal: true,\n      piece: piece ? (piece as PieceSymbol) : pieceType,\n    })\n\n    if (!to) {\n      return null\n    }\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (!from) {\n        // if there is no from square, it could be just 'x' missing from a capture\n        if (\n          cleanMove ===\n          strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')\n        ) {\n          return moves[i]\n        }\n        // hand-compare move properties with the results from our permissive regex\n      } else if (\n        (!piece || piece.toLowerCase() == moves[i].piece) &&\n        Ox88[from] == moves[i].from &&\n        Ox88[to] == moves[i].to &&\n        (!promotion || promotion.toLowerCase() == moves[i].promotion)\n      ) {\n        return moves[i]\n      } else if (overlyDisambiguated) {\n        /*\n         * SPECIAL CASE: we parsed a move string that may have an unneeded\n         * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n         */\n\n        const square = algebraic(moves[i].from)\n        if (\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\n          Ox88[to] == moves[i].to &&\n          (from == square[0] || from == square[1]) &&\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\n        ) {\n          return moves[i]\n        }\n      }\n    }\n\n    return null\n  }\n\n  ascii(): string {\n    let s = '   +------------------------+\\n'\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // display the rank\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |'\n      }\n\n      if (this._board[i]) {\n        const piece = this._board[i].type\n        const color = this._board[i].color\n        const symbol =\n          color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n        s += ' ' + symbol + ' '\n      } else {\n        s += ' . '\n      }\n\n      if ((i + 1) & 0x88) {\n        s += '|\\n'\n        i += 8\n      }\n    }\n    s += '   +------------------------+\\n'\n    s += '     a  b  c  d  e  f  g  h'\n\n    return s\n  }\n\n  perft(depth: number): number {\n    const moves = this._moves({ legal: false })\n    let nodes = 0\n    const color = this._turn\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i])\n      if (!this._isKingAttacked(color)) {\n        if (depth - 1 > 0) {\n          nodes += this.perft(depth - 1)\n        } else {\n          nodes++\n        }\n      }\n      this._undoMove()\n    }\n\n    return nodes\n  }\n\n  turn(): Color {\n    return this._turn\n  }\n\n  board(): ({ square: Square; type: PieceSymbol; color: Color } | null)[][] {\n    const output = []\n    let row = []\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i] == null) {\n        row.push(null)\n      } else {\n        row.push({\n          square: algebraic(i),\n          type: this._board[i].type,\n          color: this._board[i].color,\n        })\n      }\n      if ((i + 1) & 0x88) {\n        output.push(row)\n        row = []\n        i += 8\n      }\n    }\n\n    return output\n  }\n\n  squareColor(square: Square): 'light' | 'dark' | null {\n    if (square in Ox88) {\n      const sq = Ox88[square]\n      return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark'\n    }\n\n    return null\n  }\n\n  history(): string[]\n  history({ verbose }: { verbose: true }): Move[]\n  history({ verbose }: { verbose: false }): string[]\n  history({ verbose }: { verbose: boolean }): string[] | Move[]\n  history({ verbose = false }: { verbose?: boolean } = {}) {\n    const reversedHistory = []\n    const moveHistory = []\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    while (true) {\n      const move = reversedHistory.pop()\n      if (!move) {\n        break\n      }\n\n      if (verbose) {\n        moveHistory.push(new Move(this, move))\n      } else {\n        moveHistory.push(this._moveToSan(move, this._moves()))\n      }\n      this._makeMove(move)\n    }\n\n    return moveHistory\n  }\n\n  /*\n   * Keeps track of position occurrence counts for the purpose of repetition\n   * checking. All three methods (`_inc`, `_dec`, and `_get`) trim the\n   * irrelevent information from the fen, initialising new positions, and\n   * removing old positions from the record if their counts are reduced to 0.\n   */\n  private _getPositionCount(fen: string): number {\n    const trimmedFen = trimFen(fen)\n    return this._positionCount[trimmedFen] || 0\n  }\n\n  private _incPositionCount(fen: string) {\n    const trimmedFen = trimFen(fen)\n    if (this._positionCount[trimmedFen] === undefined) {\n      this._positionCount[trimmedFen] = 0\n    }\n    this._positionCount[trimmedFen] += 1\n  }\n\n  private _decPositionCount(fen: string) {\n    const trimmedFen = trimFen(fen)\n    if (this._positionCount[trimmedFen] === 1) {\n      delete this._positionCount[trimmedFen]\n    } else {\n      this._positionCount[trimmedFen] -= 1\n    }\n  }\n\n  private _pruneComments() {\n    const reversedHistory = []\n    const currentComments: Record<string, string> = {}\n\n    const copyComment = (fen: string) => {\n      if (fen in this._comments) {\n        currentComments[fen] = this._comments[fen]\n      }\n    }\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    copyComment(this.fen())\n\n    while (true) {\n      const move = reversedHistory.pop()\n      if (!move) {\n        break\n      }\n      this._makeMove(move)\n      copyComment(this.fen())\n    }\n    this._comments = currentComments\n  }\n\n  getComment(): string {\n    return this._comments[this.fen()]\n  }\n\n  setComment(comment: string) {\n    this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']')\n  }\n\n  /**\n   * @deprecated Renamed to `removeComment` for consistency\n   */\n  deleteComment(): string {\n    return this.removeComment()\n  }\n\n  removeComment(): string {\n    const comment = this._comments[this.fen()]\n    delete this._comments[this.fen()]\n    return comment\n  }\n\n  getComments(): { fen: string; comment: string }[] {\n    this._pruneComments()\n    return Object.keys(this._comments).map((fen: string) => {\n      return { fen: fen, comment: this._comments[fen] }\n    })\n  }\n\n  /**\n   * @deprecated Renamed to `removeComments` for consistency\n   */\n  deleteComments(): { fen: string; comment: string }[] {\n    return this.removeComments()\n  }\n\n  removeComments(): { fen: string; comment: string }[] {\n    this._pruneComments()\n    return Object.keys(this._comments).map((fen) => {\n      const comment = this._comments[fen]\n      delete this._comments[fen]\n      return { fen: fen, comment: comment }\n    })\n  }\n\n  setCastlingRights(\n    color: Color,\n    rights: Partial<Record<typeof KING | typeof QUEEN, boolean>>,\n  ): boolean {\n    for (const side of [KING, QUEEN] as const) {\n      if (rights[side] !== undefined) {\n        if (rights[side]) {\n          this._castling[color] |= SIDES[side]\n        } else {\n          this._castling[color] &= ~SIDES[side]\n        }\n      }\n    }\n\n    this._updateCastlingRights()\n    const result = this.getCastlingRights(color)\n\n    return (\n      (rights[KING] === undefined || rights[KING] === result[KING]) &&\n      (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN])\n    )\n  }\n\n  getCastlingRights(color: Color): { [KING]: boolean; [QUEEN]: boolean } {\n    return {\n      [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n      [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n    }\n  }\n\n  moveNumber(): number {\n    return this._moveNumber\n  }\n}\n","import { start } from './api.js';\nimport { configure } from './config.js';\nimport { defaults } from './state.js';\nimport { renderWrap } from './wrap.js';\nimport * as events from './events.js';\nimport { render, renderResized, updateBounds } from './render.js';\nimport * as autoPieces from './autoPieces.js';\nimport * as svg from './svg.js';\nimport * as util from './util.js';\nexport function initModule({ el, config }) {\n    return Chessground(el, config);\n}\nexport function Chessground(element, config) {\n    const maybeState = defaults();\n    configure(maybeState, config || {});\n    function redrawAll() {\n        const prevUnbind = 'dom' in maybeState ? maybeState.dom.unbind : undefined;\n        // compute bounds from existing board element if possible\n        // this allows non-square boards from CSS to be handled (for 3D)\n        const elements = renderWrap(element, maybeState), bounds = util.memo(() => elements.board.getBoundingClientRect()), redrawNow = (skipSvg) => {\n            render(state);\n            if (elements.autoPieces)\n                autoPieces.render(state, elements.autoPieces);\n            if (!skipSvg && elements.svg)\n                svg.renderSvg(state, elements.svg, elements.customSvg);\n        }, onResize = () => {\n            updateBounds(state);\n            renderResized(state);\n            if (elements.autoPieces)\n                autoPieces.renderResized(state);\n        };\n        const state = maybeState;\n        state.dom = {\n            elements,\n            bounds,\n            redraw: debounceRedraw(redrawNow),\n            redrawNow,\n            unbind: prevUnbind,\n        };\n        state.drawable.prevSvgHash = '';\n        updateBounds(state);\n        redrawNow(false);\n        events.bindBoard(state, onResize);\n        if (!prevUnbind)\n            state.dom.unbind = events.bindDocument(state, onResize);\n        state.events.insert && state.events.insert(elements);\n        return state;\n    }\n    return start(redrawAll(), redrawAll);\n}\nfunction debounceRedraw(redrawNow) {\n    let redrawing = false;\n    return () => {\n        if (redrawing)\n            return;\n        redrawing = true;\n        requestAnimationFrame(() => {\n            redrawNow();\n            redrawing = false;\n        });\n    };\n}\n//# sourceMappingURL=chessground.js.map","import { Api, start } from './api.js';\nimport { Config, configure } from './config.js';\nimport { HeadlessState, State, defaults } from './state.js';\n\nimport { renderWrap } from './wrap.js';\nimport * as events from './events.js';\nimport { render, renderResized, updateBounds } from './render.js';\nimport * as autoPieces from './autoPieces.js';\nimport * as svg from './svg.js';\nimport * as util from './util.js';\n\nexport function initModule({ el, config }: { el: HTMLElement; config?: Config }): Api {\n  return Chessground(el, config);\n}\n\nexport function Chessground(element: HTMLElement, config?: Config): Api {\n  const maybeState: State | HeadlessState = defaults();\n\n  configure(maybeState, config || {});\n\n  function redrawAll(): State {\n    const prevUnbind = 'dom' in maybeState ? maybeState.dom.unbind : undefined;\n    // compute bounds from existing board element if possible\n    // this allows non-square boards from CSS to be handled (for 3D)\n    const elements = renderWrap(element, maybeState),\n      bounds = util.memo(() => elements.board.getBoundingClientRect()),\n      redrawNow = (skipSvg?: boolean): void => {\n        render(state);\n        if (elements.autoPieces) autoPieces.render(state, elements.autoPieces);\n        if (!skipSvg && elements.svg) svg.renderSvg(state, elements.svg, elements.customSvg!);\n      },\n      onResize = (): void => {\n        updateBounds(state);\n        renderResized(state);\n        if (elements.autoPieces) autoPieces.renderResized(state);\n      };\n    const state = maybeState as State;\n    state.dom = {\n      elements,\n      bounds,\n      redraw: debounceRedraw(redrawNow),\n      redrawNow,\n      unbind: prevUnbind,\n    };\n    state.drawable.prevSvgHash = '';\n    updateBounds(state);\n    redrawNow(false);\n    events.bindBoard(state, onResize);\n    if (!prevUnbind) state.dom.unbind = events.bindDocument(state, onResize);\n    state.events.insert && state.events.insert(elements);\n    return state;\n  }\n\n  return start(redrawAll(), redrawAll);\n}\n\nfunction debounceRedraw(redrawNow: (skipSvg?: boolean) => void): () => void {\n  let redrawing = false;\n  return () => {\n    if (redrawing) return;\n    redrawing = true;\n    requestAnimationFrame(() => {\n      redrawNow();\n      redrawing = false;\n    });\n  };\n}\n","import * as board from './board.js';\nimport { write as fenWrite } from './fen.js';\nimport { configure, applyAnimation } from './config.js';\nimport { anim, render } from './anim.js';\nimport { cancel as dragCancel, dragNewPiece } from './drag.js';\nimport { explosion } from './explosion.js';\n// see API types and documentations in dts/api.d.ts\nexport function start(state, redrawAll) {\n    function toggleOrientation() {\n        board.toggleOrientation(state);\n        redrawAll();\n    }\n    return {\n        set(config) {\n            if (config.orientation && config.orientation !== state.orientation)\n                toggleOrientation();\n            applyAnimation(state, config);\n            (config.fen ? anim : render)(state => configure(state, config), state);\n        },\n        state,\n        getFen: () => fenWrite(state.pieces),\n        toggleOrientation,\n        setPieces(pieces) {\n            anim(state => board.setPieces(state, pieces), state);\n        },\n        selectSquare(key, force) {\n            if (key)\n                anim(state => board.selectSquare(state, key, force), state);\n            else if (state.selected) {\n                board.unselect(state);\n                state.dom.redraw();\n            }\n        },\n        move(orig, dest) {\n            anim(state => board.baseMove(state, orig, dest), state);\n        },\n        newPiece(piece, key) {\n            anim(state => board.baseNewPiece(state, piece, key), state);\n        },\n        playPremove() {\n            if (state.premovable.current) {\n                if (anim(board.playPremove, state))\n                    return true;\n                // if the premove couldn't be played, redraw to clear it up\n                state.dom.redraw();\n            }\n            return false;\n        },\n        playPredrop(validate) {\n            if (state.predroppable.current) {\n                const result = board.playPredrop(state, validate);\n                state.dom.redraw();\n                return result;\n            }\n            return false;\n        },\n        cancelPremove() {\n            render(board.unsetPremove, state);\n        },\n        cancelPredrop() {\n            render(board.unsetPredrop, state);\n        },\n        cancelMove() {\n            render(state => {\n                board.cancelMove(state);\n                dragCancel(state);\n            }, state);\n        },\n        stop() {\n            render(state => {\n                board.stop(state);\n                dragCancel(state);\n            }, state);\n        },\n        explode(keys) {\n            explosion(state, keys);\n        },\n        setAutoShapes(shapes) {\n            render(state => (state.drawable.autoShapes = shapes), state);\n        },\n        setShapes(shapes) {\n            render(state => (state.drawable.shapes = shapes), state);\n        },\n        getKeyAtDomPos(pos) {\n            return board.getKeyAtDomPos(pos, board.whitePov(state), state.dom.bounds());\n        },\n        redrawAll,\n        dragNewPiece(piece, event, force) {\n            dragNewPiece(state, piece, event, force);\n        },\n        destroy() {\n            board.stop(state);\n            state.dom.unbind && state.dom.unbind();\n            state.dom.destroyed = true;\n        },\n    };\n}\n//# sourceMappingURL=api.js.map","import { State } from './state.js';\nimport * as board from './board.js';\nimport { write as fenWrite } from './fen.js';\nimport { Config, configure, applyAnimation } from './config.js';\nimport { anim, render } from './anim.js';\nimport { cancel as dragCancel, dragNewPiece } from './drag.js';\nimport { DrawShape } from './draw.js';\nimport { explosion } from './explosion.js';\nimport * as cg from './types.js';\n\nexport interface Api {\n  // reconfigure the instance. Accepts all config options, except for viewOnly & drawable.visible.\n  // board will be animated accordingly, if animations are enabled.\n  set(config: Config): void;\n\n  // read chessground state; write at your own risks.\n  state: State;\n\n  // get the position as a FEN string (only contains pieces, no flags)\n  // e.g. rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR\n  getFen(): cg.FEN;\n\n  // change the view angle\n  toggleOrientation(): void;\n\n  // perform a move programmatically\n  move(orig: cg.Key, dest: cg.Key): void;\n\n  // add and/or remove arbitrary pieces on the board\n  setPieces(pieces: cg.PiecesDiff): void;\n\n  // click a square programmatically\n  selectSquare(key: cg.Key | null, force?: boolean): void;\n\n  // put a new piece on the board\n  newPiece(piece: cg.Piece, key: cg.Key): void;\n\n  // play the current premove, if any; returns true if premove was played\n  playPremove(): boolean;\n\n  // cancel the current premove, if any\n  cancelPremove(): void;\n\n  // play the current predrop, if any; returns true if premove was played\n  playPredrop(validate: (drop: cg.Drop) => boolean): boolean;\n\n  // cancel the current predrop, if any\n  cancelPredrop(): void;\n\n  // cancel the current move being made\n  cancelMove(): void;\n\n  // cancel current move and prevent further ones\n  stop(): void;\n\n  // make squares explode (atomic chess)\n  explode(keys: cg.Key[]): void;\n\n  // programmatically draw user shapes\n  setShapes(shapes: DrawShape[]): void;\n\n  // programmatically draw auto shapes\n  setAutoShapes(shapes: DrawShape[]): void;\n\n  // square name at this DOM position (like \"e4\")\n  getKeyAtDomPos(pos: cg.NumberPair): cg.Key | undefined;\n\n  // only useful when CSS changes the board width/height ratio (for 3D)\n  redrawAll: cg.Redraw;\n\n  // for crazyhouse and board editors\n  dragNewPiece(piece: cg.Piece, event: cg.MouchEvent, force?: boolean): void;\n\n  // unbinds all events\n  // (important for document-wide events like scroll and mousemove)\n  destroy: cg.Unbind;\n}\n\n// see API types and documentations in dts/api.d.ts\nexport function start(state: State, redrawAll: cg.Redraw): Api {\n  function toggleOrientation(): void {\n    board.toggleOrientation(state);\n    redrawAll();\n  }\n\n  return {\n    set(config): void {\n      if (config.orientation && config.orientation !== state.orientation) toggleOrientation();\n      applyAnimation(state, config);\n      (config.fen ? anim : render)(state => configure(state, config), state);\n    },\n\n    state,\n\n    getFen: () => fenWrite(state.pieces),\n\n    toggleOrientation,\n\n    setPieces(pieces): void {\n      anim(state => board.setPieces(state, pieces), state);\n    },\n\n    selectSquare(key, force): void {\n      if (key) anim(state => board.selectSquare(state, key, force), state);\n      else if (state.selected) {\n        board.unselect(state);\n        state.dom.redraw();\n      }\n    },\n\n    move(orig, dest): void {\n      anim(state => board.baseMove(state, orig, dest), state);\n    },\n\n    newPiece(piece, key): void {\n      anim(state => board.baseNewPiece(state, piece, key), state);\n    },\n\n    playPremove(): boolean {\n      if (state.premovable.current) {\n        if (anim(board.playPremove, state)) return true;\n        // if the premove couldn't be played, redraw to clear it up\n        state.dom.redraw();\n      }\n      return false;\n    },\n\n    playPredrop(validate): boolean {\n      if (state.predroppable.current) {\n        const result = board.playPredrop(state, validate);\n        state.dom.redraw();\n        return result;\n      }\n      return false;\n    },\n\n    cancelPremove(): void {\n      render(board.unsetPremove, state);\n    },\n\n    cancelPredrop(): void {\n      render(board.unsetPredrop, state);\n    },\n\n    cancelMove(): void {\n      render(state => {\n        board.cancelMove(state);\n        dragCancel(state);\n      }, state);\n    },\n\n    stop(): void {\n      render(state => {\n        board.stop(state);\n        dragCancel(state);\n      }, state);\n    },\n\n    explode(keys: cg.Key[]): void {\n      explosion(state, keys);\n    },\n\n    setAutoShapes(shapes: DrawShape[]): void {\n      render(state => (state.drawable.autoShapes = shapes), state);\n    },\n\n    setShapes(shapes: DrawShape[]): void {\n      render(state => (state.drawable.shapes = shapes), state);\n    },\n\n    getKeyAtDomPos(pos): cg.Key | undefined {\n      return board.getKeyAtDomPos(pos, board.whitePov(state), state.dom.bounds());\n    },\n\n    redrawAll,\n\n    dragNewPiece(piece, event, force): void {\n      dragNewPiece(state, piece, event, force);\n    },\n\n    destroy(): void {\n      board.stop(state);\n      state.dom.unbind && state.dom.unbind();\n      state.dom.destroyed = true;\n    },\n  };\n}\n","import { pos2key, key2pos, opposite, distanceSq, allPos, computeSquareCenter } from './util.js';\nimport { premove, queen, knight } from './premove.js';\nexport function callUserFunction(f, ...args) {\n    if (f)\n        setTimeout(() => f(...args), 1);\n}\nexport function toggleOrientation(state) {\n    state.orientation = opposite(state.orientation);\n    state.animation.current = state.draggable.current = state.selected = undefined;\n}\nexport function reset(state) {\n    state.lastMove = undefined;\n    unselect(state);\n    unsetPremove(state);\n    unsetPredrop(state);\n}\nexport function setPieces(state, pieces) {\n    for (const [key, piece] of pieces) {\n        if (piece)\n            state.pieces.set(key, piece);\n        else\n            state.pieces.delete(key);\n    }\n}\nexport function setCheck(state, color) {\n    state.check = undefined;\n    if (color === true)\n        color = state.turnColor;\n    if (color)\n        for (const [k, p] of state.pieces) {\n            if (p.role === 'king' && p.color === color) {\n                state.check = k;\n            }\n        }\n}\nfunction setPremove(state, orig, dest, meta) {\n    unsetPredrop(state);\n    state.premovable.current = [orig, dest];\n    callUserFunction(state.premovable.events.set, orig, dest, meta);\n}\nexport function unsetPremove(state) {\n    if (state.premovable.current) {\n        state.premovable.current = undefined;\n        callUserFunction(state.premovable.events.unset);\n    }\n}\nfunction setPredrop(state, role, key) {\n    unsetPremove(state);\n    state.predroppable.current = { role, key };\n    callUserFunction(state.predroppable.events.set, role, key);\n}\nexport function unsetPredrop(state) {\n    const pd = state.predroppable;\n    if (pd.current) {\n        pd.current = undefined;\n        callUserFunction(pd.events.unset);\n    }\n}\nfunction tryAutoCastle(state, orig, dest) {\n    if (!state.autoCastle)\n        return false;\n    const king = state.pieces.get(orig);\n    if (!king || king.role !== 'king')\n        return false;\n    const origPos = key2pos(orig);\n    const destPos = key2pos(dest);\n    if ((origPos[1] !== 0 && origPos[1] !== 7) || origPos[1] !== destPos[1])\n        return false;\n    if (origPos[0] === 4 && !state.pieces.has(dest)) {\n        if (destPos[0] === 6)\n            dest = pos2key([7, destPos[1]]);\n        else if (destPos[0] === 2)\n            dest = pos2key([0, destPos[1]]);\n    }\n    const rook = state.pieces.get(dest);\n    if (!rook || rook.color !== king.color || rook.role !== 'rook')\n        return false;\n    state.pieces.delete(orig);\n    state.pieces.delete(dest);\n    if (origPos[0] < destPos[0]) {\n        state.pieces.set(pos2key([6, destPos[1]]), king);\n        state.pieces.set(pos2key([5, destPos[1]]), rook);\n    }\n    else {\n        state.pieces.set(pos2key([2, destPos[1]]), king);\n        state.pieces.set(pos2key([3, destPos[1]]), rook);\n    }\n    return true;\n}\nexport function baseMove(state, orig, dest) {\n    const origPiece = state.pieces.get(orig), destPiece = state.pieces.get(dest);\n    if (orig === dest || !origPiece)\n        return false;\n    const captured = destPiece && destPiece.color !== origPiece.color ? destPiece : undefined;\n    if (dest === state.selected)\n        unselect(state);\n    callUserFunction(state.events.move, orig, dest, captured);\n    if (!tryAutoCastle(state, orig, dest)) {\n        state.pieces.set(dest, origPiece);\n        state.pieces.delete(orig);\n    }\n    state.lastMove = [orig, dest];\n    state.check = undefined;\n    callUserFunction(state.events.change);\n    return captured || true;\n}\nexport function baseNewPiece(state, piece, key, force) {\n    if (state.pieces.has(key)) {\n        if (force)\n            state.pieces.delete(key);\n        else\n            return false;\n    }\n    callUserFunction(state.events.dropNewPiece, piece, key);\n    state.pieces.set(key, piece);\n    state.lastMove = [key];\n    state.check = undefined;\n    callUserFunction(state.events.change);\n    state.movable.dests = undefined;\n    state.turnColor = opposite(state.turnColor);\n    return true;\n}\nfunction baseUserMove(state, orig, dest) {\n    const result = baseMove(state, orig, dest);\n    if (result) {\n        state.movable.dests = undefined;\n        state.turnColor = opposite(state.turnColor);\n        state.animation.current = undefined;\n    }\n    return result;\n}\nexport function userMove(state, orig, dest) {\n    if (canMove(state, orig, dest)) {\n        const result = baseUserMove(state, orig, dest);\n        if (result) {\n            const holdTime = state.hold.stop();\n            unselect(state);\n            const metadata = {\n                premove: false,\n                ctrlKey: state.stats.ctrlKey,\n                holdTime,\n            };\n            if (result !== true)\n                metadata.captured = result;\n            callUserFunction(state.movable.events.after, orig, dest, metadata);\n            return true;\n        }\n    }\n    else if (canPremove(state, orig, dest)) {\n        setPremove(state, orig, dest, {\n            ctrlKey: state.stats.ctrlKey,\n        });\n        unselect(state);\n        return true;\n    }\n    unselect(state);\n    return false;\n}\nexport function dropNewPiece(state, orig, dest, force) {\n    const piece = state.pieces.get(orig);\n    if (piece && (canDrop(state, orig, dest) || force)) {\n        state.pieces.delete(orig);\n        baseNewPiece(state, piece, dest, force);\n        callUserFunction(state.movable.events.afterNewPiece, piece.role, dest, {\n            premove: false,\n            predrop: false,\n        });\n    }\n    else if (piece && canPredrop(state, orig, dest)) {\n        setPredrop(state, piece.role, dest);\n    }\n    else {\n        unsetPremove(state);\n        unsetPredrop(state);\n    }\n    state.pieces.delete(orig);\n    unselect(state);\n}\nexport function selectSquare(state, key, force) {\n    callUserFunction(state.events.select, key);\n    if (state.selected) {\n        if (state.selected === key && !state.draggable.enabled) {\n            unselect(state);\n            state.hold.cancel();\n            return;\n        }\n        else if ((state.selectable.enabled || force) && state.selected !== key) {\n            if (userMove(state, state.selected, key)) {\n                state.stats.dragged = false;\n                return;\n            }\n        }\n    }\n    if ((state.selectable.enabled || state.draggable.enabled) &&\n        (isMovable(state, key) || isPremovable(state, key))) {\n        setSelected(state, key);\n        state.hold.start();\n    }\n}\nexport function setSelected(state, key) {\n    state.selected = key;\n    if (isPremovable(state, key)) {\n        // calculate chess premoves if custom premoves are not passed\n        if (!state.premovable.customDests) {\n            state.premovable.dests = premove(state.pieces, key, state.premovable.castle);\n        }\n    }\n    else\n        state.premovable.dests = undefined;\n}\nexport function unselect(state) {\n    state.selected = undefined;\n    state.premovable.dests = undefined;\n    state.hold.cancel();\n}\nfunction isMovable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return (!!piece &&\n        (state.movable.color === 'both' ||\n            (state.movable.color === piece.color && state.turnColor === piece.color)));\n}\nexport const canMove = (state, orig, dest) => {\n    var _a, _b;\n    return orig !== dest &&\n        isMovable(state, orig) &&\n        (state.movable.free || !!((_b = (_a = state.movable.dests) === null || _a === void 0 ? void 0 : _a.get(orig)) === null || _b === void 0 ? void 0 : _b.includes(dest)));\n};\nfunction canDrop(state, orig, dest) {\n    const piece = state.pieces.get(orig);\n    return (!!piece &&\n        (orig === dest || !state.pieces.has(dest)) &&\n        (state.movable.color === 'both' ||\n            (state.movable.color === piece.color && state.turnColor === piece.color)));\n}\nfunction isPremovable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return (!!piece &&\n        state.premovable.enabled &&\n        state.movable.color === piece.color &&\n        state.turnColor !== piece.color);\n}\nfunction canPremove(state, orig, dest) {\n    var _a, _b;\n    const validPremoves = (_b = (_a = state.premovable.customDests) === null || _a === void 0 ? void 0 : _a.get(orig)) !== null && _b !== void 0 ? _b : premove(state.pieces, orig, state.premovable.castle);\n    return orig !== dest && isPremovable(state, orig) && validPremoves.includes(dest);\n}\nfunction canPredrop(state, orig, dest) {\n    const piece = state.pieces.get(orig);\n    const destPiece = state.pieces.get(dest);\n    return (!!piece &&\n        (!destPiece || destPiece.color !== state.movable.color) &&\n        state.predroppable.enabled &&\n        (piece.role !== 'pawn' || (dest[1] !== '1' && dest[1] !== '8')) &&\n        state.movable.color === piece.color &&\n        state.turnColor !== piece.color);\n}\nexport function isDraggable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return (!!piece &&\n        state.draggable.enabled &&\n        (state.movable.color === 'both' ||\n            (state.movable.color === piece.color && (state.turnColor === piece.color || state.premovable.enabled))));\n}\nexport function playPremove(state) {\n    const move = state.premovable.current;\n    if (!move)\n        return false;\n    const orig = move[0], dest = move[1];\n    let success = false;\n    if (canMove(state, orig, dest)) {\n        const result = baseUserMove(state, orig, dest);\n        if (result) {\n            const metadata = { premove: true };\n            if (result !== true)\n                metadata.captured = result;\n            callUserFunction(state.movable.events.after, orig, dest, metadata);\n            success = true;\n        }\n    }\n    unsetPremove(state);\n    return success;\n}\nexport function playPredrop(state, validate) {\n    const drop = state.predroppable.current;\n    let success = false;\n    if (!drop)\n        return false;\n    if (validate(drop)) {\n        const piece = {\n            role: drop.role,\n            color: state.movable.color,\n        };\n        if (baseNewPiece(state, piece, drop.key)) {\n            callUserFunction(state.movable.events.afterNewPiece, drop.role, drop.key, {\n                premove: false,\n                predrop: true,\n            });\n            success = true;\n        }\n    }\n    unsetPredrop(state);\n    return success;\n}\nexport function cancelMove(state) {\n    unsetPremove(state);\n    unsetPredrop(state);\n    unselect(state);\n}\nexport function stop(state) {\n    state.movable.color = state.movable.dests = state.animation.current = undefined;\n    cancelMove(state);\n}\nexport function getKeyAtDomPos(pos, asWhite, bounds) {\n    let file = Math.floor((8 * (pos[0] - bounds.left)) / bounds.width);\n    if (!asWhite)\n        file = 7 - file;\n    let rank = 7 - Math.floor((8 * (pos[1] - bounds.top)) / bounds.height);\n    if (!asWhite)\n        rank = 7 - rank;\n    return file >= 0 && file < 8 && rank >= 0 && rank < 8 ? pos2key([file, rank]) : undefined;\n}\nexport function getSnappedKeyAtDomPos(orig, pos, asWhite, bounds) {\n    const origPos = key2pos(orig);\n    const validSnapPos = allPos.filter(pos2 => queen(origPos[0], origPos[1], pos2[0], pos2[1]) || knight(origPos[0], origPos[1], pos2[0], pos2[1]));\n    const validSnapCenters = validSnapPos.map(pos2 => computeSquareCenter(pos2key(pos2), asWhite, bounds));\n    const validSnapDistances = validSnapCenters.map(pos2 => distanceSq(pos, pos2));\n    const [, closestSnapIndex] = validSnapDistances.reduce((a, b, index) => (a[0] < b ? a : [b, index]), [validSnapDistances[0], 0]);\n    return pos2key(validSnapPos[closestSnapIndex]);\n}\nexport const whitePov = (s) => s.orientation === 'white';\n//# sourceMappingURL=board.js.map","import { HeadlessState } from './state.js';\nimport { pos2key, key2pos, opposite, distanceSq, allPos, computeSquareCenter } from './util.js';\nimport { premove, queen, knight } from './premove.js';\nimport * as cg from './types.js';\n\nexport function callUserFunction<T extends (...args: any[]) => void>(\n  f: T | undefined,\n  ...args: Parameters<T>\n): void {\n  if (f) setTimeout(() => f(...args), 1);\n}\n\nexport function toggleOrientation(state: HeadlessState): void {\n  state.orientation = opposite(state.orientation);\n  state.animation.current = state.draggable.current = state.selected = undefined;\n}\n\nexport function reset(state: HeadlessState): void {\n  state.lastMove = undefined;\n  unselect(state);\n  unsetPremove(state);\n  unsetPredrop(state);\n}\n\nexport function setPieces(state: HeadlessState, pieces: cg.PiecesDiff): void {\n  for (const [key, piece] of pieces) {\n    if (piece) state.pieces.set(key, piece);\n    else state.pieces.delete(key);\n  }\n}\n\nexport function setCheck(state: HeadlessState, color: cg.Color | boolean): void {\n  state.check = undefined;\n  if (color === true) color = state.turnColor;\n  if (color)\n    for (const [k, p] of state.pieces) {\n      if (p.role === 'king' && p.color === color) {\n        state.check = k;\n      }\n    }\n}\n\nfunction setPremove(state: HeadlessState, orig: cg.Key, dest: cg.Key, meta: cg.SetPremoveMetadata): void {\n  unsetPredrop(state);\n  state.premovable.current = [orig, dest];\n  callUserFunction(state.premovable.events.set, orig, dest, meta);\n}\n\nexport function unsetPremove(state: HeadlessState): void {\n  if (state.premovable.current) {\n    state.premovable.current = undefined;\n    callUserFunction(state.premovable.events.unset);\n  }\n}\n\nfunction setPredrop(state: HeadlessState, role: cg.Role, key: cg.Key): void {\n  unsetPremove(state);\n  state.predroppable.current = { role, key };\n  callUserFunction(state.predroppable.events.set, role, key);\n}\n\nexport function unsetPredrop(state: HeadlessState): void {\n  const pd = state.predroppable;\n  if (pd.current) {\n    pd.current = undefined;\n    callUserFunction(pd.events.unset);\n  }\n}\n\nfunction tryAutoCastle(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  if (!state.autoCastle) return false;\n\n  const king = state.pieces.get(orig);\n  if (!king || king.role !== 'king') return false;\n\n  const origPos = key2pos(orig);\n  const destPos = key2pos(dest);\n  if ((origPos[1] !== 0 && origPos[1] !== 7) || origPos[1] !== destPos[1]) return false;\n  if (origPos[0] === 4 && !state.pieces.has(dest)) {\n    if (destPos[0] === 6) dest = pos2key([7, destPos[1]]);\n    else if (destPos[0] === 2) dest = pos2key([0, destPos[1]]);\n  }\n  const rook = state.pieces.get(dest);\n  if (!rook || rook.color !== king.color || rook.role !== 'rook') return false;\n\n  state.pieces.delete(orig);\n  state.pieces.delete(dest);\n\n  if (origPos[0] < destPos[0]) {\n    state.pieces.set(pos2key([6, destPos[1]]), king);\n    state.pieces.set(pos2key([5, destPos[1]]), rook);\n  } else {\n    state.pieces.set(pos2key([2, destPos[1]]), king);\n    state.pieces.set(pos2key([3, destPos[1]]), rook);\n  }\n  return true;\n}\n\nexport function baseMove(state: HeadlessState, orig: cg.Key, dest: cg.Key): cg.Piece | boolean {\n  const origPiece = state.pieces.get(orig),\n    destPiece = state.pieces.get(dest);\n  if (orig === dest || !origPiece) return false;\n  const captured = destPiece && destPiece.color !== origPiece.color ? destPiece : undefined;\n  if (dest === state.selected) unselect(state);\n  callUserFunction(state.events.move, orig, dest, captured);\n  if (!tryAutoCastle(state, orig, dest)) {\n    state.pieces.set(dest, origPiece);\n    state.pieces.delete(orig);\n  }\n  state.lastMove = [orig, dest];\n  state.check = undefined;\n  callUserFunction(state.events.change);\n  return captured || true;\n}\n\nexport function baseNewPiece(state: HeadlessState, piece: cg.Piece, key: cg.Key, force?: boolean): boolean {\n  if (state.pieces.has(key)) {\n    if (force) state.pieces.delete(key);\n    else return false;\n  }\n  callUserFunction(state.events.dropNewPiece, piece, key);\n  state.pieces.set(key, piece);\n  state.lastMove = [key];\n  state.check = undefined;\n  callUserFunction(state.events.change);\n  state.movable.dests = undefined;\n  state.turnColor = opposite(state.turnColor);\n  return true;\n}\n\nfunction baseUserMove(state: HeadlessState, orig: cg.Key, dest: cg.Key): cg.Piece | boolean {\n  const result = baseMove(state, orig, dest);\n  if (result) {\n    state.movable.dests = undefined;\n    state.turnColor = opposite(state.turnColor);\n    state.animation.current = undefined;\n  }\n  return result;\n}\n\nexport function userMove(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  if (canMove(state, orig, dest)) {\n    const result = baseUserMove(state, orig, dest);\n    if (result) {\n      const holdTime = state.hold.stop();\n      unselect(state);\n      const metadata: cg.MoveMetadata = {\n        premove: false,\n        ctrlKey: state.stats.ctrlKey,\n        holdTime,\n      };\n      if (result !== true) metadata.captured = result;\n      callUserFunction(state.movable.events.after, orig, dest, metadata);\n      return true;\n    }\n  } else if (canPremove(state, orig, dest)) {\n    setPremove(state, orig, dest, {\n      ctrlKey: state.stats.ctrlKey,\n    });\n    unselect(state);\n    return true;\n  }\n  unselect(state);\n  return false;\n}\n\nexport function dropNewPiece(state: HeadlessState, orig: cg.Key, dest: cg.Key, force?: boolean): void {\n  const piece = state.pieces.get(orig);\n  if (piece && (canDrop(state, orig, dest) || force)) {\n    state.pieces.delete(orig);\n    baseNewPiece(state, piece, dest, force);\n    callUserFunction(state.movable.events.afterNewPiece, piece.role, dest, {\n      premove: false,\n      predrop: false,\n    });\n  } else if (piece && canPredrop(state, orig, dest)) {\n    setPredrop(state, piece.role, dest);\n  } else {\n    unsetPremove(state);\n    unsetPredrop(state);\n  }\n  state.pieces.delete(orig);\n  unselect(state);\n}\n\nexport function selectSquare(state: HeadlessState, key: cg.Key, force?: boolean): void {\n  callUserFunction(state.events.select, key);\n  if (state.selected) {\n    if (state.selected === key && !state.draggable.enabled) {\n      unselect(state);\n      state.hold.cancel();\n      return;\n    } else if ((state.selectable.enabled || force) && state.selected !== key) {\n      if (userMove(state, state.selected, key)) {\n        state.stats.dragged = false;\n        return;\n      }\n    }\n  }\n  if (\n    (state.selectable.enabled || state.draggable.enabled) &&\n    (isMovable(state, key) || isPremovable(state, key))\n  ) {\n    setSelected(state, key);\n    state.hold.start();\n  }\n}\n\nexport function setSelected(state: HeadlessState, key: cg.Key): void {\n  state.selected = key;\n  if (isPremovable(state, key)) {\n    // calculate chess premoves if custom premoves are not passed\n    if (!state.premovable.customDests) {\n      state.premovable.dests = premove(state.pieces, key, state.premovable.castle);\n    }\n  } else state.premovable.dests = undefined;\n}\n\nexport function unselect(state: HeadlessState): void {\n  state.selected = undefined;\n  state.premovable.dests = undefined;\n  state.hold.cancel();\n}\n\nfunction isMovable(state: HeadlessState, orig: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return (\n    !!piece &&\n    (state.movable.color === 'both' ||\n      (state.movable.color === piece.color && state.turnColor === piece.color))\n  );\n}\n\nexport const canMove = (state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean =>\n  orig !== dest &&\n  isMovable(state, orig) &&\n  (state.movable.free || !!state.movable.dests?.get(orig)?.includes(dest));\n\nfunction canDrop(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return (\n    !!piece &&\n    (orig === dest || !state.pieces.has(dest)) &&\n    (state.movable.color === 'both' ||\n      (state.movable.color === piece.color && state.turnColor === piece.color))\n  );\n}\n\nfunction isPremovable(state: HeadlessState, orig: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return (\n    !!piece &&\n    state.premovable.enabled &&\n    state.movable.color === piece.color &&\n    state.turnColor !== piece.color\n  );\n}\n\nfunction canPremove(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  const validPremoves: cg.Key[] =\n    state.premovable.customDests?.get(orig) ?? premove(state.pieces, orig, state.premovable.castle);\n  return orig !== dest && isPremovable(state, orig) && validPremoves.includes(dest);\n}\n\nfunction canPredrop(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  const destPiece = state.pieces.get(dest);\n  return (\n    !!piece &&\n    (!destPiece || destPiece.color !== state.movable.color) &&\n    state.predroppable.enabled &&\n    (piece.role !== 'pawn' || (dest[1] !== '1' && dest[1] !== '8')) &&\n    state.movable.color === piece.color &&\n    state.turnColor !== piece.color\n  );\n}\n\nexport function isDraggable(state: HeadlessState, orig: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return (\n    !!piece &&\n    state.draggable.enabled &&\n    (state.movable.color === 'both' ||\n      (state.movable.color === piece.color && (state.turnColor === piece.color || state.premovable.enabled)))\n  );\n}\n\nexport function playPremove(state: HeadlessState): boolean {\n  const move = state.premovable.current;\n  if (!move) return false;\n  const orig = move[0],\n    dest = move[1];\n  let success = false;\n  if (canMove(state, orig, dest)) {\n    const result = baseUserMove(state, orig, dest);\n    if (result) {\n      const metadata: cg.MoveMetadata = { premove: true };\n      if (result !== true) metadata.captured = result;\n      callUserFunction(state.movable.events.after, orig, dest, metadata);\n      success = true;\n    }\n  }\n  unsetPremove(state);\n  return success;\n}\n\nexport function playPredrop(state: HeadlessState, validate: (drop: cg.Drop) => boolean): boolean {\n  const drop = state.predroppable.current;\n  let success = false;\n  if (!drop) return false;\n  if (validate(drop)) {\n    const piece = {\n      role: drop.role,\n      color: state.movable.color,\n    } as cg.Piece;\n    if (baseNewPiece(state, piece, drop.key)) {\n      callUserFunction(state.movable.events.afterNewPiece, drop.role, drop.key, {\n        premove: false,\n        predrop: true,\n      });\n      success = true;\n    }\n  }\n  unsetPredrop(state);\n  return success;\n}\n\nexport function cancelMove(state: HeadlessState): void {\n  unsetPremove(state);\n  unsetPredrop(state);\n  unselect(state);\n}\n\nexport function stop(state: HeadlessState): void {\n  state.movable.color = state.movable.dests = state.animation.current = undefined;\n  cancelMove(state);\n}\n\nexport function getKeyAtDomPos(\n  pos: cg.NumberPair,\n  asWhite: boolean,\n  bounds: DOMRectReadOnly,\n): cg.Key | undefined {\n  let file = Math.floor((8 * (pos[0] - bounds.left)) / bounds.width);\n  if (!asWhite) file = 7 - file;\n  let rank = 7 - Math.floor((8 * (pos[1] - bounds.top)) / bounds.height);\n  if (!asWhite) rank = 7 - rank;\n  return file >= 0 && file < 8 && rank >= 0 && rank < 8 ? pos2key([file, rank]) : undefined;\n}\n\nexport function getSnappedKeyAtDomPos(\n  orig: cg.Key,\n  pos: cg.NumberPair,\n  asWhite: boolean,\n  bounds: DOMRectReadOnly,\n): cg.Key | undefined {\n  const origPos = key2pos(orig);\n  const validSnapPos = allPos.filter(\n    pos2 =>\n      queen(origPos[0], origPos[1], pos2[0], pos2[1]) || knight(origPos[0], origPos[1], pos2[0], pos2[1]),\n  );\n  const validSnapCenters = validSnapPos.map(pos2 => computeSquareCenter(pos2key(pos2), asWhite, bounds));\n  const validSnapDistances = validSnapCenters.map(pos2 => distanceSq(pos, pos2));\n  const [, closestSnapIndex] = validSnapDistances.reduce(\n    (a, b, index) => (a[0] < b ? a : [b, index]),\n    [validSnapDistances[0], 0],\n  );\n  return pos2key(validSnapPos[closestSnapIndex]);\n}\n\nexport const whitePov = (s: HeadlessState): boolean => s.orientation === 'white';\n","import * as cg from './types.js';\nexport const invRanks = [...cg.ranks].reverse();\nexport const allKeys = Array.prototype.concat(...cg.files.map(c => cg.ranks.map(r => c + r)));\nexport const pos2key = (pos) => allKeys[8 * pos[0] + pos[1]];\nexport const key2pos = (k) => [k.charCodeAt(0) - 97, k.charCodeAt(1) - 49];\nexport const uciToMove = (uci) => {\n    if (!uci)\n        return undefined;\n    if (uci[1] === '@')\n        return [uci.slice(2, 4)];\n    return [uci.slice(0, 2), uci.slice(2, 4)];\n};\nexport const allPos = allKeys.map(key2pos);\nexport function memo(f) {\n    let v;\n    const ret = () => {\n        if (v === undefined)\n            v = f();\n        return v;\n    };\n    ret.clear = () => {\n        v = undefined;\n    };\n    return ret;\n}\nexport const timer = () => {\n    let startAt;\n    return {\n        start() {\n            startAt = performance.now();\n        },\n        cancel() {\n            startAt = undefined;\n        },\n        stop() {\n            if (!startAt)\n                return 0;\n            const time = performance.now() - startAt;\n            startAt = undefined;\n            return time;\n        },\n    };\n};\nexport const opposite = (c) => (c === 'white' ? 'black' : 'white');\nexport const distanceSq = (pos1, pos2) => {\n    const dx = pos1[0] - pos2[0], dy = pos1[1] - pos2[1];\n    return dx * dx + dy * dy;\n};\nexport const samePiece = (p1, p2) => p1.role === p2.role && p1.color === p2.color;\nexport const posToTranslate = (bounds) => (pos, asWhite) => [\n    ((asWhite ? pos[0] : 7 - pos[0]) * bounds.width) / 8,\n    ((asWhite ? 7 - pos[1] : pos[1]) * bounds.height) / 8,\n];\nexport const translate = (el, pos) => {\n    el.style.transform = `translate(${pos[0]}px,${pos[1]}px)`;\n};\nexport const translateAndScale = (el, pos, scale = 1) => {\n    el.style.transform = `translate(${pos[0]}px,${pos[1]}px) scale(${scale})`;\n};\nexport const setVisible = (el, v) => {\n    el.style.visibility = v ? 'visible' : 'hidden';\n};\nexport const eventPosition = (e) => {\n    var _a;\n    if (e.clientX || e.clientX === 0)\n        return [e.clientX, e.clientY];\n    if ((_a = e.targetTouches) === null || _a === void 0 ? void 0 : _a[0])\n        return [e.targetTouches[0].clientX, e.targetTouches[0].clientY];\n    return; // touchend has no position!\n};\nexport const isRightButton = (e) => e.button === 2;\nexport const createEl = (tagName, className) => {\n    const el = document.createElement(tagName);\n    if (className)\n        el.className = className;\n    return el;\n};\nexport function computeSquareCenter(key, asWhite, bounds) {\n    const pos = key2pos(key);\n    if (!asWhite) {\n        pos[0] = 7 - pos[0];\n        pos[1] = 7 - pos[1];\n    }\n    return [\n        bounds.left + (bounds.width * pos[0]) / 8 + bounds.width / 16,\n        bounds.top + (bounds.height * (7 - pos[1])) / 8 + bounds.height / 16,\n    ];\n}\n//# sourceMappingURL=util.js.map","import * as cg from './types.js';\n\nexport const invRanks: readonly cg.Rank[] = [...cg.ranks].reverse();\n\nexport const allKeys: readonly cg.Key[] = Array.prototype.concat(\n  ...cg.files.map(c => cg.ranks.map(r => c + r)),\n);\n\nexport const pos2key = (pos: cg.Pos): cg.Key => allKeys[8 * pos[0] + pos[1]];\n\nexport const key2pos = (k: cg.Key): cg.Pos => [k.charCodeAt(0) - 97, k.charCodeAt(1) - 49];\n\nexport const uciToMove = (uci: string | undefined): cg.Key[] | undefined => {\n  if (!uci) return undefined;\n  if (uci[1] === '@') return [uci.slice(2, 4) as cg.Key];\n  return [uci.slice(0, 2), uci.slice(2, 4)] as cg.Key[];\n};\n\nexport const allPos: readonly cg.Pos[] = allKeys.map(key2pos);\n\nexport function memo<A>(f: () => A): cg.Memo<A> {\n  let v: A | undefined;\n  const ret = (): A => {\n    if (v === undefined) v = f();\n    return v;\n  };\n  ret.clear = () => {\n    v = undefined;\n  };\n  return ret;\n}\n\nexport const timer = (): cg.Timer => {\n  let startAt: number | undefined;\n  return {\n    start() {\n      startAt = performance.now();\n    },\n    cancel() {\n      startAt = undefined;\n    },\n    stop() {\n      if (!startAt) return 0;\n      const time = performance.now() - startAt;\n      startAt = undefined;\n      return time;\n    },\n  };\n};\n\nexport const opposite = (c: cg.Color): cg.Color => (c === 'white' ? 'black' : 'white');\n\nexport const distanceSq = (pos1: cg.Pos, pos2: cg.Pos): number => {\n  const dx = pos1[0] - pos2[0],\n    dy = pos1[1] - pos2[1];\n  return dx * dx + dy * dy;\n};\n\nexport const samePiece = (p1: cg.Piece, p2: cg.Piece): boolean =>\n  p1.role === p2.role && p1.color === p2.color;\n\nexport const posToTranslate =\n  (bounds: DOMRectReadOnly): ((pos: cg.Pos, asWhite: boolean) => cg.NumberPair) =>\n  (pos, asWhite) => [\n    ((asWhite ? pos[0] : 7 - pos[0]) * bounds.width) / 8,\n    ((asWhite ? 7 - pos[1] : pos[1]) * bounds.height) / 8,\n  ];\n\nexport const translate = (el: HTMLElement, pos: cg.NumberPair): void => {\n  el.style.transform = `translate(${pos[0]}px,${pos[1]}px)`;\n};\n\nexport const translateAndScale = (el: HTMLElement, pos: cg.NumberPair, scale = 1): void => {\n  el.style.transform = `translate(${pos[0]}px,${pos[1]}px) scale(${scale})`;\n};\n\nexport const setVisible = (el: HTMLElement, v: boolean): void => {\n  el.style.visibility = v ? 'visible' : 'hidden';\n};\n\nexport const eventPosition = (e: cg.MouchEvent): cg.NumberPair | undefined => {\n  if (e.clientX || e.clientX === 0) return [e.clientX, e.clientY!];\n  if (e.targetTouches?.[0]) return [e.targetTouches[0].clientX, e.targetTouches[0].clientY];\n  return; // touchend has no position!\n};\n\nexport const isRightButton = (e: cg.MouchEvent): boolean => e.button === 2;\n\nexport const createEl = (tagName: string, className?: string): HTMLElement => {\n  const el = document.createElement(tagName);\n  if (className) el.className = className;\n  return el;\n};\n\nexport function computeSquareCenter(key: cg.Key, asWhite: boolean, bounds: DOMRectReadOnly): cg.NumberPair {\n  const pos = key2pos(key);\n  if (!asWhite) {\n    pos[0] = 7 - pos[0];\n    pos[1] = 7 - pos[1];\n  }\n  return [\n    bounds.left + (bounds.width * pos[0]) / 8 + bounds.width / 16,\n    bounds.top + (bounds.height * (7 - pos[1])) / 8 + bounds.height / 16,\n  ];\n}\n","export const colors = ['white', 'black'];\nexport const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\nexport const ranks = ['1', '2', '3', '4', '5', '6', '7', '8'];\n//# sourceMappingURL=types.js.map","export type Color = (typeof colors)[number];\nexport type Role = 'king' | 'queen' | 'rook' | 'bishop' | 'knight' | 'pawn';\nexport type File = (typeof files)[number];\nexport type Rank = (typeof ranks)[number];\nexport type Key = 'a0' | `${File}${Rank}`;\nexport type FEN = string;\nexport type Pos = [number, number];\nexport interface Piece {\n  role: Role;\n  color: Color;\n  promoted?: boolean;\n}\nexport interface Drop {\n  role: Role;\n  key: Key;\n}\nexport type Pieces = Map<Key, Piece>;\nexport type PiecesDiff = Map<Key, Piece | undefined>;\n\nexport type KeyPair = [Key, Key];\n\nexport type NumberPair = [number, number];\n\nexport type NumberQuad = [number, number, number, number];\n\nexport interface Rect {\n  left: number;\n  top: number;\n  width: number;\n  height: number;\n}\n\nexport type Dests = Map<Key, Key[]>;\n\nexport interface Elements {\n  board: HTMLElement;\n  wrap: HTMLElement;\n  container: HTMLElement;\n  ghost?: HTMLElement;\n  svg?: SVGElement;\n  customSvg?: SVGElement;\n  autoPieces?: HTMLElement;\n}\nexport interface Dom {\n  elements: Elements;\n  bounds: Memo<DOMRectReadOnly>;\n  redraw: () => void;\n  redrawNow: (skipSvg?: boolean) => void;\n  unbind?: Unbind;\n  destroyed?: boolean;\n}\nexport interface Exploding {\n  stage: number;\n  keys: readonly Key[];\n}\n\nexport interface MoveMetadata {\n  premove: boolean;\n  ctrlKey?: boolean;\n  holdTime?: number;\n  captured?: Piece;\n  predrop?: boolean;\n}\nexport interface SetPremoveMetadata {\n  ctrlKey?: boolean;\n}\n\nexport type MouchEvent = Event & Partial<MouseEvent & TouchEvent>;\n\nexport interface KeyedNode extends HTMLElement {\n  cgKey: Key;\n}\nexport interface PieceNode extends KeyedNode {\n  tagName: 'PIECE';\n  cgPiece: string;\n  cgAnimating?: boolean;\n  cgFading?: boolean;\n  cgDragging?: boolean;\n  cgScale?: number;\n}\nexport interface SquareNode extends KeyedNode {\n  tagName: 'SQUARE';\n}\n\nexport interface Memo<A> {\n  (): A;\n  clear: () => void;\n}\n\nexport interface Timer {\n  start: () => void;\n  cancel: () => void;\n  stop: () => number;\n}\n\nexport type Redraw = () => void;\nexport type Unbind = () => void;\nexport type Milliseconds = number;\nexport type KHz = number;\n\nexport const colors = ['white', 'black'] as const;\nexport const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] as const;\nexport const ranks = ['1', '2', '3', '4', '5', '6', '7', '8'] as const;\n\nexport type RanksPosition = 'left' | 'right';\n\nexport type BrushColor = 'green' | 'red' | 'blue' | 'yellow';\n\nexport type SquareClasses = Map<Key, string>;\n","import * as util from './util.js';\nconst diff = (a, b) => Math.abs(a - b);\nconst pawn = (color) => (x1, y1, x2, y2) => diff(x1, x2) < 2 &&\n    (color === 'white'\n        ? // allow 2 squares from first two ranks, for horde\n            y2 === y1 + 1 || (y1 <= 1 && y2 === y1 + 2 && x1 === x2)\n        : y2 === y1 - 1 || (y1 >= 6 && y2 === y1 - 2 && x1 === x2));\nexport const knight = (x1, y1, x2, y2) => {\n    const xd = diff(x1, x2);\n    const yd = diff(y1, y2);\n    return (xd === 1 && yd === 2) || (xd === 2 && yd === 1);\n};\nconst bishop = (x1, y1, x2, y2) => {\n    return diff(x1, x2) === diff(y1, y2);\n};\nconst rook = (x1, y1, x2, y2) => {\n    return x1 === x2 || y1 === y2;\n};\nexport const queen = (x1, y1, x2, y2) => {\n    return bishop(x1, y1, x2, y2) || rook(x1, y1, x2, y2);\n};\nconst king = (color, rookFiles, canCastle) => (x1, y1, x2, y2) => (diff(x1, x2) < 2 && diff(y1, y2) < 2) ||\n    (canCastle &&\n        y1 === y2 &&\n        y1 === (color === 'white' ? 0 : 7) &&\n        ((x1 === 4 && ((x2 === 2 && rookFiles.includes(0)) || (x2 === 6 && rookFiles.includes(7)))) ||\n            rookFiles.includes(x2)));\nfunction rookFilesOf(pieces, color) {\n    const backrank = color === 'white' ? '1' : '8';\n    const files = [];\n    for (const [key, piece] of pieces) {\n        if (key[1] === backrank && piece.color === color && piece.role === 'rook') {\n            files.push(util.key2pos(key)[0]);\n        }\n    }\n    return files;\n}\nexport function premove(pieces, key, canCastle) {\n    const piece = pieces.get(key);\n    if (!piece)\n        return [];\n    const pos = util.key2pos(key), r = piece.role, mobility = r === 'pawn'\n        ? pawn(piece.color)\n        : r === 'knight'\n            ? knight\n            : r === 'bishop'\n                ? bishop\n                : r === 'rook'\n                    ? rook\n                    : r === 'queen'\n                        ? queen\n                        : king(piece.color, rookFilesOf(pieces, piece.color), canCastle);\n    return util.allPos\n        .filter(pos2 => (pos[0] !== pos2[0] || pos[1] !== pos2[1]) && mobility(pos[0], pos[1], pos2[0], pos2[1]))\n        .map(util.pos2key);\n}\n//# sourceMappingURL=premove.js.map","import * as util from './util.js';\nimport * as cg from './types.js';\n\ntype Mobility = (x1: number, y1: number, x2: number, y2: number) => boolean;\n\nconst diff = (a: number, b: number): number => Math.abs(a - b);\n\nconst pawn =\n  (color: cg.Color): Mobility =>\n  (x1, y1, x2, y2) =>\n    diff(x1, x2) < 2 &&\n    (color === 'white'\n      ? // allow 2 squares from first two ranks, for horde\n        y2 === y1 + 1 || (y1 <= 1 && y2 === y1 + 2 && x1 === x2)\n      : y2 === y1 - 1 || (y1 >= 6 && y2 === y1 - 2 && x1 === x2));\n\nexport const knight: Mobility = (x1, y1, x2, y2) => {\n  const xd = diff(x1, x2);\n  const yd = diff(y1, y2);\n  return (xd === 1 && yd === 2) || (xd === 2 && yd === 1);\n};\n\nconst bishop: Mobility = (x1, y1, x2, y2) => {\n  return diff(x1, x2) === diff(y1, y2);\n};\n\nconst rook: Mobility = (x1, y1, x2, y2) => {\n  return x1 === x2 || y1 === y2;\n};\n\nexport const queen: Mobility = (x1, y1, x2, y2) => {\n  return bishop(x1, y1, x2, y2) || rook(x1, y1, x2, y2);\n};\n\nconst king =\n  (color: cg.Color, rookFiles: number[], canCastle: boolean): Mobility =>\n  (x1, y1, x2, y2) =>\n    (diff(x1, x2) < 2 && diff(y1, y2) < 2) ||\n    (canCastle &&\n      y1 === y2 &&\n      y1 === (color === 'white' ? 0 : 7) &&\n      ((x1 === 4 && ((x2 === 2 && rookFiles.includes(0)) || (x2 === 6 && rookFiles.includes(7)))) ||\n        rookFiles.includes(x2)));\n\nfunction rookFilesOf(pieces: cg.Pieces, color: cg.Color) {\n  const backrank = color === 'white' ? '1' : '8';\n  const files = [];\n  for (const [key, piece] of pieces) {\n    if (key[1] === backrank && piece.color === color && piece.role === 'rook') {\n      files.push(util.key2pos(key)[0]);\n    }\n  }\n  return files;\n}\n\nexport function premove(pieces: cg.Pieces, key: cg.Key, canCastle: boolean): cg.Key[] {\n  const piece = pieces.get(key);\n  if (!piece) return [];\n  const pos = util.key2pos(key),\n    r = piece.role,\n    mobility: Mobility =\n      r === 'pawn'\n        ? pawn(piece.color)\n        : r === 'knight'\n          ? knight\n          : r === 'bishop'\n            ? bishop\n            : r === 'rook'\n              ? rook\n              : r === 'queen'\n                ? queen\n                : king(piece.color, rookFilesOf(pieces, piece.color), canCastle);\n  return util.allPos\n    .filter(pos2 => (pos[0] !== pos2[0] || pos[1] !== pos2[1]) && mobility(pos[0], pos[1], pos2[0], pos2[1]))\n    .map(util.pos2key);\n}\n","import { pos2key, invRanks } from './util.js';\nimport * as cg from './types.js';\nexport const initial = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\nconst roles = {\n    p: 'pawn',\n    r: 'rook',\n    n: 'knight',\n    b: 'bishop',\n    q: 'queen',\n    k: 'king',\n};\nconst letters = {\n    pawn: 'p',\n    rook: 'r',\n    knight: 'n',\n    bishop: 'b',\n    queen: 'q',\n    king: 'k',\n};\nexport function read(fen) {\n    if (fen === 'start')\n        fen = initial;\n    const pieces = new Map();\n    let row = 7, col = 0;\n    for (const c of fen) {\n        switch (c) {\n            case ' ':\n            case '[':\n                return pieces;\n            case '/':\n                --row;\n                if (row < 0)\n                    return pieces;\n                col = 0;\n                break;\n            case '~': {\n                const piece = pieces.get(pos2key([col - 1, row]));\n                if (piece)\n                    piece.promoted = true;\n                break;\n            }\n            default: {\n                const nb = c.charCodeAt(0);\n                if (nb < 57)\n                    col += nb - 48;\n                else {\n                    const role = c.toLowerCase();\n                    pieces.set(pos2key([col, row]), {\n                        role: roles[role],\n                        color: c === role ? 'black' : 'white',\n                    });\n                    ++col;\n                }\n            }\n        }\n    }\n    return pieces;\n}\nexport function write(pieces) {\n    return invRanks\n        .map(y => cg.files\n        .map(x => {\n        const piece = pieces.get((x + y));\n        if (piece) {\n            let p = letters[piece.role];\n            if (piece.color === 'white')\n                p = p.toUpperCase();\n            if (piece.promoted)\n                p += '~';\n            return p;\n        }\n        else\n            return '1';\n    })\n        .join(''))\n        .join('/')\n        .replace(/1{2,}/g, s => s.length.toString());\n}\n//# sourceMappingURL=fen.js.map","import { pos2key, invRanks } from './util.js';\nimport * as cg from './types.js';\n\nexport const initial: cg.FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\n\nconst roles: { [letter: string]: cg.Role } = {\n  p: 'pawn',\n  r: 'rook',\n  n: 'knight',\n  b: 'bishop',\n  q: 'queen',\n  k: 'king',\n};\n\nconst letters = {\n  pawn: 'p',\n  rook: 'r',\n  knight: 'n',\n  bishop: 'b',\n  queen: 'q',\n  king: 'k',\n};\n\nexport function read(fen: cg.FEN): cg.Pieces {\n  if (fen === 'start') fen = initial;\n  const pieces: cg.Pieces = new Map();\n  let row = 7,\n    col = 0;\n  for (const c of fen) {\n    switch (c) {\n      case ' ':\n      case '[':\n        return pieces;\n      case '/':\n        --row;\n        if (row < 0) return pieces;\n        col = 0;\n        break;\n      case '~': {\n        const piece = pieces.get(pos2key([col - 1, row]));\n        if (piece) piece.promoted = true;\n        break;\n      }\n      default: {\n        const nb = c.charCodeAt(0);\n        if (nb < 57) col += nb - 48;\n        else {\n          const role = c.toLowerCase();\n          pieces.set(pos2key([col, row]), {\n            role: roles[role],\n            color: c === role ? 'black' : 'white',\n          });\n          ++col;\n        }\n      }\n    }\n  }\n  return pieces;\n}\n\nexport function write(pieces: cg.Pieces): cg.FEN {\n  return invRanks\n    .map(y =>\n      cg.files\n        .map(x => {\n          const piece = pieces.get((x + y) as cg.Key);\n          if (piece) {\n            let p = letters[piece.role];\n            if (piece.color === 'white') p = p.toUpperCase();\n            if (piece.promoted) p += '~';\n            return p;\n          } else return '1';\n        })\n        .join(''),\n    )\n    .join('/')\n    .replace(/1{2,}/g, s => s.length.toString());\n}\n","import { setCheck, setSelected } from './board.js';\nimport { read as fenRead } from './fen.js';\nexport function applyAnimation(state, config) {\n    if (config.animation) {\n        deepMerge(state.animation, config.animation);\n        // no need for such short animations\n        if ((state.animation.duration || 0) < 70)\n            state.animation.enabled = false;\n    }\n}\nexport function configure(state, config) {\n    var _a, _b, _c;\n    // don't merge destinations and autoShapes. Just override.\n    if ((_a = config.movable) === null || _a === void 0 ? void 0 : _a.dests)\n        state.movable.dests = undefined;\n    if ((_b = config.drawable) === null || _b === void 0 ? void 0 : _b.autoShapes)\n        state.drawable.autoShapes = [];\n    deepMerge(state, config);\n    // if a fen was provided, replace the pieces\n    if (config.fen) {\n        state.pieces = fenRead(config.fen);\n        state.drawable.shapes = ((_c = config.drawable) === null || _c === void 0 ? void 0 : _c.shapes) || [];\n    }\n    // apply config values that could be undefined yet meaningful\n    if ('check' in config)\n        setCheck(state, config.check || false);\n    if ('lastMove' in config && !config.lastMove)\n        state.lastMove = undefined;\n    // in case of ZH drop last move, there's a single square.\n    // if the previous last move had two squares,\n    // the merge algorithm will incorrectly keep the second square.\n    else if (config.lastMove)\n        state.lastMove = config.lastMove;\n    // fix move/premove dests\n    if (state.selected)\n        setSelected(state, state.selected);\n    applyAnimation(state, config);\n    if (!state.movable.rookCastle && state.movable.dests) {\n        const rank = state.movable.color === 'white' ? '1' : '8', kingStartPos = ('e' + rank), dests = state.movable.dests.get(kingStartPos), king = state.pieces.get(kingStartPos);\n        if (!dests || !king || king.role !== 'king')\n            return;\n        state.movable.dests.set(kingStartPos, dests.filter(d => !(d === 'a' + rank && dests.includes(('c' + rank))) &&\n            !(d === 'h' + rank && dests.includes(('g' + rank)))));\n    }\n}\nfunction deepMerge(base, extend) {\n    for (const key in extend) {\n        if (Object.prototype.hasOwnProperty.call(extend, key)) {\n            if (Object.prototype.hasOwnProperty.call(base, key) &&\n                isPlainObject(base[key]) &&\n                isPlainObject(extend[key]))\n                deepMerge(base[key], extend[key]);\n            else\n                base[key] = extend[key];\n        }\n    }\n}\nfunction isPlainObject(o) {\n    if (typeof o !== 'object' || o === null)\n        return false;\n    const proto = Object.getPrototypeOf(o);\n    return proto === Object.prototype || proto === null;\n}\n//# sourceMappingURL=config.js.map","import { HeadlessState } from './state.js';\nimport { setCheck, setSelected } from './board.js';\nimport { read as fenRead } from './fen.js';\nimport { DrawShape, DrawBrushes } from './draw.js';\nimport * as cg from './types.js';\n\nexport interface Config {\n  fen?: cg.FEN; // chess position in Forsyth notation\n  orientation?: cg.Color; // board orientation. white | black\n  turnColor?: cg.Color; // turn to play. white | black\n  check?: cg.Color | boolean; // true for current color, false to unset\n  lastMove?: cg.Key[]; // squares part of the last move [\"c3\", \"c4\"]\n  selected?: cg.Key; // square currently selected \"a1\"\n  coordinates?: boolean; // include coords attributes\n  coordinatesOnSquares?: boolean; // include coords attributes on every square\n  autoCastle?: boolean; // immediately complete the castle by moving the rook after king move\n  viewOnly?: boolean; // don't bind events: the user will never be able to move pieces around\n  disableContextMenu?: boolean; // because who needs a context menu on a chessboard\n  addPieceZIndex?: boolean; // adds z-index values to pieces (for 3D)\n  addDimensionsCssVarsTo?: HTMLElement; // add ---cg-width and ---cg-height CSS vars containing the board's dimensions to this element\n  blockTouchScroll?: boolean; // block scrolling via touch dragging on the board, e.g. for coordinate training\n  // pieceKey: boolean; // add a data-key attribute to piece elements\n  trustAllEvents?: boolean; // disable checking for human only input (e.isTrusted)\n  highlight?: {\n    lastMove?: boolean; // add last-move class to squares\n    check?: boolean; // add check class to squares\n    custom?: cg.SquareClasses; // add custom classes to custom squares\n  };\n  animation?: {\n    enabled?: boolean;\n    duration?: number;\n  };\n  movable?: {\n    free?: boolean; // all moves are valid - board editor\n    color?: cg.Color | 'both'; // color that can move. white | black | both | undefined\n    dests?: cg.Dests; // valid moves. {\"a2\" [\"a3\" \"a4\"] \"b1\" [\"a3\" \"c3\"]}\n    showDests?: boolean; // whether to add the move-dest class on squares\n    events?: {\n      after?: (orig: cg.Key, dest: cg.Key, metadata: cg.MoveMetadata) => void; // called after the move has been played\n      afterNewPiece?: (role: cg.Role, key: cg.Key, metadata: cg.MoveMetadata) => void; // called after a new piece is dropped on the board\n    };\n    rookCastle?: boolean; // castle by moving the king to the rook\n  };\n  premovable?: {\n    enabled?: boolean; // allow premoves for color that can not move\n    showDests?: boolean; // whether to add the premove-dest class on squares\n    castle?: boolean; // whether to allow king castle premoves\n    dests?: cg.Key[]; // premove destinations for the current selection\n    customDests?: cg.Dests; // use custom valid premoves. {\"a2\" [\"a3\" \"a4\"] \"b1\" [\"a3\" \"c3\"]}\n    events?: {\n      set?: (orig: cg.Key, dest: cg.Key, metadata?: cg.SetPremoveMetadata) => void; // called after the premove has been set\n      unset?: () => void; // called after the premove has been unset\n    };\n  };\n  predroppable?: {\n    enabled?: boolean; // allow predrops for color that can not move\n    events?: {\n      set?: (role: cg.Role, key: cg.Key) => void; // called after the predrop has been set\n      unset?: () => void; // called after the predrop has been unset\n    };\n  };\n  draggable?: {\n    enabled?: boolean; // allow moves & premoves to use drag'n drop\n    distance?: number; // minimum distance to initiate a drag; in pixels\n    autoDistance?: boolean; // lets chessground set distance to zero when user drags pieces\n    showGhost?: boolean; // show ghost of piece being dragged\n    deleteOnDropOff?: boolean; // delete a piece when it is dropped off the board\n  };\n  selectable?: {\n    // disable to enforce dragging over click-click move\n    enabled?: boolean;\n  };\n  events?: {\n    change?: () => void; // called after the situation changes on the board\n    // called after a piece has been moved.\n    // capturedPiece is undefined or like {color: 'white'; 'role': 'queen'}\n    move?: (orig: cg.Key, dest: cg.Key, capturedPiece?: cg.Piece) => void;\n    dropNewPiece?: (piece: cg.Piece, key: cg.Key) => void;\n    select?: (key: cg.Key) => void; // called when a square is selected\n    insert?: (elements: cg.Elements) => void; // when the board DOM has been (re)inserted\n  };\n  drawable?: {\n    enabled?: boolean; // can draw\n    visible?: boolean; // can view\n    defaultSnapToValidMove?: boolean;\n    // false to keep the drawing if a movable piece is clicked.\n    // Clicking an empty square or immovable piece will clear the drawing regardless.\n    eraseOnClick?: boolean;\n    shapes?: DrawShape[];\n    autoShapes?: DrawShape[];\n    brushes?: DrawBrushes;\n    onChange?: (shapes: DrawShape[]) => void; // called after drawable shapes change\n  };\n}\n\nexport function applyAnimation(state: HeadlessState, config: Config): void {\n  if (config.animation) {\n    deepMerge(state.animation, config.animation);\n    // no need for such short animations\n    if ((state.animation.duration || 0) < 70) state.animation.enabled = false;\n  }\n}\n\nexport function configure(state: HeadlessState, config: Config): void {\n  // don't merge destinations and autoShapes. Just override.\n  if (config.movable?.dests) state.movable.dests = undefined;\n  if (config.drawable?.autoShapes) state.drawable.autoShapes = [];\n\n  deepMerge(state, config);\n\n  // if a fen was provided, replace the pieces\n  if (config.fen) {\n    state.pieces = fenRead(config.fen);\n    state.drawable.shapes = config.drawable?.shapes || [];\n  }\n\n  // apply config values that could be undefined yet meaningful\n  if ('check' in config) setCheck(state, config.check || false);\n  if ('lastMove' in config && !config.lastMove) state.lastMove = undefined;\n  // in case of ZH drop last move, there's a single square.\n  // if the previous last move had two squares,\n  // the merge algorithm will incorrectly keep the second square.\n  else if (config.lastMove) state.lastMove = config.lastMove;\n\n  // fix move/premove dests\n  if (state.selected) setSelected(state, state.selected);\n\n  applyAnimation(state, config);\n\n  if (!state.movable.rookCastle && state.movable.dests) {\n    const rank = state.movable.color === 'white' ? '1' : '8',\n      kingStartPos = ('e' + rank) as cg.Key,\n      dests = state.movable.dests.get(kingStartPos),\n      king = state.pieces.get(kingStartPos);\n    if (!dests || !king || king.role !== 'king') return;\n    state.movable.dests.set(\n      kingStartPos,\n      dests.filter(\n        d =>\n          !(d === 'a' + rank && dests.includes(('c' + rank) as cg.Key)) &&\n          !(d === 'h' + rank && dests.includes(('g' + rank) as cg.Key)),\n      ),\n    );\n  }\n}\n\nfunction deepMerge(base: any, extend: any): void {\n  for (const key in extend) {\n    if (Object.prototype.hasOwnProperty.call(extend, key)) {\n      if (\n        Object.prototype.hasOwnProperty.call(base, key) &&\n        isPlainObject(base[key]) &&\n        isPlainObject(extend[key])\n      )\n        deepMerge(base[key], extend[key]);\n      else base[key] = extend[key];\n    }\n  }\n}\n\nfunction isPlainObject(o: unknown): boolean {\n  if (typeof o !== 'object' || o === null) return false;\n  const proto = Object.getPrototypeOf(o);\n  return proto === Object.prototype || proto === null;\n}\n","import * as util from './util.js';\nexport const anim = (mutation, state) => state.animation.enabled ? animate(mutation, state) : render(mutation, state);\nexport function render(mutation, state) {\n    const result = mutation(state);\n    state.dom.redraw();\n    return result;\n}\nconst makePiece = (key, piece) => ({\n    key: key,\n    pos: util.key2pos(key),\n    piece: piece,\n});\nconst closer = (piece, pieces) => pieces.sort((p1, p2) => util.distanceSq(piece.pos, p1.pos) - util.distanceSq(piece.pos, p2.pos))[0];\nfunction computePlan(prevPieces, current) {\n    const anims = new Map(), animedOrigs = [], fadings = new Map(), missings = [], news = [], prePieces = new Map();\n    let curP, preP, vector;\n    for (const [k, p] of prevPieces) {\n        prePieces.set(k, makePiece(k, p));\n    }\n    for (const key of util.allKeys) {\n        curP = current.pieces.get(key);\n        preP = prePieces.get(key);\n        if (curP) {\n            if (preP) {\n                if (!util.samePiece(curP, preP.piece)) {\n                    missings.push(preP);\n                    news.push(makePiece(key, curP));\n                }\n            }\n            else\n                news.push(makePiece(key, curP));\n        }\n        else if (preP)\n            missings.push(preP);\n    }\n    for (const newP of news) {\n        preP = closer(newP, missings.filter(p => util.samePiece(newP.piece, p.piece)));\n        if (preP) {\n            vector = [preP.pos[0] - newP.pos[0], preP.pos[1] - newP.pos[1]];\n            anims.set(newP.key, vector.concat(vector));\n            animedOrigs.push(preP.key);\n        }\n    }\n    for (const p of missings) {\n        if (!animedOrigs.includes(p.key))\n            fadings.set(p.key, p.piece);\n    }\n    return {\n        anims: anims,\n        fadings: fadings,\n    };\n}\nfunction step(state, now) {\n    const cur = state.animation.current;\n    if (cur === undefined) {\n        // animation was canceled :(\n        if (!state.dom.destroyed)\n            state.dom.redrawNow();\n        return;\n    }\n    const rest = 1 - (now - cur.start) * cur.frequency;\n    if (rest <= 0) {\n        state.animation.current = undefined;\n        state.dom.redrawNow();\n    }\n    else {\n        const ease = easing(rest);\n        for (const cfg of cur.plan.anims.values()) {\n            cfg[2] = cfg[0] * ease;\n            cfg[3] = cfg[1] * ease;\n        }\n        state.dom.redrawNow(true); // optimisation: don't render SVG changes during animations\n        requestAnimationFrame((now = performance.now()) => step(state, now));\n    }\n}\nfunction animate(mutation, state) {\n    // clone state before mutating it\n    const prevPieces = new Map(state.pieces);\n    const result = mutation(state);\n    const plan = computePlan(prevPieces, state);\n    if (plan.anims.size || plan.fadings.size) {\n        const alreadyRunning = state.animation.current && state.animation.current.start;\n        state.animation.current = {\n            start: performance.now(),\n            frequency: 1 / state.animation.duration,\n            plan: plan,\n        };\n        if (!alreadyRunning)\n            step(state, performance.now());\n    }\n    else {\n        // don't animate, just render right away\n        state.dom.redraw();\n    }\n    return result;\n}\n// https://gist.github.com/gre/1650294\nconst easing = (t) => (t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1);\n//# sourceMappingURL=anim.js.map","import { State } from './state.js';\nimport * as util from './util.js';\nimport * as cg from './types.js';\n\nexport type Mutation<A> = (state: State) => A;\n\n// 0,1 animation goal\n// 2,3 animation current status\nexport type AnimVector = cg.NumberQuad;\n\nexport type AnimVectors = Map<cg.Key, AnimVector>;\n\nexport type AnimFadings = Map<cg.Key, cg.Piece>;\n\nexport interface AnimPlan {\n  anims: AnimVectors;\n  fadings: AnimFadings;\n}\n\nexport interface AnimCurrent {\n  start: DOMHighResTimeStamp;\n  frequency: cg.KHz;\n  plan: AnimPlan;\n}\n\nexport const anim = <A>(mutation: Mutation<A>, state: State): A =>\n  state.animation.enabled ? animate(mutation, state) : render(mutation, state);\n\nexport function render<A>(mutation: Mutation<A>, state: State): A {\n  const result = mutation(state);\n  state.dom.redraw();\n  return result;\n}\n\ninterface AnimPiece {\n  key: cg.Key;\n  pos: cg.Pos;\n  piece: cg.Piece;\n}\ntype AnimPieces = Map<cg.Key, AnimPiece>;\n\nconst makePiece = (key: cg.Key, piece: cg.Piece): AnimPiece => ({\n  key: key,\n  pos: util.key2pos(key),\n  piece: piece,\n});\n\nconst closer = (piece: AnimPiece, pieces: AnimPiece[]): AnimPiece | undefined =>\n  pieces.sort((p1, p2) => util.distanceSq(piece.pos, p1.pos) - util.distanceSq(piece.pos, p2.pos))[0];\n\nfunction computePlan(prevPieces: cg.Pieces, current: State): AnimPlan {\n  const anims: AnimVectors = new Map(),\n    animedOrigs: cg.Key[] = [],\n    fadings: AnimFadings = new Map(),\n    missings: AnimPiece[] = [],\n    news: AnimPiece[] = [],\n    prePieces: AnimPieces = new Map();\n  let curP: cg.Piece | undefined, preP: AnimPiece | undefined, vector: cg.NumberPair;\n  for (const [k, p] of prevPieces) {\n    prePieces.set(k, makePiece(k, p));\n  }\n  for (const key of util.allKeys) {\n    curP = current.pieces.get(key);\n    preP = prePieces.get(key);\n    if (curP) {\n      if (preP) {\n        if (!util.samePiece(curP, preP.piece)) {\n          missings.push(preP);\n          news.push(makePiece(key, curP));\n        }\n      } else news.push(makePiece(key, curP));\n    } else if (preP) missings.push(preP);\n  }\n  for (const newP of news) {\n    preP = closer(\n      newP,\n      missings.filter(p => util.samePiece(newP.piece, p.piece)),\n    );\n    if (preP) {\n      vector = [preP.pos[0] - newP.pos[0], preP.pos[1] - newP.pos[1]];\n      anims.set(newP.key, vector.concat(vector) as AnimVector);\n      animedOrigs.push(preP.key);\n    }\n  }\n  for (const p of missings) {\n    if (!animedOrigs.includes(p.key)) fadings.set(p.key, p.piece);\n  }\n\n  return {\n    anims: anims,\n    fadings: fadings,\n  };\n}\n\nfunction step(state: State, now: DOMHighResTimeStamp): void {\n  const cur = state.animation.current;\n  if (cur === undefined) {\n    // animation was canceled :(\n    if (!state.dom.destroyed) state.dom.redrawNow();\n    return;\n  }\n  const rest = 1 - (now - cur.start) * cur.frequency;\n  if (rest <= 0) {\n    state.animation.current = undefined;\n    state.dom.redrawNow();\n  } else {\n    const ease = easing(rest);\n    for (const cfg of cur.plan.anims.values()) {\n      cfg[2] = cfg[0] * ease;\n      cfg[3] = cfg[1] * ease;\n    }\n    state.dom.redrawNow(true); // optimisation: don't render SVG changes during animations\n    requestAnimationFrame((now = performance.now()) => step(state, now));\n  }\n}\n\nfunction animate<A>(mutation: Mutation<A>, state: State): A {\n  // clone state before mutating it\n  const prevPieces: cg.Pieces = new Map(state.pieces);\n\n  const result = mutation(state);\n  const plan = computePlan(prevPieces, state);\n  if (plan.anims.size || plan.fadings.size) {\n    const alreadyRunning = state.animation.current && state.animation.current.start;\n    state.animation.current = {\n      start: performance.now(),\n      frequency: 1 / state.animation.duration,\n      plan: plan,\n    };\n    if (!alreadyRunning) step(state, performance.now());\n  } else {\n    // don't animate, just render right away\n    state.dom.redraw();\n  }\n  return result;\n}\n\n// https://gist.github.com/gre/1650294\nconst easing = (t: number): number => (t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1);\n","import * as board from './board.js';\nimport * as util from './util.js';\nimport { clear as drawClear } from './draw.js';\nimport { anim } from './anim.js';\nexport function start(s, e) {\n    if (!(s.trustAllEvents || e.isTrusted))\n        return; // only trust when trustAllEvents is enabled\n    if (e.buttons !== undefined && e.buttons > 1)\n        return; // only touch or left click\n    if (e.touches && e.touches.length > 1)\n        return; // support one finger touch only\n    const bounds = s.dom.bounds(), position = util.eventPosition(e), orig = board.getKeyAtDomPos(position, board.whitePov(s), bounds);\n    if (!orig)\n        return;\n    const piece = s.pieces.get(orig);\n    const previouslySelected = s.selected;\n    if (!previouslySelected &&\n        s.drawable.enabled &&\n        (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor))\n        drawClear(s);\n    // Prevent touch scroll and create no corresponding mouse event, if there\n    // is an intent to interact with the board.\n    if (e.cancelable !== false &&\n        (!e.touches || s.blockTouchScroll || piece || previouslySelected || pieceCloseTo(s, position)))\n        e.preventDefault();\n    else if (e.touches)\n        return; // Handle only corresponding mouse event https://github.com/lichess-org/chessground/pull/268\n    const hadPremove = !!s.premovable.current;\n    const hadPredrop = !!s.predroppable.current;\n    s.stats.ctrlKey = e.ctrlKey;\n    if (s.selected && board.canMove(s, s.selected, orig)) {\n        anim(state => board.selectSquare(state, orig), s);\n    }\n    else {\n        board.selectSquare(s, orig);\n    }\n    const stillSelected = s.selected === orig;\n    const element = pieceElementByKey(s, orig);\n    if (piece && element && stillSelected && board.isDraggable(s, orig)) {\n        s.draggable.current = {\n            orig,\n            piece,\n            origPos: position,\n            pos: position,\n            started: s.draggable.autoDistance && s.stats.dragged,\n            element,\n            previouslySelected,\n            originTarget: e.target,\n            keyHasChanged: false,\n        };\n        element.cgDragging = true;\n        element.classList.add('dragging');\n        // place ghost\n        const ghost = s.dom.elements.ghost;\n        if (ghost) {\n            ghost.className = `ghost ${piece.color} ${piece.role}`;\n            util.translate(ghost, util.posToTranslate(bounds)(util.key2pos(orig), board.whitePov(s)));\n            util.setVisible(ghost, true);\n        }\n        processDrag(s);\n    }\n    else {\n        if (hadPremove)\n            board.unsetPremove(s);\n        if (hadPredrop)\n            board.unsetPredrop(s);\n    }\n    s.dom.redraw();\n}\nfunction pieceCloseTo(s, pos) {\n    const asWhite = board.whitePov(s), bounds = s.dom.bounds(), radiusSq = Math.pow(bounds.width / 8, 2);\n    for (const key of s.pieces.keys()) {\n        const center = util.computeSquareCenter(key, asWhite, bounds);\n        if (util.distanceSq(center, pos) <= radiusSq)\n            return true;\n    }\n    return false;\n}\nexport function dragNewPiece(s, piece, e, force) {\n    const key = 'a0';\n    s.pieces.set(key, piece);\n    s.dom.redraw();\n    const position = util.eventPosition(e);\n    s.draggable.current = {\n        orig: key,\n        piece,\n        origPos: position,\n        pos: position,\n        started: true,\n        element: () => pieceElementByKey(s, key),\n        originTarget: e.target,\n        newPiece: true,\n        force: !!force,\n        keyHasChanged: false,\n    };\n    processDrag(s);\n}\nfunction processDrag(s) {\n    requestAnimationFrame(() => {\n        var _a;\n        const cur = s.draggable.current;\n        if (!cur)\n            return;\n        // cancel animations while dragging\n        if ((_a = s.animation.current) === null || _a === void 0 ? void 0 : _a.plan.anims.has(cur.orig))\n            s.animation.current = undefined;\n        // if moving piece is gone, cancel\n        const origPiece = s.pieces.get(cur.orig);\n        if (!origPiece || !util.samePiece(origPiece, cur.piece))\n            cancel(s);\n        else {\n            if (!cur.started && util.distanceSq(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2))\n                cur.started = true;\n            if (cur.started) {\n                // support lazy elements\n                if (typeof cur.element === 'function') {\n                    const found = cur.element();\n                    if (!found)\n                        return;\n                    found.cgDragging = true;\n                    found.classList.add('dragging');\n                    cur.element = found;\n                }\n                const bounds = s.dom.bounds();\n                util.translate(cur.element, [\n                    cur.pos[0] - bounds.left - bounds.width / 16,\n                    cur.pos[1] - bounds.top - bounds.height / 16,\n                ]);\n                cur.keyHasChanged || (cur.keyHasChanged = cur.orig !== board.getKeyAtDomPos(cur.pos, board.whitePov(s), bounds));\n            }\n        }\n        processDrag(s);\n    });\n}\nexport function move(s, e) {\n    // support one finger touch only\n    if (s.draggable.current && (!e.touches || e.touches.length < 2)) {\n        s.draggable.current.pos = util.eventPosition(e);\n    }\n}\nexport function end(s, e) {\n    const cur = s.draggable.current;\n    if (!cur)\n        return;\n    // create no corresponding mouse event\n    if (e.type === 'touchend' && e.cancelable !== false)\n        e.preventDefault();\n    // comparing with the origin target is an easy way to test that the end event\n    // has the same touch origin\n    if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {\n        s.draggable.current = undefined;\n        return;\n    }\n    board.unsetPremove(s);\n    board.unsetPredrop(s);\n    // touchend has no position; so use the last touchmove position instead\n    const eventPos = util.eventPosition(e) || cur.pos;\n    const dest = board.getKeyAtDomPos(eventPos, board.whitePov(s), s.dom.bounds());\n    if (dest && cur.started && cur.orig !== dest) {\n        if (cur.newPiece)\n            board.dropNewPiece(s, cur.orig, dest, cur.force);\n        else {\n            s.stats.ctrlKey = e.ctrlKey;\n            if (board.userMove(s, cur.orig, dest))\n                s.stats.dragged = true;\n        }\n    }\n    else if (cur.newPiece) {\n        s.pieces.delete(cur.orig);\n    }\n    else if (s.draggable.deleteOnDropOff && !dest) {\n        s.pieces.delete(cur.orig);\n        board.callUserFunction(s.events.change);\n    }\n    if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest))\n        board.unselect(s);\n    else if (!s.selectable.enabled)\n        board.unselect(s);\n    removeDragElements(s);\n    s.draggable.current = undefined;\n    s.dom.redraw();\n}\nexport function cancel(s) {\n    const cur = s.draggable.current;\n    if (cur) {\n        if (cur.newPiece)\n            s.pieces.delete(cur.orig);\n        s.draggable.current = undefined;\n        board.unselect(s);\n        removeDragElements(s);\n        s.dom.redraw();\n    }\n}\nfunction removeDragElements(s) {\n    const e = s.dom.elements;\n    if (e.ghost)\n        util.setVisible(e.ghost, false);\n}\nfunction pieceElementByKey(s, key) {\n    let el = s.dom.elements.board.firstChild;\n    while (el) {\n        if (el.cgKey === key && el.tagName === 'PIECE')\n            return el;\n        el = el.nextSibling;\n    }\n    return;\n}\n//# sourceMappingURL=drag.js.map","import { State } from './state.js';\nimport * as board from './board.js';\nimport * as util from './util.js';\nimport { clear as drawClear } from './draw.js';\nimport * as cg from './types.js';\nimport { anim } from './anim.js';\n\nexport interface DragCurrent {\n  orig: cg.Key; // orig key of dragging piece\n  piece: cg.Piece;\n  origPos: cg.NumberPair; // first event position\n  pos: cg.NumberPair; // latest event position\n  started: boolean; // whether the drag has started; as per the distance setting\n  element: cg.PieceNode | (() => cg.PieceNode | undefined);\n  newPiece?: boolean; // it it a new piece from outside the board\n  force?: boolean; // can the new piece replace an existing one (editor)\n  previouslySelected?: cg.Key;\n  originTarget: EventTarget | null;\n  keyHasChanged: boolean; // whether the drag has left the orig key\n}\n\nexport function start(s: State, e: cg.MouchEvent): void {\n  if (!(s.trustAllEvents || e.isTrusted)) return; // only trust when trustAllEvents is enabled\n  if (e.buttons !== undefined && e.buttons > 1) return; // only touch or left click\n  if (e.touches && e.touches.length > 1) return; // support one finger touch only\n  const bounds = s.dom.bounds(),\n    position = util.eventPosition(e)!,\n    orig = board.getKeyAtDomPos(position, board.whitePov(s), bounds);\n  if (!orig) return;\n  const piece = s.pieces.get(orig);\n  const previouslySelected = s.selected;\n  if (\n    !previouslySelected &&\n    s.drawable.enabled &&\n    (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor)\n  )\n    drawClear(s);\n  // Prevent touch scroll and create no corresponding mouse event, if there\n  // is an intent to interact with the board.\n  if (\n    e.cancelable !== false &&\n    (!e.touches || s.blockTouchScroll || piece || previouslySelected || pieceCloseTo(s, position))\n  )\n    e.preventDefault();\n  else if (e.touches) return; // Handle only corresponding mouse event https://github.com/lichess-org/chessground/pull/268\n\n  const hadPremove = !!s.premovable.current;\n  const hadPredrop = !!s.predroppable.current;\n  s.stats.ctrlKey = e.ctrlKey;\n  if (s.selected && board.canMove(s, s.selected, orig)) {\n    anim(state => board.selectSquare(state, orig), s);\n  } else {\n    board.selectSquare(s, orig);\n  }\n  const stillSelected = s.selected === orig;\n  const element = pieceElementByKey(s, orig);\n  if (piece && element && stillSelected && board.isDraggable(s, orig)) {\n    s.draggable.current = {\n      orig,\n      piece,\n      origPos: position,\n      pos: position,\n      started: s.draggable.autoDistance && s.stats.dragged,\n      element,\n      previouslySelected,\n      originTarget: e.target,\n      keyHasChanged: false,\n    };\n    element.cgDragging = true;\n    element.classList.add('dragging');\n    // place ghost\n    const ghost = s.dom.elements.ghost;\n    if (ghost) {\n      ghost.className = `ghost ${piece.color} ${piece.role}`;\n      util.translate(ghost, util.posToTranslate(bounds)(util.key2pos(orig), board.whitePov(s)));\n      util.setVisible(ghost, true);\n    }\n    processDrag(s);\n  } else {\n    if (hadPremove) board.unsetPremove(s);\n    if (hadPredrop) board.unsetPredrop(s);\n  }\n  s.dom.redraw();\n}\n\nfunction pieceCloseTo(s: State, pos: cg.NumberPair): boolean {\n  const asWhite = board.whitePov(s),\n    bounds = s.dom.bounds(),\n    radiusSq = Math.pow(bounds.width / 8, 2);\n  for (const key of s.pieces.keys()) {\n    const center = util.computeSquareCenter(key, asWhite, bounds);\n    if (util.distanceSq(center, pos) <= radiusSq) return true;\n  }\n  return false;\n}\n\nexport function dragNewPiece(s: State, piece: cg.Piece, e: cg.MouchEvent, force?: boolean): void {\n  const key: cg.Key = 'a0';\n  s.pieces.set(key, piece);\n  s.dom.redraw();\n\n  const position = util.eventPosition(e)!;\n\n  s.draggable.current = {\n    orig: key,\n    piece,\n    origPos: position,\n    pos: position,\n    started: true,\n    element: () => pieceElementByKey(s, key),\n    originTarget: e.target,\n    newPiece: true,\n    force: !!force,\n    keyHasChanged: false,\n  };\n  processDrag(s);\n}\n\nfunction processDrag(s: State): void {\n  requestAnimationFrame(() => {\n    const cur = s.draggable.current;\n    if (!cur) return;\n    // cancel animations while dragging\n    if (s.animation.current?.plan.anims.has(cur.orig)) s.animation.current = undefined;\n    // if moving piece is gone, cancel\n    const origPiece = s.pieces.get(cur.orig);\n    if (!origPiece || !util.samePiece(origPiece, cur.piece)) cancel(s);\n    else {\n      if (!cur.started && util.distanceSq(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2))\n        cur.started = true;\n      if (cur.started) {\n        // support lazy elements\n        if (typeof cur.element === 'function') {\n          const found = cur.element();\n          if (!found) return;\n          found.cgDragging = true;\n          found.classList.add('dragging');\n          cur.element = found;\n        }\n\n        const bounds = s.dom.bounds();\n        util.translate(cur.element, [\n          cur.pos[0] - bounds.left - bounds.width / 16,\n          cur.pos[1] - bounds.top - bounds.height / 16,\n        ]);\n\n        cur.keyHasChanged ||= cur.orig !== board.getKeyAtDomPos(cur.pos, board.whitePov(s), bounds);\n      }\n    }\n    processDrag(s);\n  });\n}\n\nexport function move(s: State, e: cg.MouchEvent): void {\n  // support one finger touch only\n  if (s.draggable.current && (!e.touches || e.touches.length < 2)) {\n    s.draggable.current.pos = util.eventPosition(e)!;\n  }\n}\n\nexport function end(s: State, e: cg.MouchEvent): void {\n  const cur = s.draggable.current;\n  if (!cur) return;\n  // create no corresponding mouse event\n  if (e.type === 'touchend' && e.cancelable !== false) e.preventDefault();\n  // comparing with the origin target is an easy way to test that the end event\n  // has the same touch origin\n  if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {\n    s.draggable.current = undefined;\n    return;\n  }\n  board.unsetPremove(s);\n  board.unsetPredrop(s);\n  // touchend has no position; so use the last touchmove position instead\n  const eventPos = util.eventPosition(e) || cur.pos;\n  const dest = board.getKeyAtDomPos(eventPos, board.whitePov(s), s.dom.bounds());\n  if (dest && cur.started && cur.orig !== dest) {\n    if (cur.newPiece) board.dropNewPiece(s, cur.orig, dest, cur.force);\n    else {\n      s.stats.ctrlKey = e.ctrlKey;\n      if (board.userMove(s, cur.orig, dest)) s.stats.dragged = true;\n    }\n  } else if (cur.newPiece) {\n    s.pieces.delete(cur.orig);\n  } else if (s.draggable.deleteOnDropOff && !dest) {\n    s.pieces.delete(cur.orig);\n    board.callUserFunction(s.events.change);\n  }\n  if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest))\n    board.unselect(s);\n  else if (!s.selectable.enabled) board.unselect(s);\n\n  removeDragElements(s);\n\n  s.draggable.current = undefined;\n  s.dom.redraw();\n}\n\nexport function cancel(s: State): void {\n  const cur = s.draggable.current;\n  if (cur) {\n    if (cur.newPiece) s.pieces.delete(cur.orig);\n    s.draggable.current = undefined;\n    board.unselect(s);\n    removeDragElements(s);\n    s.dom.redraw();\n  }\n}\n\nfunction removeDragElements(s: State): void {\n  const e = s.dom.elements;\n  if (e.ghost) util.setVisible(e.ghost, false);\n}\n\nfunction pieceElementByKey(s: State, key: cg.Key): cg.PieceNode | undefined {\n  let el = s.dom.elements.board.firstChild;\n  while (el) {\n    if ((el as cg.KeyedNode).cgKey === key && (el as cg.KeyedNode).tagName === 'PIECE')\n      return el as cg.PieceNode;\n    el = el.nextSibling;\n  }\n  return;\n}\n","import { unselect, cancelMove, getKeyAtDomPos, getSnappedKeyAtDomPos, whitePov } from './board.js';\nimport { eventPosition, isRightButton } from './util.js';\nconst brushes = ['green', 'red', 'blue', 'yellow'];\nexport function start(state, e) {\n    // support one finger touch only\n    if (e.touches && e.touches.length > 1)\n        return;\n    e.stopPropagation();\n    e.preventDefault();\n    e.ctrlKey ? unselect(state) : cancelMove(state);\n    const pos = eventPosition(e), orig = getKeyAtDomPos(pos, whitePov(state), state.dom.bounds());\n    if (!orig)\n        return;\n    state.drawable.current = {\n        orig,\n        pos,\n        brush: eventBrush(e),\n        snapToValidMove: state.drawable.defaultSnapToValidMove,\n    };\n    processDraw(state);\n}\nexport function processDraw(state) {\n    requestAnimationFrame(() => {\n        const cur = state.drawable.current;\n        if (cur) {\n            const keyAtDomPos = getKeyAtDomPos(cur.pos, whitePov(state), state.dom.bounds());\n            if (!keyAtDomPos) {\n                cur.snapToValidMove = false;\n            }\n            const mouseSq = cur.snapToValidMove\n                ? getSnappedKeyAtDomPos(cur.orig, cur.pos, whitePov(state), state.dom.bounds())\n                : keyAtDomPos;\n            if (mouseSq !== cur.mouseSq) {\n                cur.mouseSq = mouseSq;\n                cur.dest = mouseSq !== cur.orig ? mouseSq : undefined;\n                state.dom.redrawNow();\n            }\n            processDraw(state);\n        }\n    });\n}\nexport function move(state, e) {\n    if (state.drawable.current)\n        state.drawable.current.pos = eventPosition(e);\n}\nexport function end(state) {\n    const cur = state.drawable.current;\n    if (cur) {\n        if (cur.mouseSq)\n            addShape(state.drawable, cur);\n        cancel(state);\n    }\n}\nexport function cancel(state) {\n    if (state.drawable.current) {\n        state.drawable.current = undefined;\n        state.dom.redraw();\n    }\n}\nexport function clear(state) {\n    if (state.drawable.shapes.length) {\n        state.drawable.shapes = [];\n        state.dom.redraw();\n        onChange(state.drawable);\n    }\n}\nfunction eventBrush(e) {\n    var _a;\n    const modA = (e.shiftKey || e.ctrlKey) && isRightButton(e);\n    const modB = e.altKey || e.metaKey || ((_a = e.getModifierState) === null || _a === void 0 ? void 0 : _a.call(e, 'AltGraph'));\n    return brushes[(modA ? 1 : 0) + (modB ? 2 : 0)];\n}\nfunction addShape(drawable, cur) {\n    const sameShape = (s) => s.orig === cur.orig && s.dest === cur.dest;\n    const similar = drawable.shapes.find(sameShape);\n    if (similar)\n        drawable.shapes = drawable.shapes.filter(s => !sameShape(s));\n    if (!similar || similar.brush !== cur.brush)\n        drawable.shapes.push({\n            orig: cur.orig,\n            dest: cur.dest,\n            brush: cur.brush,\n        });\n    onChange(drawable);\n}\nfunction onChange(drawable) {\n    if (drawable.onChange)\n        drawable.onChange(drawable.shapes);\n}\n//# sourceMappingURL=draw.js.map","import { State } from './state.js';\nimport { unselect, cancelMove, getKeyAtDomPos, getSnappedKeyAtDomPos, whitePov } from './board.js';\nimport { eventPosition, isRightButton } from './util.js';\nimport * as cg from './types.js';\n\nexport interface DrawShape {\n  orig: cg.Key;\n  dest?: cg.Key;\n  brush?: string; // if no brush, no shape. label moved to top right of square\n  modifiers?: DrawModifiers;\n  piece?: DrawShapePiece;\n  customSvg?: { html: string; center?: 'orig' | 'dest' | 'label' }; // 100 x 100 viewbox cenetered at [50,50]\n  label?: { text: string; fill?: string }; // fill is in '#rrggbb' format\n}\n\nexport interface DrawModifiers {\n  lineWidth?: number;\n  hilite?: boolean;\n}\n\nexport interface DrawShapePiece {\n  role: cg.Role;\n  color: cg.Color;\n  scale?: number;\n}\n\nexport interface DrawBrush {\n  key: string;\n  color: string;\n  opacity: number;\n  lineWidth: number;\n}\n\nexport interface DrawBrushes {\n  green: DrawBrush;\n  red: DrawBrush;\n  blue: DrawBrush;\n  yellow: DrawBrush;\n  [color: string]: DrawBrush;\n}\n\nexport interface Drawable {\n  enabled: boolean; // can draw\n  visible: boolean; // can view\n  defaultSnapToValidMove: boolean;\n  eraseOnClick: boolean;\n  onChange?: (shapes: DrawShape[]) => void;\n  shapes: DrawShape[]; // user shapes\n  autoShapes: DrawShape[]; // computer shapes\n  current?: DrawCurrent;\n  brushes: DrawBrushes;\n  prevSvgHash: string;\n}\n\nexport interface DrawCurrent {\n  orig: cg.Key; // orig key of drawing\n  dest?: cg.Key; // shape dest, or undefined for circle\n  mouseSq?: cg.Key; // square being moused over\n  pos: cg.NumberPair; // relative current position\n  brush: cg.BrushColor; // brush name for shape\n  snapToValidMove: boolean; // whether to snap to valid piece moves\n}\n\nconst brushes: cg.BrushColor[] = ['green', 'red', 'blue', 'yellow'];\n\nexport function start(state: State, e: cg.MouchEvent): void {\n  // support one finger touch only\n  if (e.touches && e.touches.length > 1) return;\n  e.stopPropagation();\n  e.preventDefault();\n  e.ctrlKey ? unselect(state) : cancelMove(state);\n  const pos = eventPosition(e)!,\n    orig = getKeyAtDomPos(pos, whitePov(state), state.dom.bounds());\n  if (!orig) return;\n  state.drawable.current = {\n    orig,\n    pos,\n    brush: eventBrush(e),\n    snapToValidMove: state.drawable.defaultSnapToValidMove,\n  };\n\n  processDraw(state);\n}\n\nexport function processDraw(state: State): void {\n  requestAnimationFrame(() => {\n    const cur = state.drawable.current;\n    if (cur) {\n      const keyAtDomPos = getKeyAtDomPos(cur.pos, whitePov(state), state.dom.bounds());\n      if (!keyAtDomPos) {\n        cur.snapToValidMove = false;\n      }\n      const mouseSq = cur.snapToValidMove\n        ? getSnappedKeyAtDomPos(cur.orig, cur.pos, whitePov(state), state.dom.bounds())\n        : keyAtDomPos;\n      if (mouseSq !== cur.mouseSq) {\n        cur.mouseSq = mouseSq;\n        cur.dest = mouseSq !== cur.orig ? mouseSq : undefined;\n        state.dom.redrawNow();\n      }\n      processDraw(state);\n    }\n  });\n}\n\nexport function move(state: State, e: cg.MouchEvent): void {\n  if (state.drawable.current) state.drawable.current.pos = eventPosition(e)!;\n}\n\nexport function end(state: State): void {\n  const cur = state.drawable.current;\n  if (cur) {\n    if (cur.mouseSq) addShape(state.drawable, cur);\n    cancel(state);\n  }\n}\n\nexport function cancel(state: State): void {\n  if (state.drawable.current) {\n    state.drawable.current = undefined;\n    state.dom.redraw();\n  }\n}\n\nexport function clear(state: State): void {\n  if (state.drawable.shapes.length) {\n    state.drawable.shapes = [];\n    state.dom.redraw();\n    onChange(state.drawable);\n  }\n}\n\nfunction eventBrush(e: cg.MouchEvent): cg.BrushColor {\n  const modA = (e.shiftKey || e.ctrlKey) && isRightButton(e);\n  const modB = e.altKey || e.metaKey || e.getModifierState?.('AltGraph');\n  return brushes[(modA ? 1 : 0) + (modB ? 2 : 0)];\n}\n\nfunction addShape(drawable: Drawable, cur: DrawCurrent): void {\n  const sameShape = (s: DrawShape) => s.orig === cur.orig && s.dest === cur.dest;\n  const similar = drawable.shapes.find(sameShape);\n  if (similar) drawable.shapes = drawable.shapes.filter(s => !sameShape(s));\n  if (!similar || similar.brush !== cur.brush)\n    drawable.shapes.push({\n      orig: cur.orig,\n      dest: cur.dest,\n      brush: cur.brush,\n    });\n  onChange(drawable);\n}\n\nfunction onChange(drawable: Drawable): void {\n  if (drawable.onChange) drawable.onChange(drawable.shapes);\n}\n","export function explosion(state, keys) {\n    state.exploding = { stage: 1, keys };\n    state.dom.redraw();\n    setTimeout(() => {\n        setStage(state, 2);\n        setTimeout(() => setStage(state, undefined), 120);\n    }, 120);\n}\nfunction setStage(state, stage) {\n    if (state.exploding) {\n        if (stage)\n            state.exploding.stage = stage;\n        else\n            state.exploding = undefined;\n        state.dom.redraw();\n    }\n}\n//# sourceMappingURL=explosion.js.map","import { State } from './state.js';\nimport { Key } from './types.js';\n\nexport function explosion(state: State, keys: Key[]): void {\n  state.exploding = { stage: 1, keys };\n  state.dom.redraw();\n  setTimeout(() => {\n    setStage(state, 2);\n    setTimeout(() => setStage(state, undefined), 120);\n  }, 120);\n}\n\nfunction setStage(state: State, stage: number | undefined): void {\n  if (state.exploding) {\n    if (stage) state.exploding.stage = stage;\n    else state.exploding = undefined;\n    state.dom.redraw();\n  }\n}\n","import * as fen from './fen.js';\nimport { timer } from './util.js';\nexport function defaults() {\n    return {\n        pieces: fen.read(fen.initial),\n        orientation: 'white',\n        turnColor: 'white',\n        coordinates: true,\n        coordinatesOnSquares: false,\n        ranksPosition: 'right',\n        autoCastle: true,\n        viewOnly: false,\n        disableContextMenu: false,\n        addPieceZIndex: false,\n        blockTouchScroll: false,\n        pieceKey: false,\n        trustAllEvents: false,\n        highlight: {\n            lastMove: true,\n            check: true,\n        },\n        animation: {\n            enabled: true,\n            duration: 200,\n        },\n        movable: {\n            free: true,\n            color: 'both',\n            showDests: true,\n            events: {},\n            rookCastle: true,\n        },\n        premovable: {\n            enabled: true,\n            showDests: true,\n            castle: true,\n            events: {},\n        },\n        predroppable: {\n            enabled: false,\n            events: {},\n        },\n        draggable: {\n            enabled: true,\n            distance: 3,\n            autoDistance: true,\n            showGhost: true,\n            deleteOnDropOff: false,\n        },\n        dropmode: {\n            active: false,\n        },\n        selectable: {\n            enabled: true,\n        },\n        stats: {\n            // on touchscreen, default to \"tap-tap\" moves\n            // instead of drag\n            dragged: !('ontouchstart' in window),\n        },\n        events: {},\n        drawable: {\n            enabled: true,\n            visible: true,\n            defaultSnapToValidMove: true,\n            eraseOnClick: true,\n            shapes: [],\n            autoShapes: [],\n            brushes: {\n                green: { key: 'g', color: '#15781B', opacity: 1, lineWidth: 10 },\n                red: { key: 'r', color: '#882020', opacity: 1, lineWidth: 10 },\n                blue: { key: 'b', color: '#003088', opacity: 1, lineWidth: 10 },\n                yellow: { key: 'y', color: '#e68f00', opacity: 1, lineWidth: 10 },\n                paleBlue: { key: 'pb', color: '#003088', opacity: 0.4, lineWidth: 15 },\n                paleGreen: { key: 'pg', color: '#15781B', opacity: 0.4, lineWidth: 15 },\n                paleRed: { key: 'pr', color: '#882020', opacity: 0.4, lineWidth: 15 },\n                paleGrey: {\n                    key: 'pgr',\n                    color: '#4a4a4a',\n                    opacity: 0.35,\n                    lineWidth: 15,\n                },\n                purple: { key: 'purple', color: '#68217a', opacity: 0.65, lineWidth: 10 },\n                pink: { key: 'pink', color: '#ee2080', opacity: 0.5, lineWidth: 10 },\n                white: { key: 'white', color: 'white', opacity: 1, lineWidth: 10 },\n            },\n            prevSvgHash: '',\n        },\n        hold: timer(),\n    };\n}\n//# sourceMappingURL=state.js.map","import * as fen from './fen.js';\nimport { AnimCurrent } from './anim.js';\nimport { DragCurrent } from './drag.js';\nimport { Drawable } from './draw.js';\nimport { timer } from './util.js';\nimport * as cg from './types.js';\n\nexport interface HeadlessState {\n  pieces: cg.Pieces;\n  orientation: cg.Color; // board orientation. white | black\n  turnColor: cg.Color; // turn to play. white | black\n  check?: cg.Key; // square currently in check \"a2\"\n  lastMove?: cg.Key[]; // squares part of the last move [\"c3\"; \"c4\"]\n  selected?: cg.Key; // square currently selected \"a1\"\n  coordinates: boolean; // include coords attributes\n  coordinatesOnSquares: boolean; // include coords attributes on every square\n  ranksPosition: cg.RanksPosition; // position ranks on either side. left | right\n  autoCastle: boolean; // immediately complete the castle by moving the rook after king move\n  viewOnly: boolean; // don't bind events: the user will never be able to move pieces around\n  disableContextMenu: boolean; // because who needs a context menu on a chessboard\n  addPieceZIndex: boolean; // adds z-index values to pieces (for 3D)\n  addDimensionsCssVarsTo?: HTMLElement; // add ---cg-width and ---cg-height CSS vars containing the board's dimensions to this element\n  blockTouchScroll: boolean; // block scrolling via touch dragging on the board, e.g. for coordinate training\n  pieceKey: boolean; // add a data-key attribute to piece elements\n  trustAllEvents?: boolean; // disable checking for human only input (e.isTrusted)\n  highlight: {\n    lastMove: boolean; // add last-move class to squares\n    check: boolean; // add check class to squares\n    custom?: cg.SquareClasses; // add custom classes to custom squares\n  };\n  animation: {\n    enabled: boolean;\n    duration: number;\n    current?: AnimCurrent;\n  };\n  movable: {\n    free: boolean; // all moves are valid - board editor\n    color?: cg.Color | 'both'; // color that can move. white | black | both\n    dests?: cg.Dests; // valid moves. {\"a2\" [\"a3\" \"a4\"] \"b1\" [\"a3\" \"c3\"]}\n    showDests: boolean; // whether to add the move-dest class on squares\n    events: {\n      after?: (orig: cg.Key, dest: cg.Key, metadata: cg.MoveMetadata) => void; // called after the move has been played\n      afterNewPiece?: (role: cg.Role, key: cg.Key, metadata: cg.MoveMetadata) => void; // called after a new piece is dropped on the board\n    };\n    rookCastle: boolean; // castle by moving the king to the rook\n  };\n  premovable: {\n    enabled: boolean; // allow premoves for color that can not move\n    showDests: boolean; // whether to add the premove-dest class on squares\n    castle: boolean; // whether to allow king castle premoves\n    dests?: cg.Key[]; // premove destinations for the current selection\n    customDests?: cg.Dests; // use custom valid premoves. {\"a2\" [\"a3\" \"a4\"] \"b1\" [\"a3\" \"c3\"]}\n    current?: cg.KeyPair; // keys of the current saved premove [\"e2\" \"e4\"]\n    events: {\n      set?: (orig: cg.Key, dest: cg.Key, metadata?: cg.SetPremoveMetadata) => void; // called after the premove has been set\n      unset?: () => void; // called after the premove has been unset\n    };\n  };\n  predroppable: {\n    enabled: boolean; // allow predrops for color that can not move\n    current?: {\n      // current saved predrop {role: 'knight'; key: 'e4'}\n      role: cg.Role;\n      key: cg.Key;\n    };\n    events: {\n      set?: (role: cg.Role, key: cg.Key) => void; // called after the predrop has been set\n      unset?: () => void; // called after the predrop has been unset\n    };\n  };\n  draggable: {\n    enabled: boolean; // allow moves & premoves to use drag'n drop\n    distance: number; // minimum distance to initiate a drag; in pixels\n    autoDistance: boolean; // lets chessground set distance to zero when user drags pieces\n    showGhost: boolean; // show ghost of piece being dragged\n    deleteOnDropOff: boolean; // delete a piece when it is dropped off the board\n    current?: DragCurrent;\n  };\n  dropmode: {\n    active: boolean;\n    piece?: cg.Piece;\n  };\n  selectable: {\n    // disable to enforce dragging over click-click move\n    enabled: boolean;\n  };\n  stats: {\n    // was last piece dragged or clicked?\n    // needs default to false for touch\n    dragged: boolean;\n    ctrlKey?: boolean;\n  };\n  events: {\n    change?: () => void; // called after the situation changes on the board\n    // called after a piece has been moved.\n    // capturedPiece is undefined or like {color: 'white'; 'role': 'queen'}\n    move?: (orig: cg.Key, dest: cg.Key, capturedPiece?: cg.Piece) => void;\n    dropNewPiece?: (piece: cg.Piece, key: cg.Key) => void;\n    select?: (key: cg.Key) => void; // called when a square is selected\n    insert?: (elements: cg.Elements) => void; // when the board DOM has been (re)inserted\n  };\n  drawable: Drawable;\n  exploding?: cg.Exploding;\n  hold: cg.Timer;\n}\n\nexport interface State extends HeadlessState {\n  dom: cg.Dom;\n}\n\nexport function defaults(): HeadlessState {\n  return {\n    pieces: fen.read(fen.initial),\n    orientation: 'white',\n    turnColor: 'white',\n    coordinates: true,\n    coordinatesOnSquares: false,\n    ranksPosition: 'right',\n    autoCastle: true,\n    viewOnly: false,\n    disableContextMenu: false,\n    addPieceZIndex: false,\n    blockTouchScroll: false,\n    pieceKey: false,\n    trustAllEvents: false,\n    highlight: {\n      lastMove: true,\n      check: true,\n    },\n    animation: {\n      enabled: true,\n      duration: 200,\n    },\n    movable: {\n      free: true,\n      color: 'both',\n      showDests: true,\n      events: {},\n      rookCastle: true,\n    },\n    premovable: {\n      enabled: true,\n      showDests: true,\n      castle: true,\n      events: {},\n    },\n    predroppable: {\n      enabled: false,\n      events: {},\n    },\n    draggable: {\n      enabled: true,\n      distance: 3,\n      autoDistance: true,\n      showGhost: true,\n      deleteOnDropOff: false,\n    },\n    dropmode: {\n      active: false,\n    },\n    selectable: {\n      enabled: true,\n    },\n    stats: {\n      // on touchscreen, default to \"tap-tap\" moves\n      // instead of drag\n      dragged: !('ontouchstart' in window),\n    },\n    events: {},\n    drawable: {\n      enabled: true, // can draw\n      visible: true, // can view\n      defaultSnapToValidMove: true,\n      eraseOnClick: true,\n      shapes: [],\n      autoShapes: [],\n      brushes: {\n        green: { key: 'g', color: '#15781B', opacity: 1, lineWidth: 10 },\n        red: { key: 'r', color: '#882020', opacity: 1, lineWidth: 10 },\n        blue: { key: 'b', color: '#003088', opacity: 1, lineWidth: 10 },\n        yellow: { key: 'y', color: '#e68f00', opacity: 1, lineWidth: 10 },\n        paleBlue: { key: 'pb', color: '#003088', opacity: 0.4, lineWidth: 15 },\n        paleGreen: { key: 'pg', color: '#15781B', opacity: 0.4, lineWidth: 15 },\n        paleRed: { key: 'pr', color: '#882020', opacity: 0.4, lineWidth: 15 },\n        paleGrey: {\n          key: 'pgr',\n          color: '#4a4a4a',\n          opacity: 0.35,\n          lineWidth: 15,\n        },\n        purple: { key: 'purple', color: '#68217a', opacity: 0.65, lineWidth: 10 },\n        pink: { key: 'pink', color: '#ee2080', opacity: 0.5, lineWidth: 10 },\n        white: { key: 'white', color: 'white', opacity: 1, lineWidth: 10 },\n      },\n      prevSvgHash: '',\n    },\n    hold: timer(),\n  };\n}\n","import { setVisible, createEl } from './util.js';\nimport { colors, files, ranks } from './types.js';\nimport { createElement as createSVG, setAttributes, createDefs } from './svg.js';\nexport function renderWrap(element, s) {\n    // .cg-wrap (element passed to Chessground)\n    //   cg-container\n    //     cg-board\n    //     svg.cg-shapes\n    //       defs\n    //       g\n    //     svg.cg-custom-svgs\n    //       g\n    //     cg-auto-pieces\n    //     coords.ranks\n    //     coords.files\n    //     piece.ghost\n    element.innerHTML = '';\n    // ensure the cg-wrap class is set\n    // so bounds calculation can use the CSS width/height values\n    // add that class yourself to the element before calling chessground\n    // for a slight performance improvement! (avoids recomputing style)\n    element.classList.add('cg-wrap');\n    for (const c of colors)\n        element.classList.toggle('orientation-' + c, s.orientation === c);\n    element.classList.toggle('manipulable', !s.viewOnly);\n    const container = createEl('cg-container');\n    element.appendChild(container);\n    const board = createEl('cg-board');\n    container.appendChild(board);\n    let svg;\n    let customSvg;\n    let autoPieces;\n    if (s.drawable.visible) {\n        svg = setAttributes(createSVG('svg'), {\n            class: 'cg-shapes',\n            viewBox: '-4 -4 8 8',\n            preserveAspectRatio: 'xMidYMid slice',\n        });\n        svg.appendChild(createDefs());\n        svg.appendChild(createSVG('g'));\n        customSvg = setAttributes(createSVG('svg'), {\n            class: 'cg-custom-svgs',\n            viewBox: '-3.5 -3.5 8 8',\n            preserveAspectRatio: 'xMidYMid slice',\n        });\n        customSvg.appendChild(createSVG('g'));\n        autoPieces = createEl('cg-auto-pieces');\n        container.appendChild(svg);\n        container.appendChild(customSvg);\n        container.appendChild(autoPieces);\n    }\n    if (s.coordinates) {\n        const orientClass = s.orientation === 'black' ? ' black' : '';\n        const ranksPositionClass = s.ranksPosition === 'left' ? ' left' : '';\n        if (s.coordinatesOnSquares) {\n            const rankN = s.orientation === 'white' ? i => i + 1 : i => 8 - i;\n            files.forEach((f, i) => container.appendChild(renderCoords(ranks.map(r => f + r), 'squares rank' + rankN(i) + orientClass + ranksPositionClass)));\n        }\n        else {\n            container.appendChild(renderCoords(ranks, 'ranks' + orientClass + ranksPositionClass));\n            container.appendChild(renderCoords(files, 'files' + orientClass));\n        }\n    }\n    let ghost;\n    if (s.draggable.enabled && s.draggable.showGhost) {\n        ghost = createEl('piece', 'ghost');\n        setVisible(ghost, false);\n        container.appendChild(ghost);\n    }\n    return {\n        board,\n        container,\n        wrap: element,\n        ghost,\n        svg,\n        customSvg,\n        autoPieces,\n    };\n}\nfunction renderCoords(elems, className) {\n    const el = createEl('coords', className);\n    let f;\n    for (const elem of elems) {\n        f = createEl('coord');\n        f.textContent = elem;\n        el.appendChild(f);\n    }\n    return el;\n}\n//# sourceMappingURL=wrap.js.map","import { HeadlessState } from './state.js';\nimport { setVisible, createEl } from './util.js';\nimport { colors, files, ranks, Elements } from './types.js';\nimport { createElement as createSVG, setAttributes, createDefs } from './svg.js';\n\nexport function renderWrap(element: HTMLElement, s: HeadlessState): Elements {\n  // .cg-wrap (element passed to Chessground)\n  //   cg-container\n  //     cg-board\n  //     svg.cg-shapes\n  //       defs\n  //       g\n  //     svg.cg-custom-svgs\n  //       g\n  //     cg-auto-pieces\n  //     coords.ranks\n  //     coords.files\n  //     piece.ghost\n\n  element.innerHTML = '';\n\n  // ensure the cg-wrap class is set\n  // so bounds calculation can use the CSS width/height values\n  // add that class yourself to the element before calling chessground\n  // for a slight performance improvement! (avoids recomputing style)\n  element.classList.add('cg-wrap');\n\n  for (const c of colors) element.classList.toggle('orientation-' + c, s.orientation === c);\n  element.classList.toggle('manipulable', !s.viewOnly);\n\n  const container = createEl('cg-container');\n  element.appendChild(container);\n\n  const board = createEl('cg-board');\n  container.appendChild(board);\n\n  let svg: SVGElement | undefined;\n  let customSvg: SVGElement | undefined;\n  let autoPieces: HTMLElement | undefined;\n\n  if (s.drawable.visible) {\n    svg = setAttributes(createSVG('svg'), {\n      class: 'cg-shapes',\n      viewBox: '-4 -4 8 8',\n      preserveAspectRatio: 'xMidYMid slice',\n    });\n    svg.appendChild(createDefs());\n    svg.appendChild(createSVG('g'));\n\n    customSvg = setAttributes(createSVG('svg'), {\n      class: 'cg-custom-svgs',\n      viewBox: '-3.5 -3.5 8 8',\n      preserveAspectRatio: 'xMidYMid slice',\n    });\n    customSvg.appendChild(createSVG('g'));\n\n    autoPieces = createEl('cg-auto-pieces');\n\n    container.appendChild(svg);\n    container.appendChild(customSvg);\n    container.appendChild(autoPieces);\n  }\n\n  if (s.coordinates) {\n    const orientClass = s.orientation === 'black' ? ' black' : '';\n    const ranksPositionClass = s.ranksPosition === 'left' ? ' left' : '';\n\n    if (s.coordinatesOnSquares) {\n      const rankN: (i: number) => number = s.orientation === 'white' ? i => i + 1 : i => 8 - i;\n      files.forEach((f, i) =>\n        container.appendChild(\n          renderCoords(\n            ranks.map(r => f + r),\n            'squares rank' + rankN(i) + orientClass + ranksPositionClass,\n          ),\n        ),\n      );\n    } else {\n      container.appendChild(renderCoords(ranks, 'ranks' + orientClass + ranksPositionClass));\n      container.appendChild(renderCoords(files, 'files' + orientClass));\n    }\n  }\n\n  let ghost: HTMLElement | undefined;\n  if (s.draggable.enabled && s.draggable.showGhost) {\n    ghost = createEl('piece', 'ghost');\n    setVisible(ghost, false);\n    container.appendChild(ghost);\n  }\n\n  return {\n    board,\n    container,\n    wrap: element,\n    ghost,\n    svg,\n    customSvg,\n    autoPieces,\n  };\n}\n\nfunction renderCoords(elems: readonly string[], className: string): HTMLElement {\n  const el = createEl('coords', className);\n  let f: HTMLElement;\n  for (const elem of elems) {\n    f = createEl('coord');\n    f.textContent = elem;\n    el.appendChild(f);\n  }\n  return el;\n}\n","import { key2pos } from './util.js';\nconst hilites = {\n    hilitePrimary: { key: 'hilitePrimary', color: '#3291ff', opacity: 1, lineWidth: 1 },\n    hiliteWhite: { key: 'hiliteWhite', color: '#ffffff', opacity: 1, lineWidth: 1 },\n};\nexport { createElement, setAttributes };\nexport function createDefs() {\n    const defs = createElement('defs');\n    const filter = setAttributes(createElement('filter'), { id: 'cg-filter-blur' });\n    filter.appendChild(setAttributes(createElement('feGaussianBlur'), { stdDeviation: '0.019' }));\n    defs.appendChild(filter);\n    return defs;\n}\nexport function renderSvg(state, shapesEl, customsEl) {\n    var _a;\n    const d = state.drawable, curD = d.current, cur = curD && curD.mouseSq ? curD : undefined, dests = new Map(), bounds = state.dom.bounds(), nonPieceAutoShapes = d.autoShapes.filter(autoShape => !autoShape.piece);\n    for (const s of d.shapes.concat(nonPieceAutoShapes).concat(cur ? [cur] : [])) {\n        if (!s.dest)\n            continue;\n        const sources = (_a = dests.get(s.dest)) !== null && _a !== void 0 ? _a : new Set(), from = pos2user(orient(key2pos(s.orig), state.orientation), bounds), to = pos2user(orient(key2pos(s.dest), state.orientation), bounds);\n        sources.add(moveAngle(from, to));\n        dests.set(s.dest, sources);\n    }\n    const shapes = d.shapes.concat(nonPieceAutoShapes).map((s) => {\n        return {\n            shape: s,\n            current: false,\n            hash: shapeHash(s, isShort(s.dest, dests), false, bounds),\n        };\n    });\n    if (cur)\n        shapes.push({\n            shape: cur,\n            current: true,\n            hash: shapeHash(cur, isShort(cur.dest, dests), true, bounds),\n        });\n    const fullHash = shapes.map(sc => sc.hash).join(';');\n    if (fullHash === state.drawable.prevSvgHash)\n        return;\n    state.drawable.prevSvgHash = fullHash;\n    /*\n      -- DOM hierarchy --\n      <svg class=\"cg-shapes\">      (<= svg)\n        <defs>\n          ...(for brushes)...\n        </defs>\n        <g>\n          ...(for arrows and circles)...\n        </g>\n      </svg>\n      <svg class=\"cg-custom-svgs\"> (<= customSvg)\n        <g>\n          ...(for custom svgs)...\n        </g>\n      </svg>\n    */\n    const defsEl = shapesEl.querySelector('defs');\n    syncDefs(d, shapes, defsEl);\n    syncShapes(shapes, shapesEl.querySelector('g'), customsEl.querySelector('g'), s => renderShape(state, s, d.brushes, dests, bounds));\n}\n// append only. Don't try to update/remove.\nfunction syncDefs(d, shapes, defsEl) {\n    var _a;\n    const brushes = new Map();\n    let brush;\n    for (const s of shapes.filter(s => s.shape.dest && s.shape.brush)) {\n        brush = makeCustomBrush(d.brushes[s.shape.brush], s.shape.modifiers);\n        if ((_a = s.shape.modifiers) === null || _a === void 0 ? void 0 : _a.hilite)\n            brushes.set(hilite(brush).key, hilite(brush));\n        brushes.set(brush.key, brush);\n    }\n    const keysInDom = new Set();\n    let el = defsEl.firstElementChild;\n    while (el) {\n        keysInDom.add(el.getAttribute('cgKey'));\n        el = el.nextElementSibling;\n    }\n    for (const [key, brush] of brushes.entries()) {\n        if (!keysInDom.has(key))\n            defsEl.appendChild(renderMarker(brush));\n    }\n}\nfunction syncShapes(syncables, shapes, customs, renderShape) {\n    const hashesInDom = new Map();\n    for (const sc of syncables)\n        hashesInDom.set(sc.hash, false);\n    for (const root of [shapes, customs]) {\n        const toRemove = [];\n        let el = root.firstElementChild, elHash;\n        while (el) {\n            elHash = el.getAttribute('cgHash');\n            if (hashesInDom.has(elHash))\n                hashesInDom.set(elHash, true);\n            else\n                toRemove.push(el);\n            el = el.nextElementSibling;\n        }\n        for (const el of toRemove)\n            root.removeChild(el);\n    }\n    // insert shapes that are not yet in dom\n    for (const sc of syncables.filter(s => !hashesInDom.get(s.hash))) {\n        for (const svg of renderShape(sc)) {\n            if (svg.isCustom)\n                customs.appendChild(svg.el);\n            else\n                shapes.appendChild(svg.el);\n        }\n    }\n}\nfunction shapeHash({ orig, dest, brush, piece, modifiers, customSvg, label }, shorten, current, bounds) {\n    var _a, _b;\n    // a shape and an overlay svg share a lifetime and have the same cgHash attribute\n    return [\n        bounds.width,\n        bounds.height,\n        current,\n        orig,\n        dest,\n        brush,\n        shorten && '-',\n        piece && pieceHash(piece),\n        modifiers && modifiersHash(modifiers),\n        customSvg && `custom-${textHash(customSvg.html)},${(_b = (_a = customSvg.center) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'o'}`,\n        label && `label-${textHash(label.text)}`,\n    ]\n        .filter(x => x)\n        .join(',');\n}\nfunction pieceHash(piece) {\n    return [piece.color, piece.role, piece.scale].filter(x => x).join(',');\n}\nfunction modifiersHash(m) {\n    return [m.lineWidth, m.hilite && '*'].filter(x => x).join(',');\n}\nfunction textHash(s) {\n    // Rolling hash with base 31 (cf. https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript)\n    let h = 0;\n    for (let i = 0; i < s.length; i++) {\n        h = ((h << 5) - h + s.charCodeAt(i)) >>> 0;\n    }\n    return h.toString();\n}\nfunction renderShape(state, { shape, current, hash }, brushes, dests, bounds) {\n    var _a, _b;\n    const from = pos2user(orient(key2pos(shape.orig), state.orientation), bounds), to = shape.dest ? pos2user(orient(key2pos(shape.dest), state.orientation), bounds) : from, brush = shape.brush && makeCustomBrush(brushes[shape.brush], shape.modifiers), slots = dests.get(shape.dest), svgs = [];\n    if (brush) {\n        const el = setAttributes(createElement('g'), { cgHash: hash });\n        svgs.push({ el });\n        if (from[0] !== to[0] || from[1] !== to[1])\n            el.appendChild(renderArrow(shape, brush, from, to, current, isShort(shape.dest, dests)));\n        else\n            el.appendChild(renderCircle(brushes[shape.brush], from, current, bounds));\n    }\n    if (shape.label) {\n        const label = shape.label;\n        (_a = label.fill) !== null && _a !== void 0 ? _a : (label.fill = shape.brush && brushes[shape.brush].color);\n        const corner = shape.brush ? undefined : 'tr';\n        svgs.push({ el: renderLabel(label, hash, from, to, slots, corner), isCustom: true });\n    }\n    if (shape.customSvg) {\n        const on = (_b = shape.customSvg.center) !== null && _b !== void 0 ? _b : 'orig';\n        const [x, y] = on === 'label' ? labelCoords(from, to, slots).map(c => c - 0.5) : on === 'dest' ? to : from;\n        const el = setAttributes(createElement('g'), { transform: `translate(${x},${y})`, cgHash: hash });\n        el.innerHTML = `<svg width=\"1\" height=\"1\" viewBox=\"0 0 100 100\">${shape.customSvg.html}</svg>`;\n        svgs.push({ el, isCustom: true });\n    }\n    return svgs;\n}\nfunction renderCircle(brush, at, current, bounds) {\n    const widths = circleWidth(), radius = (bounds.width + bounds.height) / (4 * Math.max(bounds.width, bounds.height));\n    return setAttributes(createElement('circle'), {\n        stroke: brush.color,\n        'stroke-width': widths[current ? 0 : 1],\n        fill: 'none',\n        opacity: opacity(brush, current),\n        cx: at[0],\n        cy: at[1],\n        r: radius - widths[1] / 2,\n    });\n}\nfunction hilite(brush) {\n    return ['#ffffff', '#fff', 'white'].includes(brush.color)\n        ? hilites['hilitePrimary']\n        : hilites['hiliteWhite'];\n}\nfunction renderArrow(s, brush, from, to, current, shorten) {\n    var _a;\n    function renderLine(isHilite) {\n        var _a;\n        const m = arrowMargin(shorten && !current), dx = to[0] - from[0], dy = to[1] - from[1], angle = Math.atan2(dy, dx), xo = Math.cos(angle) * m, yo = Math.sin(angle) * m;\n        return setAttributes(createElement('line'), {\n            stroke: isHilite ? hilite(brush).color : brush.color,\n            'stroke-width': lineWidth(brush, current) + (isHilite ? 0.04 : 0),\n            'stroke-linecap': 'round',\n            'marker-end': `url(#arrowhead-${isHilite ? hilite(brush).key : brush.key})`,\n            opacity: ((_a = s.modifiers) === null || _a === void 0 ? void 0 : _a.hilite) ? 1 : opacity(brush, current),\n            x1: from[0],\n            y1: from[1],\n            x2: to[0] - xo,\n            y2: to[1] - yo,\n        });\n    }\n    if (!((_a = s.modifiers) === null || _a === void 0 ? void 0 : _a.hilite))\n        return renderLine(false);\n    const g = createElement('g');\n    const blurred = setAttributes(createElement('g'), { filter: 'url(#cg-filter-blur)' });\n    blurred.appendChild(filterBox(from, to));\n    blurred.appendChild(renderLine(true));\n    g.appendChild(blurred);\n    g.appendChild(renderLine(false));\n    return g;\n}\nfunction renderMarker(brush) {\n    const marker = setAttributes(createElement('marker'), {\n        id: 'arrowhead-' + brush.key,\n        orient: 'auto',\n        overflow: 'visible',\n        markerWidth: 4,\n        markerHeight: 4,\n        refX: brush.key.startsWith('hilite') ? 1.86 : 2.05,\n        refY: 2,\n    });\n    marker.appendChild(setAttributes(createElement('path'), {\n        d: 'M0,0 V4 L3,2 Z',\n        fill: brush.color,\n    }));\n    marker.setAttribute('cgKey', brush.key);\n    return marker;\n}\nfunction renderLabel(label, hash, from, to, slots, corner) {\n    var _a;\n    const labelSize = 0.4, fontSize = labelSize * 0.75 ** label.text.length, at = labelCoords(from, to, slots), cornerOff = corner === 'tr' ? 0.4 : 0, g = setAttributes(createElement('g'), {\n        transform: `translate(${at[0] + cornerOff},${at[1] - cornerOff})`,\n        cgHash: hash,\n    });\n    g.appendChild(setAttributes(createElement('circle'), {\n        r: labelSize / 2,\n        'fill-opacity': corner ? 1.0 : 0.8,\n        'stroke-opacity': corner ? 1.0 : 0.7,\n        'stroke-width': 0.03,\n        fill: (_a = label.fill) !== null && _a !== void 0 ? _a : '#666',\n        stroke: 'white',\n    }));\n    const labelEl = setAttributes(createElement('text'), {\n        'font-size': fontSize,\n        'font-family': 'Noto Sans',\n        'text-anchor': 'middle',\n        fill: 'white',\n        y: 0.13 * 0.75 ** label.text.length,\n    });\n    labelEl.innerHTML = label.text;\n    g.appendChild(labelEl);\n    return g;\n}\nfunction orient(pos, color) {\n    return color === 'white' ? pos : [7 - pos[0], 7 - pos[1]];\n}\nfunction isShort(dest, dests) {\n    return true === (dest && dests.has(dest) && dests.get(dest).size > 1);\n}\nfunction createElement(tagName) {\n    return document.createElementNS('http://www.w3.org/2000/svg', tagName);\n}\nfunction setAttributes(el, attrs) {\n    for (const key in attrs) {\n        if (Object.prototype.hasOwnProperty.call(attrs, key))\n            el.setAttribute(key, attrs[key]);\n    }\n    return el;\n}\nfunction makeCustomBrush(base, modifiers) {\n    return !modifiers\n        ? base\n        : {\n            color: base.color,\n            opacity: Math.round(base.opacity * 10) / 10,\n            lineWidth: Math.round(modifiers.lineWidth || base.lineWidth),\n            key: [base.key, modifiers.lineWidth].filter(x => x).join(''),\n        };\n}\nfunction circleWidth() {\n    return [3 / 64, 4 / 64];\n}\nfunction lineWidth(brush, current) {\n    return ((brush.lineWidth || 10) * (current ? 0.85 : 1)) / 64;\n}\nfunction opacity(brush, current) {\n    return (brush.opacity || 1) * (current ? 0.9 : 1);\n}\nfunction arrowMargin(shorten) {\n    return (shorten ? 20 : 10) / 64;\n}\nfunction pos2user(pos, bounds) {\n    const xScale = Math.min(1, bounds.width / bounds.height);\n    const yScale = Math.min(1, bounds.height / bounds.width);\n    return [(pos[0] - 3.5) * xScale, (3.5 - pos[1]) * yScale];\n}\nfunction filterBox(from, to) {\n    // lines/arrows are considered to be one dimensional for the purposes of SVG filters,\n    // so we add a transparent bounding box to ensure they apply to the 2nd dimension\n    const box = {\n        from: [Math.floor(Math.min(from[0], to[0])), Math.floor(Math.min(from[1], to[1]))],\n        to: [Math.ceil(Math.max(from[0], to[0])), Math.ceil(Math.max(from[1], to[1]))],\n    };\n    return setAttributes(createElement('rect'), {\n        x: box.from[0],\n        y: box.from[1],\n        width: box.to[0] - box.from[0],\n        height: box.to[1] - box.from[1],\n        fill: 'none',\n        stroke: 'none',\n    });\n}\nfunction moveAngle(from, to, asSlot = true) {\n    const angle = Math.atan2(to[1] - from[1], to[0] - from[0]) + Math.PI;\n    return asSlot ? (Math.round((angle * 8) / Math.PI) + 16) % 16 : angle;\n}\nfunction dist(from, to) {\n    return Math.sqrt([from[0] - to[0], from[1] - to[1]].reduce((acc, x) => acc + x * x, 0));\n}\n/*\n try to place label at the junction of the destination shaft and arrowhead. if there's more than\n 1 arrow pointing to a square, the arrow shortens by 10 / 64 units so the label must move as well.\n \n if the angle between two incoming arrows is pi / 8, such as when an adjacent knight and bishop\n attack the same square, the knight's label is slid further down the shaft by an amount equal to\n our label size to avoid collision\n*/\nfunction labelCoords(from, to, slots) {\n    let mag = dist(from, to);\n    //if (mag === 0) return [from[0], from[1]];\n    const angle = moveAngle(from, to, false);\n    if (slots) {\n        mag -= 33 / 64; // reduce by arrowhead length\n        if (slots.size > 1) {\n            mag -= 10 / 64; // reduce by shortening factor\n            const slot = moveAngle(from, to);\n            if (slots.has((slot + 1) % 16) || slots.has((slot + 15) % 16)) {\n                if (slot & 1)\n                    mag -= 0.4;\n                // and by label size for the knight if another arrow is within pi / 8.\n            }\n        }\n    }\n    return [from[0] - Math.cos(angle) * mag, from[1] - Math.sin(angle) * mag].map(c => c + 0.5);\n}\n//# sourceMappingURL=svg.js.map","import { State } from './state.js';\nimport { key2pos } from './util.js';\nimport { Drawable, DrawShape, DrawShapePiece, DrawBrush, DrawBrushes, DrawModifiers } from './draw.js';\nimport { SyncableShape, Hash } from './sync.js';\nimport * as cg from './types.js';\n\ntype CustomBrushes = Map<string, DrawBrush>; // by hash\ntype Svg = { el: SVGElement; isCustom?: boolean };\ntype AngleSlots = Set<number>; // arrow angle slots for label positioning\ntype ArrowDests = Map<cg.Key | undefined, AngleSlots>; // angle slots per dest\n\nconst hilites: { [name: string]: DrawBrush } = {\n  hilitePrimary: { key: 'hilitePrimary', color: '#3291ff', opacity: 1, lineWidth: 1 },\n  hiliteWhite: { key: 'hiliteWhite', color: '#ffffff', opacity: 1, lineWidth: 1 },\n};\n\nexport { createElement, setAttributes };\n\nexport function createDefs(): Element {\n  const defs = createElement('defs');\n  const filter = setAttributes(createElement('filter'), { id: 'cg-filter-blur' });\n  filter.appendChild(setAttributes(createElement('feGaussianBlur'), { stdDeviation: '0.019' }));\n  defs.appendChild(filter);\n  return defs;\n}\n\nexport function renderSvg(state: State, shapesEl: SVGElement, customsEl: SVGElement): void {\n  const d = state.drawable,\n    curD = d.current,\n    cur = curD && curD.mouseSq ? (curD as DrawShape) : undefined,\n    dests: ArrowDests = new Map(),\n    bounds = state.dom.bounds(),\n    nonPieceAutoShapes = d.autoShapes.filter(autoShape => !autoShape.piece);\n\n  for (const s of d.shapes.concat(nonPieceAutoShapes).concat(cur ? [cur] : [])) {\n    if (!s.dest) continue;\n    const sources = dests.get(s.dest) ?? new Set(),\n      from = pos2user(orient(key2pos(s.orig), state.orientation), bounds),\n      to = pos2user(orient(key2pos(s.dest), state.orientation), bounds);\n    sources.add(moveAngle(from, to));\n    dests.set(s.dest, sources);\n  }\n  const shapes: SyncableShape[] = d.shapes.concat(nonPieceAutoShapes).map((s: DrawShape) => {\n    return {\n      shape: s,\n      current: false,\n      hash: shapeHash(s, isShort(s.dest, dests), false, bounds),\n    };\n  });\n  if (cur)\n    shapes.push({\n      shape: cur,\n      current: true,\n      hash: shapeHash(cur, isShort(cur.dest, dests), true, bounds),\n    });\n\n  const fullHash = shapes.map(sc => sc.hash).join(';');\n  if (fullHash === state.drawable.prevSvgHash) return;\n  state.drawable.prevSvgHash = fullHash;\n\n  /*\n    -- DOM hierarchy --\n    <svg class=\"cg-shapes\">      (<= svg)\n      <defs>\n        ...(for brushes)...\n      </defs>\n      <g>\n        ...(for arrows and circles)...\n      </g>\n    </svg>\n    <svg class=\"cg-custom-svgs\"> (<= customSvg)\n      <g>\n        ...(for custom svgs)...\n      </g>\n    </svg>\n  */\n\n  const defsEl = shapesEl.querySelector('defs') as SVGElement;\n\n  syncDefs(d, shapes, defsEl);\n  syncShapes(shapes, shapesEl.querySelector('g')!, customsEl.querySelector('g')!, s =>\n    renderShape(state, s, d.brushes, dests, bounds),\n  );\n}\n\n// append only. Don't try to update/remove.\nfunction syncDefs(d: Drawable, shapes: SyncableShape[], defsEl: SVGElement) {\n  const brushes: CustomBrushes = new Map();\n  let brush: DrawBrush;\n  for (const s of shapes.filter(s => s.shape.dest && s.shape.brush)) {\n    brush = makeCustomBrush(d.brushes[s.shape.brush!], s.shape.modifiers);\n    if (s.shape.modifiers?.hilite) brushes.set(hilite(brush).key, hilite(brush));\n    brushes.set(brush.key, brush);\n  }\n  const keysInDom = new Set();\n  let el: SVGElement | undefined = defsEl.firstElementChild as SVGElement;\n  while (el) {\n    keysInDom.add(el.getAttribute('cgKey'));\n    el = el.nextElementSibling as SVGElement | undefined;\n  }\n  for (const [key, brush] of brushes.entries()) {\n    if (!keysInDom.has(key)) defsEl.appendChild(renderMarker(brush));\n  }\n}\n\nfunction syncShapes(\n  syncables: SyncableShape[],\n  shapes: Element,\n  customs: Element,\n  renderShape: (shape: SyncableShape) => Svg[],\n): void {\n  const hashesInDom = new Map();\n\n  for (const sc of syncables) hashesInDom.set(sc.hash, false);\n  for (const root of [shapes, customs]) {\n    const toRemove: SVGElement[] = [];\n    let el: SVGElement | undefined = root.firstElementChild as SVGElement,\n      elHash: Hash | null;\n    while (el) {\n      elHash = el.getAttribute('cgHash') as Hash;\n      if (hashesInDom.has(elHash)) hashesInDom.set(elHash, true);\n      else toRemove.push(el);\n      el = el.nextElementSibling as SVGElement | undefined;\n    }\n    for (const el of toRemove) root.removeChild(el);\n  }\n  // insert shapes that are not yet in dom\n  for (const sc of syncables.filter(s => !hashesInDom.get(s.hash))) {\n    for (const svg of renderShape(sc)) {\n      if (svg.isCustom) customs.appendChild(svg.el);\n      else shapes.appendChild(svg.el);\n    }\n  }\n}\n\nfunction shapeHash(\n  { orig, dest, brush, piece, modifiers, customSvg, label }: DrawShape,\n  shorten: boolean,\n  current: boolean,\n  bounds: DOMRectReadOnly,\n): Hash {\n  // a shape and an overlay svg share a lifetime and have the same cgHash attribute\n  return [\n    bounds.width,\n    bounds.height,\n    current,\n    orig,\n    dest,\n    brush,\n    shorten && '-',\n    piece && pieceHash(piece),\n    modifiers && modifiersHash(modifiers),\n    customSvg && `custom-${textHash(customSvg.html)},${customSvg.center?.[0] ?? 'o'}`,\n    label && `label-${textHash(label.text)}`,\n  ]\n    .filter(x => x)\n    .join(',');\n}\n\nfunction pieceHash(piece: DrawShapePiece): Hash {\n  return [piece.color, piece.role, piece.scale].filter(x => x).join(',');\n}\n\nfunction modifiersHash(m: DrawModifiers): Hash {\n  return [m.lineWidth, m.hilite && '*'].filter(x => x).join(',');\n}\n\nfunction textHash(s: string): Hash {\n  // Rolling hash with base 31 (cf. https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript)\n  let h = 0;\n  for (let i = 0; i < s.length; i++) {\n    h = ((h << 5) - h + s.charCodeAt(i)) >>> 0;\n  }\n  return h.toString();\n}\n\nfunction renderShape(\n  state: State,\n  { shape, current, hash }: SyncableShape,\n  brushes: DrawBrushes,\n  dests: ArrowDests,\n  bounds: DOMRectReadOnly,\n): Svg[] {\n  const from = pos2user(orient(key2pos(shape.orig), state.orientation), bounds),\n    to = shape.dest ? pos2user(orient(key2pos(shape.dest), state.orientation), bounds) : from,\n    brush = shape.brush && makeCustomBrush(brushes[shape.brush], shape.modifiers),\n    slots = dests.get(shape.dest),\n    svgs: Svg[] = [];\n\n  if (brush) {\n    const el = setAttributes(createElement('g'), { cgHash: hash });\n    svgs.push({ el });\n\n    if (from[0] !== to[0] || from[1] !== to[1])\n      el.appendChild(renderArrow(shape, brush, from, to, current, isShort(shape.dest, dests)));\n    else el.appendChild(renderCircle(brushes[shape.brush!], from, current, bounds));\n  }\n  if (shape.label) {\n    const label = shape.label;\n    label.fill ??= shape.brush && brushes[shape.brush].color;\n    const corner = shape.brush ? undefined : 'tr';\n    svgs.push({ el: renderLabel(label, hash, from, to, slots, corner), isCustom: true });\n  }\n  if (shape.customSvg) {\n    const on = shape.customSvg.center ?? 'orig';\n    const [x, y] =\n      on === 'label' ? labelCoords(from, to, slots).map(c => c - 0.5) : on === 'dest' ? to : from;\n    const el = setAttributes(createElement('g'), { transform: `translate(${x},${y})`, cgHash: hash });\n    el.innerHTML = `<svg width=\"1\" height=\"1\" viewBox=\"0 0 100 100\">${shape.customSvg.html}</svg>`;\n    svgs.push({ el, isCustom: true });\n  }\n  return svgs;\n}\n\nfunction renderCircle(\n  brush: DrawBrush,\n  at: cg.NumberPair,\n  current: boolean,\n  bounds: DOMRectReadOnly,\n): SVGElement {\n  const widths = circleWidth(),\n    radius = (bounds.width + bounds.height) / (4 * Math.max(bounds.width, bounds.height));\n  return setAttributes(createElement('circle'), {\n    stroke: brush.color,\n    'stroke-width': widths[current ? 0 : 1],\n    fill: 'none',\n    opacity: opacity(brush, current),\n    cx: at[0],\n    cy: at[1],\n    r: radius - widths[1] / 2,\n  });\n}\n\nfunction hilite(brush: DrawBrush): DrawBrush {\n  return ['#ffffff', '#fff', 'white'].includes(brush.color)\n    ? hilites['hilitePrimary']\n    : hilites['hiliteWhite'];\n}\n\nfunction renderArrow(\n  s: DrawShape,\n  brush: DrawBrush,\n  from: cg.NumberPair,\n  to: cg.NumberPair,\n  current: boolean,\n  shorten: boolean,\n): SVGElement {\n  function renderLine(isHilite: boolean) {\n    const m = arrowMargin(shorten && !current),\n      dx = to[0] - from[0],\n      dy = to[1] - from[1],\n      angle = Math.atan2(dy, dx),\n      xo = Math.cos(angle) * m,\n      yo = Math.sin(angle) * m;\n    return setAttributes(createElement('line'), {\n      stroke: isHilite ? hilite(brush).color : brush.color,\n      'stroke-width': lineWidth(brush, current) + (isHilite ? 0.04 : 0),\n      'stroke-linecap': 'round',\n      'marker-end': `url(#arrowhead-${isHilite ? hilite(brush).key : brush.key})`,\n      opacity: s.modifiers?.hilite ? 1 : opacity(brush, current),\n      x1: from[0],\n      y1: from[1],\n      x2: to[0] - xo,\n      y2: to[1] - yo,\n    });\n  }\n  if (!s.modifiers?.hilite) return renderLine(false);\n\n  const g = createElement('g');\n  const blurred = setAttributes(createElement('g'), { filter: 'url(#cg-filter-blur)' });\n  blurred.appendChild(filterBox(from, to));\n  blurred.appendChild(renderLine(true));\n  g.appendChild(blurred);\n  g.appendChild(renderLine(false));\n  return g;\n}\n\nfunction renderMarker(brush: DrawBrush): SVGElement {\n  const marker = setAttributes(createElement('marker'), {\n    id: 'arrowhead-' + brush.key,\n    orient: 'auto',\n    overflow: 'visible',\n    markerWidth: 4,\n    markerHeight: 4,\n    refX: brush.key.startsWith('hilite') ? 1.86 : 2.05,\n    refY: 2,\n  });\n  marker.appendChild(\n    setAttributes(createElement('path'), {\n      d: 'M0,0 V4 L3,2 Z',\n      fill: brush.color,\n    }),\n  );\n  marker.setAttribute('cgKey', brush.key);\n  return marker;\n}\n\nfunction renderLabel(\n  label: { text: string; fill?: string },\n  hash: string,\n  from: cg.NumberPair,\n  to: cg.NumberPair,\n  slots?: AngleSlots,\n  corner?: 'tr',\n): SVGElement {\n  const labelSize = 0.4,\n    fontSize = labelSize * 0.75 ** label.text.length,\n    at = labelCoords(from, to, slots),\n    cornerOff = corner === 'tr' ? 0.4 : 0,\n    g = setAttributes(createElement('g'), {\n      transform: `translate(${at[0] + cornerOff},${at[1] - cornerOff})`,\n      cgHash: hash,\n    });\n  g.appendChild(\n    setAttributes(createElement('circle'), {\n      r: labelSize / 2,\n      'fill-opacity': corner ? 1.0 : 0.8,\n      'stroke-opacity': corner ? 1.0 : 0.7,\n      'stroke-width': 0.03,\n      fill: label.fill ?? '#666',\n      stroke: 'white',\n    }),\n  );\n  const labelEl = setAttributes(createElement('text'), {\n    'font-size': fontSize,\n    'font-family': 'Noto Sans',\n    'text-anchor': 'middle',\n    fill: 'white',\n    y: 0.13 * 0.75 ** label.text.length,\n  });\n  labelEl.innerHTML = label.text;\n  g.appendChild(labelEl);\n  return g;\n}\n\nfunction orient(pos: cg.Pos, color: cg.Color): cg.Pos {\n  return color === 'white' ? pos : [7 - pos[0], 7 - pos[1]];\n}\n\nfunction isShort(dest: cg.Key | undefined, dests: ArrowDests) {\n  return true === (dest && dests.has(dest) && dests.get(dest)!.size > 1);\n}\n\nfunction createElement(tagName: string): SVGElement {\n  return document.createElementNS('http://www.w3.org/2000/svg', tagName);\n}\n\nfunction setAttributes(el: SVGElement, attrs: { [key: string]: any }): SVGElement {\n  for (const key in attrs) {\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) el.setAttribute(key, attrs[key]);\n  }\n  return el;\n}\n\nfunction makeCustomBrush(base: DrawBrush, modifiers: DrawModifiers | undefined): DrawBrush {\n  return !modifiers\n    ? base\n    : {\n        color: base.color,\n        opacity: Math.round(base.opacity * 10) / 10,\n        lineWidth: Math.round(modifiers.lineWidth || base.lineWidth),\n        key: [base.key, modifiers.lineWidth].filter(x => x).join(''),\n      };\n}\n\nfunction circleWidth(): [number, number] {\n  return [3 / 64, 4 / 64];\n}\n\nfunction lineWidth(brush: DrawBrush, current: boolean): number {\n  return ((brush.lineWidth || 10) * (current ? 0.85 : 1)) / 64;\n}\n\nfunction opacity(brush: DrawBrush, current: boolean): number {\n  return (brush.opacity || 1) * (current ? 0.9 : 1);\n}\n\nfunction arrowMargin(shorten: boolean): number {\n  return (shorten ? 20 : 10) / 64;\n}\n\nfunction pos2user(pos: cg.Pos, bounds: DOMRectReadOnly): cg.NumberPair {\n  const xScale = Math.min(1, bounds.width / bounds.height);\n  const yScale = Math.min(1, bounds.height / bounds.width);\n  return [(pos[0] - 3.5) * xScale, (3.5 - pos[1]) * yScale];\n}\n\nfunction filterBox(from: cg.NumberPair, to: cg.NumberPair): SVGElement {\n  // lines/arrows are considered to be one dimensional for the purposes of SVG filters,\n  // so we add a transparent bounding box to ensure they apply to the 2nd dimension\n  const box = {\n    from: [Math.floor(Math.min(from[0], to[0])), Math.floor(Math.min(from[1], to[1]))],\n    to: [Math.ceil(Math.max(from[0], to[0])), Math.ceil(Math.max(from[1], to[1]))],\n  };\n  return setAttributes(createElement('rect'), {\n    x: box.from[0],\n    y: box.from[1],\n    width: box.to[0] - box.from[0],\n    height: box.to[1] - box.from[1],\n    fill: 'none',\n    stroke: 'none',\n  });\n}\n\nfunction moveAngle(from: cg.NumberPair, to: cg.NumberPair, asSlot = true) {\n  const angle = Math.atan2(to[1] - from[1], to[0] - from[0]) + Math.PI;\n  return asSlot ? (Math.round((angle * 8) / Math.PI) + 16) % 16 : angle;\n}\n\nfunction dist(from: cg.NumberPair, to: cg.NumberPair): number {\n  return Math.sqrt([from[0] - to[0], from[1] - to[1]].reduce((acc, x) => acc + x * x, 0));\n}\n\n/*\n try to place label at the junction of the destination shaft and arrowhead. if there's more than\n 1 arrow pointing to a square, the arrow shortens by 10 / 64 units so the label must move as well. \n \n if the angle between two incoming arrows is pi / 8, such as when an adjacent knight and bishop\n attack the same square, the knight's label is slid further down the shaft by an amount equal to\n our label size to avoid collision\n*/\n\nfunction labelCoords(from: cg.NumberPair, to: cg.NumberPair, slots?: AngleSlots): cg.NumberPair {\n  let mag = dist(from, to);\n  //if (mag === 0) return [from[0], from[1]];\n  const angle = moveAngle(from, to, false);\n  if (slots) {\n    mag -= 33 / 64; // reduce by arrowhead length\n    if (slots.size > 1) {\n      mag -= 10 / 64; // reduce by shortening factor\n      const slot = moveAngle(from, to);\n      if (slots.has((slot + 1) % 16) || slots.has((slot + 15) % 16)) {\n        if (slot & 1) mag -= 0.4;\n        // and by label size for the knight if another arrow is within pi / 8.\n      }\n    }\n  }\n  return [from[0] - Math.cos(angle) * mag, from[1] - Math.sin(angle) * mag].map(\n    c => c + 0.5,\n  ) as cg.NumberPair;\n}\n","import * as drag from './drag.js';\nimport * as draw from './draw.js';\nimport { drop } from './drop.js';\nimport { isRightButton } from './util.js';\nexport function bindBoard(s, onResize) {\n    const boardEl = s.dom.elements.board;\n    if ('ResizeObserver' in window)\n        new ResizeObserver(onResize).observe(s.dom.elements.wrap);\n    if (s.disableContextMenu || s.drawable.enabled) {\n        boardEl.addEventListener('contextmenu', e => e.preventDefault());\n    }\n    if (s.viewOnly)\n        return;\n    // Cannot be passive, because we prevent touch scrolling and dragging of\n    // selected elements.\n    const onStart = startDragOrDraw(s);\n    boardEl.addEventListener('touchstart', onStart, {\n        passive: false,\n    });\n    boardEl.addEventListener('mousedown', onStart, {\n        passive: false,\n    });\n}\n// returns the unbind function\nexport function bindDocument(s, onResize) {\n    const unbinds = [];\n    // Old versions of Edge and Safari do not support ResizeObserver. Send\n    // chessground.resize if a user action has changed the bounds of the board.\n    if (!('ResizeObserver' in window))\n        unbinds.push(unbindable(document.body, 'chessground.resize', onResize));\n    if (!s.viewOnly) {\n        const onmove = dragOrDraw(s, drag.move, draw.move);\n        const onend = dragOrDraw(s, drag.end, draw.end);\n        for (const ev of ['touchmove', 'mousemove'])\n            unbinds.push(unbindable(document, ev, onmove));\n        for (const ev of ['touchend', 'mouseup'])\n            unbinds.push(unbindable(document, ev, onend));\n        const onScroll = () => s.dom.bounds.clear();\n        unbinds.push(unbindable(document, 'scroll', onScroll, { capture: true, passive: true }));\n        unbinds.push(unbindable(window, 'resize', onScroll, { passive: true }));\n    }\n    return () => unbinds.forEach(f => f());\n}\nfunction unbindable(el, eventName, callback, options) {\n    el.addEventListener(eventName, callback, options);\n    return () => el.removeEventListener(eventName, callback, options);\n}\nconst startDragOrDraw = (s) => e => {\n    if (s.draggable.current)\n        drag.cancel(s);\n    else if (s.drawable.current)\n        draw.cancel(s);\n    else if (e.shiftKey || isRightButton(e)) {\n        if (s.drawable.enabled)\n            draw.start(s, e);\n    }\n    else if (!s.viewOnly) {\n        if (s.dropmode.active)\n            drop(s, e);\n        else\n            drag.start(s, e);\n    }\n};\nconst dragOrDraw = (s, withDrag, withDraw) => e => {\n    if (s.drawable.current) {\n        if (s.drawable.enabled)\n            withDraw(s, e);\n    }\n    else if (!s.viewOnly)\n        withDrag(s, e);\n};\n//# sourceMappingURL=events.js.map","import { State } from './state.js';\nimport * as drag from './drag.js';\nimport * as draw from './draw.js';\nimport { drop } from './drop.js';\nimport { isRightButton } from './util.js';\nimport * as cg from './types.js';\n\ntype MouchBind = (e: cg.MouchEvent) => void;\ntype StateMouchBind = (d: State, e: cg.MouchEvent) => void;\n\nexport function bindBoard(s: State, onResize: () => void): void {\n  const boardEl = s.dom.elements.board;\n\n  if ('ResizeObserver' in window) new ResizeObserver(onResize).observe(s.dom.elements.wrap);\n\n  if (s.disableContextMenu || s.drawable.enabled) {\n    boardEl.addEventListener('contextmenu', e => e.preventDefault());\n  }\n\n  if (s.viewOnly) return;\n\n  // Cannot be passive, because we prevent touch scrolling and dragging of\n  // selected elements.\n  const onStart = startDragOrDraw(s);\n  boardEl.addEventListener('touchstart', onStart as EventListener, {\n    passive: false,\n  });\n  boardEl.addEventListener('mousedown', onStart as EventListener, {\n    passive: false,\n  });\n}\n\n// returns the unbind function\nexport function bindDocument(s: State, onResize: () => void): cg.Unbind {\n  const unbinds: cg.Unbind[] = [];\n\n  // Old versions of Edge and Safari do not support ResizeObserver. Send\n  // chessground.resize if a user action has changed the bounds of the board.\n  if (!('ResizeObserver' in window)) unbinds.push(unbindable(document.body, 'chessground.resize', onResize));\n\n  if (!s.viewOnly) {\n    const onmove = dragOrDraw(s, drag.move, draw.move);\n    const onend = dragOrDraw(s, drag.end, draw.end);\n\n    for (const ev of ['touchmove', 'mousemove'])\n      unbinds.push(unbindable(document, ev, onmove as EventListener));\n    for (const ev of ['touchend', 'mouseup']) unbinds.push(unbindable(document, ev, onend as EventListener));\n\n    const onScroll = () => s.dom.bounds.clear();\n    unbinds.push(unbindable(document, 'scroll', onScroll, { capture: true, passive: true }));\n    unbinds.push(unbindable(window, 'resize', onScroll, { passive: true }));\n  }\n\n  return () => unbinds.forEach(f => f());\n}\n\nfunction unbindable(\n  el: EventTarget,\n  eventName: string,\n  callback: EventListener,\n  options?: AddEventListenerOptions,\n): cg.Unbind {\n  el.addEventListener(eventName, callback, options);\n  return () => el.removeEventListener(eventName, callback, options);\n}\n\nconst startDragOrDraw =\n  (s: State): MouchBind =>\n  e => {\n    if (s.draggable.current) drag.cancel(s);\n    else if (s.drawable.current) draw.cancel(s);\n    else if (e.shiftKey || isRightButton(e)) {\n      if (s.drawable.enabled) draw.start(s, e);\n    } else if (!s.viewOnly) {\n      if (s.dropmode.active) drop(s, e);\n      else drag.start(s, e);\n    }\n  };\n\nconst dragOrDraw =\n  (s: State, withDrag: StateMouchBind, withDraw: StateMouchBind): MouchBind =>\n  e => {\n    if (s.drawable.current) {\n      if (s.drawable.enabled) withDraw(s, e);\n    } else if (!s.viewOnly) withDrag(s, e);\n  };\n","import * as board from './board.js';\nimport * as util from './util.js';\nimport { cancel as dragCancel } from './drag.js';\nexport function setDropMode(s, piece) {\n    s.dropmode = {\n        active: true,\n        piece,\n    };\n    dragCancel(s);\n}\nexport function cancelDropMode(s) {\n    s.dropmode = {\n        active: false,\n    };\n}\nexport function drop(s, e) {\n    if (!s.dropmode.active)\n        return;\n    board.unsetPremove(s);\n    board.unsetPredrop(s);\n    const piece = s.dropmode.piece;\n    if (piece) {\n        s.pieces.set('a0', piece);\n        const position = util.eventPosition(e);\n        const dest = position && board.getKeyAtDomPos(position, board.whitePov(s), s.dom.bounds());\n        if (dest)\n            board.dropNewPiece(s, 'a0', dest);\n    }\n    s.dom.redraw();\n}\n//# sourceMappingURL=drop.js.map","import { State } from './state.js';\nimport * as cg from './types.js';\nimport * as board from './board.js';\nimport * as util from './util.js';\nimport { cancel as dragCancel } from './drag.js';\n\nexport function setDropMode(s: State, piece?: cg.Piece): void {\n  s.dropmode = {\n    active: true,\n    piece,\n  };\n  dragCancel(s);\n}\n\nexport function cancelDropMode(s: State): void {\n  s.dropmode = {\n    active: false,\n  };\n}\n\nexport function drop(s: State, e: cg.MouchEvent): void {\n  if (!s.dropmode.active) return;\n\n  board.unsetPremove(s);\n  board.unsetPredrop(s);\n\n  const piece = s.dropmode.piece;\n\n  if (piece) {\n    s.pieces.set('a0', piece);\n    const position = util.eventPosition(e);\n    const dest = position && board.getKeyAtDomPos(position, board.whitePov(s), s.dom.bounds());\n    if (dest) board.dropNewPiece(s, 'a0', dest);\n  }\n  s.dom.redraw();\n}\n","import { key2pos, createEl, posToTranslate as posToTranslateFromBounds, translate } from './util.js';\nimport { whitePov } from './board.js';\n// ported from https://github.com/lichess-org/lichobile/blob/master/src/chessground/render.ts\n// in case of bugs, blame @veloce\nexport function render(s) {\n    const asWhite = whitePov(s), posToTranslate = posToTranslateFromBounds(s.dom.bounds()), boardEl = s.dom.elements.board, pieces = s.pieces, curAnim = s.animation.current, anims = curAnim ? curAnim.plan.anims : new Map(), fadings = curAnim ? curAnim.plan.fadings : new Map(), curDrag = s.draggable.current, squares = computeSquareClasses(s), samePieces = new Set(), sameSquares = new Set(), movedPieces = new Map(), movedSquares = new Map(); // by class name\n    let k, el, pieceAtKey, elPieceName, anim, fading, pMvdset, pMvd, sMvdset, sMvd;\n    // walk over all board dom elements, apply animations and flag moved pieces\n    el = boardEl.firstChild;\n    while (el) {\n        k = el.cgKey;\n        if (isPieceNode(el)) {\n            pieceAtKey = pieces.get(k);\n            anim = anims.get(k);\n            fading = fadings.get(k);\n            elPieceName = el.cgPiece;\n            // if piece not being dragged anymore, remove dragging style\n            if (el.cgDragging && (!curDrag || curDrag.orig !== k)) {\n                el.classList.remove('dragging');\n                translate(el, posToTranslate(key2pos(k), asWhite));\n                el.cgDragging = false;\n            }\n            // remove fading class if it still remains\n            if (!fading && el.cgFading) {\n                el.cgFading = false;\n                el.classList.remove('fading');\n            }\n            // there is now a piece at this dom key\n            if (pieceAtKey) {\n                // continue animation if already animating and same piece\n                // (otherwise it could animate a captured piece)\n                if (anim && el.cgAnimating && elPieceName === pieceNameOf(pieceAtKey)) {\n                    const pos = key2pos(k);\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                    el.classList.add('anim');\n                    translate(el, posToTranslate(pos, asWhite));\n                }\n                else if (el.cgAnimating) {\n                    el.cgAnimating = false;\n                    el.classList.remove('anim');\n                    translate(el, posToTranslate(key2pos(k), asWhite));\n                    if (s.addPieceZIndex)\n                        el.style.zIndex = posZIndex(key2pos(k), asWhite);\n                }\n                // same piece: flag as same\n                if (elPieceName === pieceNameOf(pieceAtKey) && (!fading || !el.cgFading)) {\n                    samePieces.add(k);\n                }\n                // different piece: flag as moved unless it is a fading piece\n                else {\n                    if (fading && elPieceName === pieceNameOf(fading)) {\n                        el.classList.add('fading');\n                        el.cgFading = true;\n                    }\n                    else {\n                        appendValue(movedPieces, elPieceName, el);\n                    }\n                }\n            }\n            // no piece: flag as moved\n            else {\n                appendValue(movedPieces, elPieceName, el);\n            }\n        }\n        else if (isSquareNode(el)) {\n            const cn = el.className;\n            if (squares.get(k) === cn)\n                sameSquares.add(k);\n            else\n                appendValue(movedSquares, cn, el);\n        }\n        el = el.nextSibling;\n    }\n    // walk over all squares in current set, apply dom changes to moved squares\n    // or append new squares\n    for (const [sk, className] of squares) {\n        if (!sameSquares.has(sk)) {\n            sMvdset = movedSquares.get(className);\n            sMvd = sMvdset && sMvdset.pop();\n            const translation = posToTranslate(key2pos(sk), asWhite);\n            if (sMvd) {\n                sMvd.cgKey = sk;\n                translate(sMvd, translation);\n            }\n            else {\n                const squareNode = createEl('square', className);\n                squareNode.cgKey = sk;\n                translate(squareNode, translation);\n                boardEl.insertBefore(squareNode, boardEl.firstChild);\n            }\n        }\n    }\n    // walk over all pieces in current set, apply dom changes to moved pieces\n    // or append new pieces\n    for (const [k, p] of pieces) {\n        anim = anims.get(k);\n        if (!samePieces.has(k)) {\n            pMvdset = movedPieces.get(pieceNameOf(p));\n            pMvd = pMvdset && pMvdset.pop();\n            // a same piece was moved\n            if (pMvd) {\n                // apply dom changes\n                pMvd.cgKey = k;\n                if (pMvd.cgFading) {\n                    pMvd.classList.remove('fading');\n                    pMvd.cgFading = false;\n                }\n                const pos = key2pos(k);\n                if (s.addPieceZIndex)\n                    pMvd.style.zIndex = posZIndex(pos, asWhite);\n                if (anim) {\n                    pMvd.cgAnimating = true;\n                    pMvd.classList.add('anim');\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                }\n                translate(pMvd, posToTranslate(pos, asWhite));\n            }\n            // no piece in moved obj: insert the new piece\n            // assumes the new piece is not being dragged\n            else {\n                const pieceName = pieceNameOf(p), pieceNode = createEl('piece', pieceName), pos = key2pos(k);\n                pieceNode.cgPiece = pieceName;\n                pieceNode.cgKey = k;\n                if (anim) {\n                    pieceNode.cgAnimating = true;\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                }\n                translate(pieceNode, posToTranslate(pos, asWhite));\n                if (s.addPieceZIndex)\n                    pieceNode.style.zIndex = posZIndex(pos, asWhite);\n                boardEl.appendChild(pieceNode);\n            }\n        }\n    }\n    // remove any element that remains in the moved sets\n    for (const nodes of movedPieces.values())\n        removeNodes(s, nodes);\n    for (const nodes of movedSquares.values())\n        removeNodes(s, nodes);\n}\nexport function renderResized(s) {\n    const asWhite = whitePov(s), posToTranslate = posToTranslateFromBounds(s.dom.bounds());\n    let el = s.dom.elements.board.firstChild;\n    while (el) {\n        if ((isPieceNode(el) && !el.cgAnimating) || isSquareNode(el)) {\n            translate(el, posToTranslate(key2pos(el.cgKey), asWhite));\n        }\n        el = el.nextSibling;\n    }\n}\nexport function updateBounds(s) {\n    var _a, _b;\n    const bounds = s.dom.elements.wrap.getBoundingClientRect();\n    const container = s.dom.elements.container;\n    const ratio = bounds.height / bounds.width;\n    const width = (Math.floor((bounds.width * window.devicePixelRatio) / 8) * 8) / window.devicePixelRatio;\n    const height = width * ratio;\n    container.style.width = width + 'px';\n    container.style.height = height + 'px';\n    s.dom.bounds.clear();\n    (_a = s.addDimensionsCssVarsTo) === null || _a === void 0 ? void 0 : _a.style.setProperty('---cg-width', width + 'px');\n    (_b = s.addDimensionsCssVarsTo) === null || _b === void 0 ? void 0 : _b.style.setProperty('---cg-height', height + 'px');\n}\nconst isPieceNode = (el) => el.tagName === 'PIECE';\nconst isSquareNode = (el) => el.tagName === 'SQUARE';\nfunction removeNodes(s, nodes) {\n    for (const node of nodes)\n        s.dom.elements.board.removeChild(node);\n}\nfunction posZIndex(pos, asWhite) {\n    const minZ = 3;\n    const rank = pos[1];\n    const z = asWhite ? minZ + 7 - rank : minZ + rank;\n    return `${z}`;\n}\nconst pieceNameOf = (piece) => `${piece.color} ${piece.role}`;\nfunction computeSquareClasses(s) {\n    var _a, _b, _c;\n    const squares = new Map();\n    if (s.lastMove && s.highlight.lastMove)\n        for (const k of s.lastMove) {\n            addSquare(squares, k, 'last-move');\n        }\n    if (s.check && s.highlight.check)\n        addSquare(squares, s.check, 'check');\n    if (s.selected) {\n        addSquare(squares, s.selected, 'selected');\n        if (s.movable.showDests) {\n            const dests = (_a = s.movable.dests) === null || _a === void 0 ? void 0 : _a.get(s.selected);\n            if (dests)\n                for (const k of dests) {\n                    addSquare(squares, k, 'move-dest' + (s.pieces.has(k) ? ' oc' : ''));\n                }\n            const pDests = (_c = (_b = s.premovable.customDests) === null || _b === void 0 ? void 0 : _b.get(s.selected)) !== null && _c !== void 0 ? _c : s.premovable.dests;\n            if (pDests)\n                for (const k of pDests) {\n                    addSquare(squares, k, 'premove-dest' + (s.pieces.has(k) ? ' oc' : ''));\n                }\n        }\n    }\n    const premove = s.premovable.current;\n    if (premove)\n        for (const k of premove)\n            addSquare(squares, k, 'current-premove');\n    else if (s.predroppable.current)\n        addSquare(squares, s.predroppable.current.key, 'current-premove');\n    const o = s.exploding;\n    if (o)\n        for (const k of o.keys)\n            addSquare(squares, k, 'exploding' + o.stage);\n    if (s.highlight.custom) {\n        s.highlight.custom.forEach((v, k) => {\n            addSquare(squares, k, v);\n        });\n    }\n    return squares;\n}\nfunction addSquare(squares, key, klass) {\n    const classes = squares.get(key);\n    if (classes)\n        squares.set(key, `${classes} ${klass}`);\n    else\n        squares.set(key, klass);\n}\nfunction appendValue(map, key, value) {\n    const arr = map.get(key);\n    if (arr)\n        arr.push(value);\n    else\n        map.set(key, [value]);\n}\n//# sourceMappingURL=render.js.map","import { State } from './state.js';\nimport { key2pos, createEl, posToTranslate as posToTranslateFromBounds, translate } from './util.js';\nimport { whitePov } from './board.js';\nimport { AnimCurrent, AnimVectors, AnimVector, AnimFadings } from './anim.js';\nimport { DragCurrent } from './drag.js';\nimport * as cg from './types.js';\n\ntype PieceName = string; // `$color $role`\n\n// ported from https://github.com/lichess-org/lichobile/blob/master/src/chessground/render.ts\n// in case of bugs, blame @veloce\nexport function render(s: State): void {\n  const asWhite: boolean = whitePov(s),\n    posToTranslate = posToTranslateFromBounds(s.dom.bounds()),\n    boardEl: HTMLElement = s.dom.elements.board,\n    pieces: cg.Pieces = s.pieces,\n    curAnim: AnimCurrent | undefined = s.animation.current,\n    anims: AnimVectors = curAnim ? curAnim.plan.anims : new Map(),\n    fadings: AnimFadings = curAnim ? curAnim.plan.fadings : new Map(),\n    curDrag: DragCurrent | undefined = s.draggable.current,\n    squares: cg.SquareClasses = computeSquareClasses(s),\n    samePieces: Set<cg.Key> = new Set(),\n    sameSquares: Set<cg.Key> = new Set(),\n    movedPieces: Map<PieceName, cg.PieceNode[]> = new Map(),\n    movedSquares: Map<string, cg.SquareNode[]> = new Map(); // by class name\n  let k: cg.Key,\n    el: cg.PieceNode | cg.SquareNode | undefined,\n    pieceAtKey: cg.Piece | undefined,\n    elPieceName: PieceName,\n    anim: AnimVector | undefined,\n    fading: cg.Piece | undefined,\n    pMvdset: cg.PieceNode[] | undefined,\n    pMvd: cg.PieceNode | undefined,\n    sMvdset: cg.SquareNode[] | undefined,\n    sMvd: cg.SquareNode | undefined;\n\n  // walk over all board dom elements, apply animations and flag moved pieces\n  el = boardEl.firstChild as cg.PieceNode | cg.SquareNode | undefined;\n  while (el) {\n    k = el.cgKey;\n    if (isPieceNode(el)) {\n      pieceAtKey = pieces.get(k);\n      anim = anims.get(k);\n      fading = fadings.get(k);\n      elPieceName = el.cgPiece;\n      // if piece not being dragged anymore, remove dragging style\n      if (el.cgDragging && (!curDrag || curDrag.orig !== k)) {\n        el.classList.remove('dragging');\n        translate(el, posToTranslate(key2pos(k), asWhite));\n        el.cgDragging = false;\n      }\n      // remove fading class if it still remains\n      if (!fading && el.cgFading) {\n        el.cgFading = false;\n        el.classList.remove('fading');\n      }\n      // there is now a piece at this dom key\n      if (pieceAtKey) {\n        // continue animation if already animating and same piece\n        // (otherwise it could animate a captured piece)\n        if (anim && el.cgAnimating && elPieceName === pieceNameOf(pieceAtKey)) {\n          const pos = key2pos(k);\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n          el.classList.add('anim');\n          translate(el, posToTranslate(pos, asWhite));\n        } else if (el.cgAnimating) {\n          el.cgAnimating = false;\n          el.classList.remove('anim');\n          translate(el, posToTranslate(key2pos(k), asWhite));\n          if (s.addPieceZIndex) el.style.zIndex = posZIndex(key2pos(k), asWhite);\n        }\n        // same piece: flag as same\n        if (elPieceName === pieceNameOf(pieceAtKey) && (!fading || !el.cgFading)) {\n          samePieces.add(k);\n        }\n        // different piece: flag as moved unless it is a fading piece\n        else {\n          if (fading && elPieceName === pieceNameOf(fading)) {\n            el.classList.add('fading');\n            el.cgFading = true;\n          } else {\n            appendValue(movedPieces, elPieceName, el);\n          }\n        }\n      }\n      // no piece: flag as moved\n      else {\n        appendValue(movedPieces, elPieceName, el);\n      }\n    } else if (isSquareNode(el)) {\n      const cn = el.className;\n      if (squares.get(k) === cn) sameSquares.add(k);\n      else appendValue(movedSquares, cn, el);\n    }\n    el = el.nextSibling as cg.PieceNode | cg.SquareNode | undefined;\n  }\n\n  // walk over all squares in current set, apply dom changes to moved squares\n  // or append new squares\n  for (const [sk, className] of squares) {\n    if (!sameSquares.has(sk)) {\n      sMvdset = movedSquares.get(className);\n      sMvd = sMvdset && sMvdset.pop();\n      const translation = posToTranslate(key2pos(sk), asWhite);\n      if (sMvd) {\n        sMvd.cgKey = sk;\n        translate(sMvd, translation);\n      } else {\n        const squareNode = createEl('square', className) as cg.SquareNode;\n        squareNode.cgKey = sk;\n        translate(squareNode, translation);\n        boardEl.insertBefore(squareNode, boardEl.firstChild);\n      }\n    }\n  }\n\n  // walk over all pieces in current set, apply dom changes to moved pieces\n  // or append new pieces\n  for (const [k, p] of pieces) {\n    anim = anims.get(k);\n    if (!samePieces.has(k)) {\n      pMvdset = movedPieces.get(pieceNameOf(p));\n      pMvd = pMvdset && pMvdset.pop();\n      // a same piece was moved\n      if (pMvd) {\n        // apply dom changes\n        pMvd.cgKey = k;\n        if (pMvd.cgFading) {\n          pMvd.classList.remove('fading');\n          pMvd.cgFading = false;\n        }\n        const pos = key2pos(k);\n        if (s.addPieceZIndex) pMvd.style.zIndex = posZIndex(pos, asWhite);\n        if (anim) {\n          pMvd.cgAnimating = true;\n          pMvd.classList.add('anim');\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n        }\n        translate(pMvd, posToTranslate(pos, asWhite));\n      }\n      // no piece in moved obj: insert the new piece\n      // assumes the new piece is not being dragged\n      else {\n        const pieceName = pieceNameOf(p),\n          pieceNode = createEl('piece', pieceName) as cg.PieceNode,\n          pos = key2pos(k);\n\n        pieceNode.cgPiece = pieceName;\n        pieceNode.cgKey = k;\n        if (anim) {\n          pieceNode.cgAnimating = true;\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n        }\n        translate(pieceNode, posToTranslate(pos, asWhite));\n\n        if (s.addPieceZIndex) pieceNode.style.zIndex = posZIndex(pos, asWhite);\n\n        boardEl.appendChild(pieceNode);\n      }\n    }\n  }\n\n  // remove any element that remains in the moved sets\n  for (const nodes of movedPieces.values()) removeNodes(s, nodes);\n  for (const nodes of movedSquares.values()) removeNodes(s, nodes);\n}\n\nexport function renderResized(s: State): void {\n  const asWhite: boolean = whitePov(s),\n    posToTranslate = posToTranslateFromBounds(s.dom.bounds());\n  let el = s.dom.elements.board.firstChild as cg.PieceNode | cg.SquareNode | undefined;\n  while (el) {\n    if ((isPieceNode(el) && !el.cgAnimating) || isSquareNode(el)) {\n      translate(el, posToTranslate(key2pos(el.cgKey), asWhite));\n    }\n    el = el.nextSibling as cg.PieceNode | cg.SquareNode | undefined;\n  }\n}\n\nexport function updateBounds(s: State): void {\n  const bounds = s.dom.elements.wrap.getBoundingClientRect();\n  const container = s.dom.elements.container;\n  const ratio = bounds.height / bounds.width;\n  const width = (Math.floor((bounds.width * window.devicePixelRatio) / 8) * 8) / window.devicePixelRatio;\n  const height = width * ratio;\n  container.style.width = width + 'px';\n  container.style.height = height + 'px';\n  s.dom.bounds.clear();\n\n  s.addDimensionsCssVarsTo?.style.setProperty('---cg-width', width + 'px');\n  s.addDimensionsCssVarsTo?.style.setProperty('---cg-height', height + 'px');\n}\n\nconst isPieceNode = (el: cg.PieceNode | cg.SquareNode): el is cg.PieceNode => el.tagName === 'PIECE';\nconst isSquareNode = (el: cg.PieceNode | cg.SquareNode): el is cg.SquareNode => el.tagName === 'SQUARE';\n\nfunction removeNodes(s: State, nodes: HTMLElement[]): void {\n  for (const node of nodes) s.dom.elements.board.removeChild(node);\n}\n\nfunction posZIndex(pos: cg.Pos, asWhite: boolean): string {\n  const minZ = 3;\n  const rank = pos[1];\n  const z = asWhite ? minZ + 7 - rank : minZ + rank;\n\n  return `${z}`;\n}\n\nconst pieceNameOf = (piece: cg.Piece): string => `${piece.color} ${piece.role}`;\n\nfunction computeSquareClasses(s: State): cg.SquareClasses {\n  const squares: cg.SquareClasses = new Map();\n  if (s.lastMove && s.highlight.lastMove)\n    for (const k of s.lastMove) {\n      addSquare(squares, k, 'last-move');\n    }\n  if (s.check && s.highlight.check) addSquare(squares, s.check, 'check');\n  if (s.selected) {\n    addSquare(squares, s.selected, 'selected');\n    if (s.movable.showDests) {\n      const dests = s.movable.dests?.get(s.selected);\n      if (dests)\n        for (const k of dests) {\n          addSquare(squares, k, 'move-dest' + (s.pieces.has(k) ? ' oc' : ''));\n        }\n      const pDests = s.premovable.customDests?.get(s.selected) ?? s.premovable.dests;\n      if (pDests)\n        for (const k of pDests) {\n          addSquare(squares, k, 'premove-dest' + (s.pieces.has(k) ? ' oc' : ''));\n        }\n    }\n  }\n  const premove = s.premovable.current;\n  if (premove) for (const k of premove) addSquare(squares, k, 'current-premove');\n  else if (s.predroppable.current) addSquare(squares, s.predroppable.current.key, 'current-premove');\n\n  const o = s.exploding;\n  if (o) for (const k of o.keys) addSquare(squares, k, 'exploding' + o.stage);\n\n  if (s.highlight.custom) {\n    s.highlight.custom.forEach((v: string, k: cg.Key) => {\n      addSquare(squares, k, v);\n    });\n  }\n\n  return squares;\n}\n\nfunction addSquare(squares: cg.SquareClasses, key: cg.Key, klass: string): void {\n  const classes = squares.get(key);\n  if (classes) squares.set(key, `${classes} ${klass}`);\n  else squares.set(key, klass);\n}\n\nfunction appendValue<K, V>(map: Map<K, V[]>, key: K, value: V): void {\n  const arr = map.get(key);\n  if (arr) arr.push(value);\n  else map.set(key, [value]);\n}\n","import { key2pos, createEl, posToTranslate as posToTranslateFromBounds, translateAndScale } from './util.js';\nimport { whitePov } from './board.js';\nimport { syncShapes } from './sync.js';\nexport function render(state, autoPieceEl) {\n    const autoPieces = state.drawable.autoShapes.filter(autoShape => autoShape.piece);\n    const autoPieceShapes = autoPieces.map((s) => {\n        return {\n            shape: s,\n            hash: hash(s),\n            current: false,\n        };\n    });\n    syncShapes(autoPieceShapes, autoPieceEl, shape => renderShape(state, shape, state.dom.bounds()));\n}\nexport function renderResized(state) {\n    var _a;\n    const asWhite = whitePov(state), posToTranslate = posToTranslateFromBounds(state.dom.bounds());\n    let el = (_a = state.dom.elements.autoPieces) === null || _a === void 0 ? void 0 : _a.firstChild;\n    while (el) {\n        translateAndScale(el, posToTranslate(key2pos(el.cgKey), asWhite), el.cgScale);\n        el = el.nextSibling;\n    }\n}\nfunction renderShape(state, { shape, hash }, bounds) {\n    var _a, _b, _c;\n    const orig = shape.orig;\n    const role = (_a = shape.piece) === null || _a === void 0 ? void 0 : _a.role;\n    const color = (_b = shape.piece) === null || _b === void 0 ? void 0 : _b.color;\n    const scale = (_c = shape.piece) === null || _c === void 0 ? void 0 : _c.scale;\n    const pieceEl = createEl('piece', `${role} ${color}`);\n    pieceEl.setAttribute('cgHash', hash);\n    pieceEl.cgKey = orig;\n    pieceEl.cgScale = scale;\n    translateAndScale(pieceEl, posToTranslateFromBounds(bounds)(key2pos(orig), whitePov(state)), scale);\n    return pieceEl;\n}\nconst hash = (autoPiece) => { var _a, _b, _c; return [autoPiece.orig, (_a = autoPiece.piece) === null || _a === void 0 ? void 0 : _a.role, (_b = autoPiece.piece) === null || _b === void 0 ? void 0 : _b.color, (_c = autoPiece.piece) === null || _c === void 0 ? void 0 : _c.scale].join(','); };\n//# sourceMappingURL=autoPieces.js.map","import { State } from './state.js';\nimport { key2pos, createEl, posToTranslate as posToTranslateFromBounds, translateAndScale } from './util.js';\nimport { whitePov } from './board.js';\nimport * as cg from './types.js';\nimport { DrawShape } from './draw.js';\nimport { SyncableShape, Hash, syncShapes } from './sync.js';\n\nexport function render(state: State, autoPieceEl: HTMLElement): void {\n  const autoPieces = state.drawable.autoShapes.filter(autoShape => autoShape.piece);\n  const autoPieceShapes: SyncableShape[] = autoPieces.map((s: DrawShape) => {\n    return {\n      shape: s,\n      hash: hash(s),\n      current: false,\n    };\n  });\n\n  syncShapes(autoPieceShapes, autoPieceEl, shape => renderShape(state, shape, state.dom.bounds()));\n}\n\nexport function renderResized(state: State): void {\n  const asWhite: boolean = whitePov(state),\n    posToTranslate = posToTranslateFromBounds(state.dom.bounds());\n  let el = state.dom.elements.autoPieces?.firstChild as cg.PieceNode | undefined;\n  while (el) {\n    translateAndScale(el, posToTranslate(key2pos(el.cgKey), asWhite), el.cgScale);\n    el = el.nextSibling as cg.PieceNode | undefined;\n  }\n}\n\nfunction renderShape(state: State, { shape, hash }: SyncableShape, bounds: DOMRectReadOnly): cg.PieceNode {\n  const orig = shape.orig;\n  const role = shape.piece?.role;\n  const color = shape.piece?.color;\n  const scale = shape.piece?.scale;\n\n  const pieceEl = createEl('piece', `${role} ${color}`) as cg.PieceNode;\n  pieceEl.setAttribute('cgHash', hash);\n  pieceEl.cgKey = orig;\n  pieceEl.cgScale = scale;\n  translateAndScale(pieceEl, posToTranslateFromBounds(bounds)(key2pos(orig), whitePov(state)), scale);\n\n  return pieceEl;\n}\n\nconst hash = (autoPiece: DrawShape): Hash =>\n  [autoPiece.orig, autoPiece.piece?.role, autoPiece.piece?.color, autoPiece.piece?.scale].join(',');\n","// append and remove only. No updates.\nexport function syncShapes(shapes, root, renderShape) {\n    const hashesInDom = new Map(), // by hash\n    toRemove = [];\n    for (const sc of shapes)\n        hashesInDom.set(sc.hash, false);\n    let el = root.firstElementChild, elHash;\n    while (el) {\n        elHash = el.getAttribute('cgHash');\n        // found a shape element that's here to stay\n        if (hashesInDom.has(elHash))\n            hashesInDom.set(elHash, true);\n        // or remove it\n        else\n            toRemove.push(el);\n        el = el.nextElementSibling;\n    }\n    // remove old shapes\n    for (const el of toRemove)\n        root.removeChild(el);\n    // insert shapes that are not yet in dom\n    for (const sc of shapes) {\n        if (!hashesInDom.get(sc.hash))\n            root.appendChild(renderShape(sc));\n    }\n}\n//# sourceMappingURL=sync.js.map","import { DrawShape } from './draw';\n\nexport interface SyncableShape {\n  shape: DrawShape;\n  current: boolean;\n  hash: Hash;\n}\n\nexport type Hash = string;\n\n// append and remove only. No updates.\nexport function syncShapes(\n  shapes: SyncableShape[],\n  root: HTMLElement | SVGElement,\n  renderShape: (shape: SyncableShape) => HTMLElement | SVGElement,\n): void {\n  const hashesInDom = new Map(), // by hash\n    toRemove: SVGElement[] = [];\n  for (const sc of shapes) hashesInDom.set(sc.hash, false);\n  let el: SVGElement | undefined = root.firstElementChild as SVGElement,\n    elHash: Hash | null;\n  while (el) {\n    elHash = el.getAttribute('cgHash') as Hash;\n    // found a shape element that's here to stay\n    if (hashesInDom.has(elHash)) hashesInDom.set(elHash, true);\n    // or remove it\n    else toRemove.push(el);\n    el = el.nextElementSibling as SVGElement | undefined;\n  }\n  // remove old shapes\n  for (const el of toRemove) root.removeChild(el);\n  // insert shapes that are not yet in dom\n  for (const sc of shapes) {\n    if (!hashesInDom.get(sc.hash)) root.appendChild(renderShape(sc));\n  }\n}\n"],"names":["$e1e1f1f3cd154daa$export$1264a6620073cfaa","$e1e1f1f3cd154daa$export$e49a5ad3dd6df925","color","from","to","piece","captured","promotion","flags","san","lan","before","after","constructor","chess","internal","fromAlgebraic","$e1e1f1f3cd154daa$var$algebraic","toAlgebraic","flag","legal","fen","$e1e1f1f3cd154daa$var$BITS","$e1e1f1f3cd154daa$var$FLAGS","isCapture","indexOf","isPromotion","isEnPassant","isKingsideCastle","isQueensideCastle","isBigPawn","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","$e1e1f1f3cd154daa$var$Ox88","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","$e1e1f1f3cd154daa$var$PAWN_OFFSETS","b","w","$e1e1f1f3cd154daa$var$PIECE_OFFSETS","n","r","q","k","$e1e1f1f3cd154daa$var$ATTACKS","$e1e1f1f3cd154daa$var$RAYS","$e1e1f1f3cd154daa$var$PIECE_MASKS","p","$e1e1f1f3cd154daa$var$PROMOTIONS","$e1e1f1f3cd154daa$var$SIDES","$e1e1f1f3cd154daa$var$ROOKS","square","$e1e1f1f3cd154daa$var$SECOND_RANK","$e1e1f1f3cd154daa$var$TERMINATION_MARKERS","$e1e1f1f3cd154daa$var$isDigit","c","f","substring","$e1e1f1f3cd154daa$var$swapColor","$e1e1f1f3cd154daa$var$addMove","moves","i","length","push","$e1e1f1f3cd154daa$var$inferPieceType","pieceType","charAt","match","toLowerCase","$e1e1f1f3cd154daa$var$strippedSan","move","replace","$e1e1f1f3cd154daa$var$trimFen","split","slice","join","$e1e1f1f3cd154daa$export$a4d6ea685c300d39","_board","Array","_turn","_header","_kings","_epSquare","_halfMoves","_moveNumber","_history","_comments","_castling","_positionCount","load","clear","preserveHeaders","skipValidation","tokens","concat","adjustments","ok","error","$e1e1f1f3cd154daa$export$d9e02ca3a6185312","moveNumber","parseInt","isNaN","halfMoves","test","rows","sumFields","previousWasNumber","regex","some","char","toUpperCase","Error","position","_put","type","_updateSetup","_incPositionCount","empty","castling","epSquare","bigPawnSquare","_makeMove","isLegal","_isKingAttacked","_undoMove","reset","get","put","_updateCastlingRights","_updateEnPassantSquare","$e1e1f1f3cd154daa$var$SYMBOLS","sq","currentPieceOnSquare","remove","whiteKingInPlace","blackKingInPlace","startSquare","currentSquare","attackers","_attacked","verbose","undefined","difference","index","offset","j","blocked","attackedBy","isAttacked","isCheck","inCheck","isCheckmate","_moves","isStalemate","isInsufficientMaterial","pieces","bishops","numPieces","squareColor","sum","len","isThreefoldRepetition","_getPositionCount","isDrawByFiftyMoves","isDraw","isGameOver","map","_moveToSan","forSquare","forPiece","us","them","firstSquare","lastSquare","singleSquare","castlingFrom","castlingTo","legalMoves","strict","moveObj","_moveFromSan","JSON","stringify","prettyMove","_push","kings","turn","undo","_decPositionCount","old","pop","pgn","newline","maxWidth","result","headerExists","appendComment","moveString","comment","delimiter","reversedHistory","prefix","Result","strip","currentWidth","includes","wrapComment","width","token","header","args","setHeader","key","value","removeHeader","getHeaders","loadPgn","newlineChar","mask","str","trim","headerRegexResults","headerRegex","RegExp","exec","headerString","headers","parsePgnHeader","headerObj","encodeComment","s","charCodeAt","toString","encodeURIComponent","ms","_match","bracket","semicolon","ravRegex","filter","halfMove","decodeComment","startsWith","endsWith","decodeURIComponent","Object","keys","output","disambiguator","$e1e1f1f3cd154daa$var$getDisambiguator","ambiguities","sameRank","sameFile","ambigFrom","ambigTo","matches","cleanMove","overlyDisambiguated","ascii","perft","depth","nodes","board","row","$e1e1f1f3cd154daa$var$rank","history","moveHistory","trimmedFen","_pruneComments","currentComments","copyComment","getComment","setComment","deleteComment","removeComment","getComments","deleteComments","removeComments","setCastlingRights","rights","side","getCastlingRights","$a9912b1579309d38$export$8f45430ccf837300","$a9912b1579309d38$export$3a444357c5f65f65","$a9912b1579309d38$export$d8e4e3952f325c95","$e845129b04f677bd$export$978f7ef4c67d166e","reverse","$e845129b04f677bd$export$ade7a30951d0bc54","prototype","$e845129b04f677bd$export$fe9f8b727818c0ae","pos","$e845129b04f677bd$export$e2878eba51f22d11","$e845129b04f677bd$export$26773b74d67e09c2","$e845129b04f677bd$export$9dc4ecf953986f04","startAt","start","performance","now","cancel","stop","time","$e845129b04f677bd$export$a27c3a1c44ba515b","$e845129b04f677bd$export$e4884e1734dcd545","pos1","pos2","dx","dy","$e845129b04f677bd$export$e329b1a538c004fa","p1","p2","role","$e845129b04f677bd$export$2135ad75550a2ff4","bounds","asWhite","height","$e845129b04f677bd$export$d73ee8ef04f5226a","el","style","transform","$e845129b04f677bd$export$f8afaca97e230dc6","scale","$e845129b04f677bd$export$8cb512849e51eaf5","v","visibility","$e845129b04f677bd$export$33052595192f7117","e","_a","clientX","clientY","targetTouches","$e845129b04f677bd$export$947a472b5b3020ba","button","$e845129b04f677bd$export$3d7cd8ed57263b30","tagName","className","document","createElement","$e845129b04f677bd$export$1c17f680299a31f7","left","top","$6478a7cdda5927f6$var$diff","a","Math","abs","$6478a7cdda5927f6$var$pawn","x1","y1","x2","y2","$6478a7cdda5927f6$export$5584fb45fd3a6d08","xd","yd","$6478a7cdda5927f6$var$bishop","$6478a7cdda5927f6$var$rook","$6478a7cdda5927f6$export$b9d1aa6d9cf991c6","$6478a7cdda5927f6$var$king","rookFiles","canCastle","$6478a7cdda5927f6$export$99ff1a176ab1ff90","mobility","$6478a7cdda5927f6$var$rookFilesOf","backrank","files","$362ede749680455b$export$6511920ae9f0cd34","setTimeout","$362ede749680455b$export$f92a111f74a3f7c7","state","premovable","current","events","unset","$362ede749680455b$export$9e6f418e5ea6b92c","pd","predroppable","$362ede749680455b$export$13f6ca6271343510","orig","dest","origPiece","destPiece","selected","$362ede749680455b$export$fe412c270a34f415","$362ede749680455b$var$tryAutoCastle","autoCastle","king","origPos","destPos","has","rook","delete","set","lastMove","check","change","$362ede749680455b$export$13886f9573facc29","force","dropNewPiece","movable","dests","turnColor","$362ede749680455b$var$baseUserMove","animation","$362ede749680455b$export$843c446e2e718822","$362ede749680455b$export$a4ef2b0c3fa55ad2","holdTime","hold","metadata","premove","ctrlKey","stats","$362ede749680455b$var$canPremove","_b","validPremoves","customDests","castle","$362ede749680455b$var$isPremovable","meta","$362ede749680455b$export$b2b9f46b948033b0","$362ede749680455b$var$canDrop","afterNewPiece","predrop","$362ede749680455b$var$canPredrop","enabled","$362ede749680455b$var$setPredrop","$362ede749680455b$export$6073914ea697a63e","select","draggable","selectable","dragged","$362ede749680455b$var$isMovable","$362ede749680455b$export$5a4818cec1656a71","free","$362ede749680455b$export$d04320a93cdae73d","success","$362ede749680455b$export$e47a3d6268102bb5","$362ede749680455b$export$fa6813432f753b0d","$362ede749680455b$export$102bdd581884418b","file","floor","rank","$362ede749680455b$export$970133fdf67d86cb","orientation","$283b3759973e0b3f$export$59ff82fc918bd7e3","$283b3759973e0b3f$var$roles","$283b3759973e0b3f$var$letters","pawn","knight","bishop","queen","$283b3759973e0b3f$export$aafa59e2e03f2942","Map","col","promoted","nb","$d854d6e3b9054dcc$export$d771543c4ed87064","config","$d854d6e3b9054dcc$var$deepMerge","duration","$d854d6e3b9054dcc$export$8d21e34596265fa2","_c","drawable","autoShapes","shapes","rookCastle","kingStartPos","d","base","extend","hasOwnProperty","call","$d854d6e3b9054dcc$var$isPlainObject","o","proto","getPrototypeOf","$4862821e78925973$export$bd46b8ab3689edc4","mutation","$4862821e78925973$var$animate","prevPieces","plan","$4862821e78925973$var$computePlan","curP","preP","vector","anims","animedOrigs","fadings","missings","news","prePieces","$4862821e78925973$var$makePiece","newP","$4862821e78925973$var$closer","size","alreadyRunning","frequency","$4862821e78925973$var$step","cur","dom","destroyed","redrawNow","rest","ease","$4862821e78925973$var$easing","cfg","values","requestAnimationFrame","redraw","$4862821e78925973$export$b3890eb0ae9dca99","sort","t","$e4dfa114a4df3bca$var$brushes","$e4dfa114a4df3bca$export$d947e5f4f4c48d48","$e4dfa114a4df3bca$export$bd5df0f255a350f8","mouseSq","$e4dfa114a4df3bca$var$addShape","sameShape","similar","find","brush","$e4dfa114a4df3bca$var$onChange","$e4dfa114a4df3bca$export$70b61ad426ddbe54","onChange","$f0622fe2c415ff29$var$processDrag","started","pow","distance","element","found","cgDragging","classList","add","keyHasChanged","$f0622fe2c415ff29$export$70b61ad426ddbe54","$f0622fe2c415ff29$export$d947e5f4f4c48d48","touches","$f0622fe2c415ff29$export$bd5df0f255a350f8","cancelable","preventDefault","originTarget","target","newPiece","deleteOnDropOff","previouslySelected","$f0622fe2c415ff29$var$removeDragElements","elements","ghost","$f0622fe2c415ff29$var$pieceElementByKey","firstChild","cgKey","nextSibling","$c20cd8d479dc62bc$var$setStage","stage","exploding","$624548787bc3efbc$var$hilites","hilitePrimary","opacity","lineWidth","hiliteWhite","$624548787bc3efbc$var$shapeHash","modifiers","customSvg","label","shorten","x","m","hilite","$624548787bc3efbc$var$textHash","html","center","text","h","$624548787bc3efbc$var$hilite","$624548787bc3efbc$var$orient","$624548787bc3efbc$var$isShort","$624548787bc3efbc$export$c8a8987d4410bf2d","createElementNS","$624548787bc3efbc$export$74da2cba014bdc09","attrs","setAttribute","$624548787bc3efbc$var$makeCustomBrush","round","$624548787bc3efbc$var$opacity","$624548787bc3efbc$var$pos2user","xScale","min","yScale","$624548787bc3efbc$var$moveAngle","asSlot","angle","atan2","PI","$624548787bc3efbc$var$labelCoords","slots","mag","sqrt","reduce","acc","slot","cos","sin","$d0202f5e455c071c$var$renderCoords","elems","elem","textContent","appendChild","$d8436509f6a2172f$var$unbindable","eventName","callback","options","addEventListener","removeEventListener","$d8436509f6a2172f$var$startDragOrDraw","shiftKey","$e4dfa114a4df3bca$export$b3571188c770cc5a","stopPropagation","modA","modB","altKey","metaKey","getModifierState","snapToValidMove","defaultSnapToValidMove","$e4dfa114a4df3bca$export$816e7b21815d9cf9","keyAtDomPos","validSnapPos","validSnapDistances","validSnapCenters","closestSnapIndex","viewOnly","dropmode","active","$f0622fe2c415ff29$export$b3571188c770cc5a","trustAllEvents","isTrusted","buttons","eraseOnClick","blockTouchScroll","$f0622fe2c415ff29$var$pieceCloseTo","radiusSq","hadPremove","hadPredrop","stillSelected","$362ede749680455b$export$fe8f97248bbe2d04","autoDistance","$d8436509f6a2172f$var$dragOrDraw","withDrag","withDraw","$676ff861fa9fc211$export$f4467a4f41373bc7","wrap","getBoundingClientRect","container","ratio","window","devicePixelRatio","addDimensionsCssVarsTo","setProperty","$676ff861fa9fc211$var$isPieceNode","$676ff861fa9fc211$var$isSquareNode","$676ff861fa9fc211$var$removeNodes","node","removeChild","$676ff861fa9fc211$var$posZIndex","minZ","$676ff861fa9fc211$var$pieceNameOf","$676ff861fa9fc211$var$addSquare","squares","klass","classes","$676ff861fa9fc211$var$appendValue","arr","$7d4b88c0b296489d$var$hash","autoPiece","$36d5a33d9da87b96$var$chess","$36d5a33d9da87b96$var$board","maybeState","coordinates","coordinatesOnSquares","ranksPosition","disableContextMenu","addPieceZIndex","pieceKey","highlight","showDests","showGhost","visible","brushes","green","red","blue","yellow","paleBlue","paleGreen","paleRed","paleGrey","purple","pink","white","prevSvgHash","redrawAll","redrawing","prevUnbind","unbind","svg","autoPieces","innerHTML","toggle","class","viewBox","preserveAspectRatio","defs","id","stdDeviation","orientClass","ranksPositionClass","rankN","forEach","$e845129b04f677bd$export$7c73462e0d25e514","ret","skipSvg","pieceAtKey","elPieceName","anim","fading","pMvdset","pMvd","sMvdset","sMvd","posToTranslate","boardEl","curAnim","curDrag","$676ff861fa9fc211$var$computeSquareClasses","pDests","custom","samePieces","Set","sameSquares","movedPieces","movedSquares","cgPiece","cgFading","cgAnimating","zIndex","cn","sk","translation","squareNode","insertBefore","pieceName","pieceNode","$7d4b88c0b296489d$export$b3890eb0ae9dca99","autoPieceEl","root","renderShape","hashesInDom","toRemove","sc","hash","firstElementChild","elHash","getAttribute","nextElementSibling","autoShape","shape","$7d4b88c0b296489d$var$renderShape","pieceEl","cgScale","$624548787bc3efbc$export$fb80b1b7d7777ee5","shapesEl","customsEl","curD","nonPieceAutoShapes","sources","fullHash","$624548787bc3efbc$var$syncDefs","defsEl","keysInDom","entries","$624548787bc3efbc$var$renderMarker","marker","orient","overflow","markerWidth","markerHeight","refX","refY","fill","querySelector","$624548787bc3efbc$var$syncShapes","syncables","customs","isCustom","$624548787bc3efbc$var$renderShape","svgs","cgHash","$624548787bc3efbc$var$renderArrow","renderLine","isHilite","xo","yo","stroke","$624548787bc3efbc$var$lineWidth","g","blurred","$624548787bc3efbc$var$filterBox","box","ceil","max","y","$624548787bc3efbc$var$renderCircle","at","widths","radius","cx","cy","corner","$624548787bc3efbc$var$renderLabel","fontSize","labelSize","cornerOff","labelEl","on","onResize","$7d4b88c0b296489d$export$d62f185fd39aa98c","$d8436509f6a2172f$export$fc48d2ed06541843","ResizeObserver","observe","onStart","passive","$d8436509f6a2172f$export$fdc77453278b0fa9","unbinds","body","onmove","onend","ev","onScroll","capture","insert","toggleOrientation","getFen","setPieces","$362ede749680455b$export$20a063d1402ff7ff","selectSquare","playPremove","playPredrop","validate","$362ede749680455b$export$8efa9460c0cedd9e","drop","cancelPremove","cancelPredrop","cancelMove","explode","setAutoShapes","setShapes","getKeyAtDomPos","dragNewPiece","event","destroy","getElementById","console"],"version":3,"file":"index.47963c1a.js.map"}
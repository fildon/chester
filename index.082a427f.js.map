{"mappings":"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","sources":["<anon>","src/app.ts","node_modules/chessops/dist/esm/chess.js","node_modules/chessops/src/chess.ts","node_modules/@badrap/result/dist/index.module.mjs","node_modules/@badrap/result/src/index.ts","node_modules/chessops/dist/esm/attacks.js","node_modules/chessops/src/attacks.ts","node_modules/chessops/dist/esm/squareSet.js","node_modules/chessops/src/squareSet.ts","node_modules/chessops/dist/esm/util.js","node_modules/chessops/src/util.ts","node_modules/chessops/dist/esm/types.js","node_modules/chessops/src/types.ts","node_modules/chessops/dist/esm/board.js","node_modules/chessops/src/board.ts","node_modules/chessops/dist/esm/fen.js","node_modules/chessops/src/fen.ts","node_modules/chessops/dist/esm/setup.js","node_modules/chessops/src/setup.ts","node_modules/chessground/dist/chessground.js","node_modules/chessground/src/chessground.ts","node_modules/chessground/dist/api.js","node_modules/chessground/src/api.ts","node_modules/chessground/dist/board.js","node_modules/chessground/src/board.ts","node_modules/chessground/dist/util.js","node_modules/chessground/src/util.ts","node_modules/chessground/dist/types.js","node_modules/chessground/src/types.ts","node_modules/chessground/dist/premove.js","node_modules/chessground/src/premove.ts","node_modules/chessground/dist/fen.js","node_modules/chessground/src/fen.ts","node_modules/chessground/dist/config.js","node_modules/chessground/src/config.ts","node_modules/chessground/dist/anim.js","node_modules/chessground/src/anim.ts","node_modules/chessground/dist/drag.js","node_modules/chessground/src/drag.ts","node_modules/chessground/dist/draw.js","node_modules/chessground/src/draw.ts","node_modules/chessground/dist/explosion.js","node_modules/chessground/src/explosion.ts","node_modules/chessground/dist/state.js","node_modules/chessground/src/state.ts","node_modules/chessground/dist/wrap.js","node_modules/chessground/src/wrap.ts","node_modules/chessground/dist/svg.js","node_modules/chessground/src/svg.ts","node_modules/chessground/dist/events.js","node_modules/chessground/src/events.ts","node_modules/chessground/dist/drop.js","node_modules/chessground/src/drop.ts","node_modules/chessground/dist/render.js","node_modules/chessground/src/render.ts","node_modules/chessground/dist/autoPieces.js","node_modules/chessground/src/autoPieces.ts","node_modules/chessground/dist/sync.js","node_modules/chessground/src/sync.ts","src/movePicker.ts"],"sourcesContent":["(function () {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nfunction $0b15f372ed432f56$var$r(r, n) {\n    r.prototype = Object.create(n.prototype), r.prototype.constructor = r, $0b15f372ed432f56$var$t(r, n);\n}\nfunction $0b15f372ed432f56$var$t(r, n) {\n    return $0b15f372ed432f56$var$t = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, t) {\n        return r.__proto__ = t, r;\n    }, $0b15f372ed432f56$var$t(r, n);\n}\nvar $0b15f372ed432f56$export$8fdcabde73f49165, $0b15f372ed432f56$var$e = /*#__PURE__*/ function() {\n    function r() {}\n    var t = r.prototype;\n    return t.unwrap = function(r, t) {\n        var e = this._chain(function(t) {\n            return $0b15f372ed432f56$export$8fdcabde73f49165.ok(r ? r(t) : t);\n        }, function(r) {\n            return t ? $0b15f372ed432f56$export$8fdcabde73f49165.ok(t(r)) : $0b15f372ed432f56$export$8fdcabde73f49165.err(r);\n        });\n        if (e.isErr) throw e.error;\n        return e.value;\n    }, t.map = function(r, t) {\n        return this._chain(function(t) {\n            return $0b15f372ed432f56$export$8fdcabde73f49165.ok(r(t));\n        }, function(r) {\n            return $0b15f372ed432f56$export$8fdcabde73f49165.err(t ? t(r) : r);\n        });\n    }, t.chain = function(r, t) {\n        return this._chain(r, t || function(r) {\n            return $0b15f372ed432f56$export$8fdcabde73f49165.err(r);\n        });\n    }, r;\n}(), $0b15f372ed432f56$var$o = /*#__PURE__*/ function(t) {\n    function n(r) {\n        var n;\n        return (n = t.call(this) || this).value = void 0, n.isOk = !0, n.isErr = !1, n.value = r, n;\n    }\n    return $0b15f372ed432f56$var$r(n, t), n.prototype._chain = function(r, t) {\n        return r(this.value);\n    }, n;\n}($0b15f372ed432f56$var$e), $0b15f372ed432f56$var$u = /*#__PURE__*/ function(t) {\n    function n(r) {\n        var n;\n        return (n = t.call(this) || this).error = void 0, n.isOk = !1, n.isErr = !0, n.error = r, n;\n    }\n    return $0b15f372ed432f56$var$r(n, t), n.prototype._chain = function(r, t) {\n        return t(this.error);\n    }, n;\n}($0b15f372ed432f56$var$e);\n!function(r) {\n    r.ok = function(r) {\n        return new $0b15f372ed432f56$var$o(r);\n    }, r.err = function(r) {\n        return new $0b15f372ed432f56$var$u(r || new Error);\n    }, r.all = function(t) {\n        if (Array.isArray(t)) {\n            for(var n = [], e = 0; e < t.length; e++){\n                var o = t[e];\n                if (o.isErr) return o;\n                n.push(o.value);\n            }\n            return r.ok(n);\n        }\n        for(var u = {}, i = Object.keys(t), c = 0; c < i.length; c++){\n            var f = t[i[c]];\n            if (f.isErr) return f;\n            u[i[c]] = f.value;\n        }\n        return r.ok(u);\n    };\n}($0b15f372ed432f56$export$8fdcabde73f49165 || ($0b15f372ed432f56$export$8fdcabde73f49165 = {}));\n\n\n/**\n * Compute attacks and rays.\n *\n * These are low-level functions that can be used to implement chess rules.\n *\n * Implementation notes: Sliding attacks are computed using\n * [Hyperbola Quintessence](https://www.chessprogramming.org/Hyperbola_Quintessence).\n * Magic Bitboards would deliver slightly faster lookups, but also require\n * initializing considerably larger attack tables. On the web, initialization\n * time is important, so the chosen method may strike a better balance.\n *\n * @packageDocumentation\n */ const $9894c45c69033325$var$popcnt32 = (n)=>{\n    n = n - (n >>> 1 & 1431655765);\n    n = (n & 858993459) + (n >>> 2 & 858993459);\n    return Math.imul(n + (n >>> 4) & 252645135, 16843009) >> 24;\n};\nconst $9894c45c69033325$var$bswap32 = (n)=>{\n    n = n >>> 8 & 16711935 | (n & 16711935) << 8;\n    return n >>> 16 & 0xffff | (n & 0xffff) << 16;\n};\nconst $9894c45c69033325$var$rbit32 = (n)=>{\n    n = n >>> 1 & 1431655765 | (n & 1431655765) << 1;\n    n = n >>> 2 & 858993459 | (n & 858993459) << 2;\n    n = n >>> 4 & 252645135 | (n & 252645135) << 4;\n    return $9894c45c69033325$var$bswap32(n);\n};\nclass $9894c45c69033325$export$1cb45477e81f9503 {\n    constructor(lo, hi){\n        this.lo = lo | 0;\n        this.hi = hi | 0;\n    }\n    static fromSquare(square) {\n        return square >= 32 ? new $9894c45c69033325$export$1cb45477e81f9503(0, 1 << square - 32) : new $9894c45c69033325$export$1cb45477e81f9503(1 << square, 0);\n    }\n    static fromRank(rank) {\n        return new $9894c45c69033325$export$1cb45477e81f9503(0xff, 0).shl64(8 * rank);\n    }\n    static fromFile(file) {\n        return new $9894c45c69033325$export$1cb45477e81f9503(16843009 << file, 16843009 << file);\n    }\n    static empty() {\n        return new $9894c45c69033325$export$1cb45477e81f9503(0, 0);\n    }\n    static full() {\n        return new $9894c45c69033325$export$1cb45477e81f9503(4294967295, 4294967295);\n    }\n    static corners() {\n        return new $9894c45c69033325$export$1cb45477e81f9503(0x81, 2164260864);\n    }\n    static center() {\n        return new $9894c45c69033325$export$1cb45477e81f9503(402653184, 0x18);\n    }\n    static backranks() {\n        return new $9894c45c69033325$export$1cb45477e81f9503(0xff, 4278190080);\n    }\n    static backrank(color) {\n        return color === 'white' ? new $9894c45c69033325$export$1cb45477e81f9503(0xff, 0) : new $9894c45c69033325$export$1cb45477e81f9503(0, 4278190080);\n    }\n    static lightSquares() {\n        return new $9894c45c69033325$export$1cb45477e81f9503(1437226410, 1437226410);\n    }\n    static darkSquares() {\n        return new $9894c45c69033325$export$1cb45477e81f9503(2857740885, 2857740885);\n    }\n    complement() {\n        return new $9894c45c69033325$export$1cb45477e81f9503(~this.lo, ~this.hi);\n    }\n    xor(other) {\n        return new $9894c45c69033325$export$1cb45477e81f9503(this.lo ^ other.lo, this.hi ^ other.hi);\n    }\n    union(other) {\n        return new $9894c45c69033325$export$1cb45477e81f9503(this.lo | other.lo, this.hi | other.hi);\n    }\n    intersect(other) {\n        return new $9894c45c69033325$export$1cb45477e81f9503(this.lo & other.lo, this.hi & other.hi);\n    }\n    diff(other) {\n        return new $9894c45c69033325$export$1cb45477e81f9503(this.lo & ~other.lo, this.hi & ~other.hi);\n    }\n    intersects(other) {\n        return this.intersect(other).nonEmpty();\n    }\n    isDisjoint(other) {\n        return this.intersect(other).isEmpty();\n    }\n    supersetOf(other) {\n        return other.diff(this).isEmpty();\n    }\n    subsetOf(other) {\n        return this.diff(other).isEmpty();\n    }\n    shr64(shift) {\n        if (shift >= 64) return $9894c45c69033325$export$1cb45477e81f9503.empty();\n        if (shift >= 32) return new $9894c45c69033325$export$1cb45477e81f9503(this.hi >>> shift - 32, 0);\n        if (shift > 0) return new $9894c45c69033325$export$1cb45477e81f9503(this.lo >>> shift ^ this.hi << 32 - shift, this.hi >>> shift);\n        return this;\n    }\n    shl64(shift) {\n        if (shift >= 64) return $9894c45c69033325$export$1cb45477e81f9503.empty();\n        if (shift >= 32) return new $9894c45c69033325$export$1cb45477e81f9503(0, this.lo << shift - 32);\n        if (shift > 0) return new $9894c45c69033325$export$1cb45477e81f9503(this.lo << shift, this.hi << shift ^ this.lo >>> 32 - shift);\n        return this;\n    }\n    bswap64() {\n        return new $9894c45c69033325$export$1cb45477e81f9503($9894c45c69033325$var$bswap32(this.hi), $9894c45c69033325$var$bswap32(this.lo));\n    }\n    rbit64() {\n        return new $9894c45c69033325$export$1cb45477e81f9503($9894c45c69033325$var$rbit32(this.hi), $9894c45c69033325$var$rbit32(this.lo));\n    }\n    minus64(other) {\n        const lo = this.lo - other.lo;\n        const c = (lo & other.lo & 1) + (other.lo >>> 1) + (lo >>> 1) >>> 31;\n        return new $9894c45c69033325$export$1cb45477e81f9503(lo, this.hi - (other.hi + c));\n    }\n    equals(other) {\n        return this.lo === other.lo && this.hi === other.hi;\n    }\n    size() {\n        return $9894c45c69033325$var$popcnt32(this.lo) + $9894c45c69033325$var$popcnt32(this.hi);\n    }\n    isEmpty() {\n        return this.lo === 0 && this.hi === 0;\n    }\n    nonEmpty() {\n        return this.lo !== 0 || this.hi !== 0;\n    }\n    has(square) {\n        return (square >= 32 ? this.hi & 1 << square - 32 : this.lo & 1 << square) !== 0;\n    }\n    set(square, on) {\n        return on ? this.with(square) : this.without(square);\n    }\n    with(square) {\n        return square >= 32 ? new $9894c45c69033325$export$1cb45477e81f9503(this.lo, this.hi | 1 << square - 32) : new $9894c45c69033325$export$1cb45477e81f9503(this.lo | 1 << square, this.hi);\n    }\n    without(square) {\n        return square >= 32 ? new $9894c45c69033325$export$1cb45477e81f9503(this.lo, this.hi & ~(1 << square - 32)) : new $9894c45c69033325$export$1cb45477e81f9503(this.lo & ~(1 << square), this.hi);\n    }\n    toggle(square) {\n        return square >= 32 ? new $9894c45c69033325$export$1cb45477e81f9503(this.lo, this.hi ^ 1 << square - 32) : new $9894c45c69033325$export$1cb45477e81f9503(this.lo ^ 1 << square, this.hi);\n    }\n    last() {\n        if (this.hi !== 0) return 63 - Math.clz32(this.hi);\n        if (this.lo !== 0) return 31 - Math.clz32(this.lo);\n        return;\n    }\n    first() {\n        if (this.lo !== 0) return 31 - Math.clz32(this.lo & -this.lo);\n        if (this.hi !== 0) return 63 - Math.clz32(this.hi & -this.hi);\n        return;\n    }\n    withoutFirst() {\n        if (this.lo !== 0) return new $9894c45c69033325$export$1cb45477e81f9503(this.lo & this.lo - 1, this.hi);\n        return new $9894c45c69033325$export$1cb45477e81f9503(0, this.hi & this.hi - 1);\n    }\n    moreThanOne() {\n        return this.hi !== 0 && this.lo !== 0 || (this.lo & this.lo - 1) !== 0 || (this.hi & this.hi - 1) !== 0;\n    }\n    singleSquare() {\n        return this.moreThanOne() ? undefined : this.last();\n    }\n    *[Symbol.iterator]() {\n        let lo = this.lo;\n        let hi = this.hi;\n        while(lo !== 0){\n            const idx = 31 - Math.clz32(lo & -lo);\n            lo ^= 1 << idx;\n            yield idx;\n        }\n        while(hi !== 0){\n            const idx = 31 - Math.clz32(hi & -hi);\n            hi ^= 1 << idx;\n            yield 32 + idx;\n        }\n    }\n    *reversed() {\n        let lo = this.lo;\n        let hi = this.hi;\n        while(hi !== 0){\n            const idx = 31 - Math.clz32(hi);\n            hi ^= 1 << idx;\n            yield 32 + idx;\n        }\n        while(lo !== 0){\n            const idx = 31 - Math.clz32(lo);\n            lo ^= 1 << idx;\n            yield idx;\n        }\n    }\n}\n\n\nconst $c489d07ce8bc1a25$export$603b1d1551079add = [\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h'\n];\nconst $c489d07ce8bc1a25$export$2b1421cb957c0b7e = [\n    '1',\n    '2',\n    '3',\n    '4',\n    '5',\n    '6',\n    '7',\n    '8'\n];\nconst $c489d07ce8bc1a25$export$56d196d2844d1ca1 = [\n    'white',\n    'black'\n];\nconst $c489d07ce8bc1a25$export$d1cfdc29cbc61821 = [\n    'pawn',\n    'knight',\n    'bishop',\n    'rook',\n    'queen',\n    'king'\n];\nconst $c489d07ce8bc1a25$export$2ac9b71d100b39a1 = [\n    'a',\n    'h'\n];\nconst $c489d07ce8bc1a25$export$90ffe53e9bf2dee8 = (v)=>'role' in v;\nconst $c489d07ce8bc1a25$export$46dd8fdc8be98d59 = (v)=>'from' in v;\nconst $c489d07ce8bc1a25$export$6f0adf80117cb8df = [\n    'chess',\n    'antichess',\n    'kingofthehill',\n    '3check',\n    'atomic',\n    'horde',\n    'racingkings',\n    'crazyhouse'\n];\n\n\nconst $ced645034f45bdd3$export$43f40ad3fa1d5c97 = (v)=>v !== undefined;\nconst $ced645034f45bdd3$export$a27c3a1c44ba515b = (color)=>color === 'white' ? 'black' : 'white';\nconst $ced645034f45bdd3$export$8ec54076fe05cd3f = (square)=>square >> 3;\nconst $ced645034f45bdd3$export$4e7f80514dc39415 = (square)=>square & 0x7;\nconst $ced645034f45bdd3$export$4a0d5207d1ffca15 = (file, rank)=>0 <= file && file < 8 && 0 <= rank && rank < 8 ? file + 8 * rank : undefined;\nconst $ced645034f45bdd3$export$f10eeb6aa79a8bf2 = (role)=>{\n    switch(role){\n        case 'pawn':\n            return 'p';\n        case 'knight':\n            return 'n';\n        case 'bishop':\n            return 'b';\n        case 'rook':\n            return 'r';\n        case 'queen':\n            return 'q';\n        case 'king':\n            return 'k';\n    }\n};\nfunction $ced645034f45bdd3$export$f2f0c9a05dc6f86f(ch) {\n    switch(ch.toLowerCase()){\n        case 'p':\n            return 'pawn';\n        case 'n':\n            return 'knight';\n        case 'b':\n            return 'bishop';\n        case 'r':\n            return 'rook';\n        case 'q':\n            return 'queen';\n        case 'k':\n            return 'king';\n        default:\n            return;\n    }\n}\nfunction $ced645034f45bdd3$export$c6ba26669b4144a1(str) {\n    if (str.length !== 2) return;\n    return $ced645034f45bdd3$export$4a0d5207d1ffca15(str.charCodeAt(0) - 'a'.charCodeAt(0), str.charCodeAt(1) - '1'.charCodeAt(0));\n}\nconst $ced645034f45bdd3$export$232f91fc931f1158 = (square)=>(0, $c489d07ce8bc1a25$export$603b1d1551079add)[$ced645034f45bdd3$export$4e7f80514dc39415(square)] + (0, $c489d07ce8bc1a25$export$2b1421cb957c0b7e)[$ced645034f45bdd3$export$8ec54076fe05cd3f(square)];\nconst $ced645034f45bdd3$export$b852a877d94ef1a7 = (str)=>{\n    if (str[1] === '@' && str.length === 4) {\n        const role = $ced645034f45bdd3$export$f2f0c9a05dc6f86f(str[0]);\n        const to = $ced645034f45bdd3$export$c6ba26669b4144a1(str.slice(2));\n        if (role && $ced645034f45bdd3$export$43f40ad3fa1d5c97(to)) return {\n            role: role,\n            to: to\n        };\n    } else if (str.length === 4 || str.length === 5) {\n        const from = $ced645034f45bdd3$export$c6ba26669b4144a1(str.slice(0, 2));\n        const to = $ced645034f45bdd3$export$c6ba26669b4144a1(str.slice(2, 4));\n        let promotion;\n        if (str.length === 5) {\n            promotion = $ced645034f45bdd3$export$f2f0c9a05dc6f86f(str[4]);\n            if (!promotion) return;\n        }\n        if ($ced645034f45bdd3$export$43f40ad3fa1d5c97(from) && $ced645034f45bdd3$export$43f40ad3fa1d5c97(to)) return {\n            from: from,\n            to: to,\n            promotion: promotion\n        };\n    }\n    return;\n};\nconst $ced645034f45bdd3$export$c948e6ce58f87d7c = (left, right)=>{\n    if (left.to !== right.to) return false;\n    if ((0, $c489d07ce8bc1a25$export$90ffe53e9bf2dee8)(left)) return (0, $c489d07ce8bc1a25$export$90ffe53e9bf2dee8)(right) && left.role === right.role;\n    else return (0, $c489d07ce8bc1a25$export$46dd8fdc8be98d59)(right) && left.from === right.from && left.promotion === right.promotion;\n};\nconst $ced645034f45bdd3$export$7557b324d9d37023 = (move)=>(0, $c489d07ce8bc1a25$export$90ffe53e9bf2dee8)(move) ? `${$ced645034f45bdd3$export$f10eeb6aa79a8bf2(move.role).toUpperCase()}@${$ced645034f45bdd3$export$232f91fc931f1158(move.to)}` : $ced645034f45bdd3$export$232f91fc931f1158(move.from) + $ced645034f45bdd3$export$232f91fc931f1158(move.to) + (move.promotion ? $ced645034f45bdd3$export$f10eeb6aa79a8bf2(move.promotion) : '');\nconst $ced645034f45bdd3$export$9d0713081c523620 = (color, side)=>color === 'white' ? side === 'a' ? 2 : 6 : side === 'a' ? 58 : 62;\nconst $ced645034f45bdd3$export$d958227fca9654a5 = (color, side)=>color === 'white' ? side === 'a' ? 3 : 5 : side === 'a' ? 59 : 61;\n\n\nconst $9fc1d75359bd39d5$var$computeRange = (square, deltas)=>{\n    let range = (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n    for (const delta of deltas){\n        const sq = square + delta;\n        if (0 <= sq && sq < 64 && Math.abs((0, $ced645034f45bdd3$export$4e7f80514dc39415)(square) - (0, $ced645034f45bdd3$export$4e7f80514dc39415)(sq)) <= 2) range = range.with(sq);\n    }\n    return range;\n};\nconst $9fc1d75359bd39d5$var$tabulate = (f)=>{\n    const table = [];\n    for(let square = 0; square < 64; square++)table[square] = f(square);\n    return table;\n};\nconst $9fc1d75359bd39d5$var$KING_ATTACKS = $9fc1d75359bd39d5$var$tabulate((sq)=>$9fc1d75359bd39d5$var$computeRange(sq, [\n        -9,\n        -8,\n        -7,\n        -1,\n        1,\n        7,\n        8,\n        9\n    ]));\nconst $9fc1d75359bd39d5$var$KNIGHT_ATTACKS = $9fc1d75359bd39d5$var$tabulate((sq)=>$9fc1d75359bd39d5$var$computeRange(sq, [\n        -17,\n        -15,\n        -10,\n        -6,\n        6,\n        10,\n        15,\n        17\n    ]));\nconst $9fc1d75359bd39d5$var$PAWN_ATTACKS = {\n    white: $9fc1d75359bd39d5$var$tabulate((sq)=>$9fc1d75359bd39d5$var$computeRange(sq, [\n            7,\n            9\n        ])),\n    black: $9fc1d75359bd39d5$var$tabulate((sq)=>$9fc1d75359bd39d5$var$computeRange(sq, [\n            -7,\n            -9\n        ]))\n};\nconst $9fc1d75359bd39d5$export$a60166eda477d9f1 = (square)=>$9fc1d75359bd39d5$var$KING_ATTACKS[square];\nconst $9fc1d75359bd39d5$export$f98f014d8442d39e = (square)=>$9fc1d75359bd39d5$var$KNIGHT_ATTACKS[square];\nconst $9fc1d75359bd39d5$export$891089f6415f4f9e = (color, square)=>$9fc1d75359bd39d5$var$PAWN_ATTACKS[color][square];\nconst $9fc1d75359bd39d5$var$FILE_RANGE = $9fc1d75359bd39d5$var$tabulate((sq)=>(0, $9894c45c69033325$export$1cb45477e81f9503).fromFile((0, $ced645034f45bdd3$export$4e7f80514dc39415)(sq)).without(sq));\nconst $9fc1d75359bd39d5$var$RANK_RANGE = $9fc1d75359bd39d5$var$tabulate((sq)=>(0, $9894c45c69033325$export$1cb45477e81f9503).fromRank((0, $ced645034f45bdd3$export$8ec54076fe05cd3f)(sq)).without(sq));\nconst $9fc1d75359bd39d5$var$DIAG_RANGE = $9fc1d75359bd39d5$var$tabulate((sq)=>{\n    const diag = new (0, $9894c45c69033325$export$1cb45477e81f9503)(134480385, 2151686160);\n    const shift = 8 * ((0, $ced645034f45bdd3$export$8ec54076fe05cd3f)(sq) - (0, $ced645034f45bdd3$export$4e7f80514dc39415)(sq));\n    return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);\n});\nconst $9fc1d75359bd39d5$var$ANTI_DIAG_RANGE = $9fc1d75359bd39d5$var$tabulate((sq)=>{\n    const diag = new (0, $9894c45c69033325$export$1cb45477e81f9503)(270549120, 16909320);\n    const shift = 8 * ((0, $ced645034f45bdd3$export$8ec54076fe05cd3f)(sq) + (0, $ced645034f45bdd3$export$4e7f80514dc39415)(sq) - 7);\n    return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);\n});\nconst $9fc1d75359bd39d5$var$hyperbola = (bit, range, occupied)=>{\n    let forward = occupied.intersect(range);\n    let reverse = forward.bswap64(); // Assumes no more than 1 bit per rank\n    forward = forward.minus64(bit);\n    reverse = reverse.minus64(bit.bswap64());\n    return forward.xor(reverse.bswap64()).intersect(range);\n};\nconst $9fc1d75359bd39d5$var$fileAttacks = (square, occupied)=>$9fc1d75359bd39d5$var$hyperbola((0, $9894c45c69033325$export$1cb45477e81f9503).fromSquare(square), $9fc1d75359bd39d5$var$FILE_RANGE[square], occupied);\nconst $9fc1d75359bd39d5$var$rankAttacks = (square, occupied)=>{\n    const range = $9fc1d75359bd39d5$var$RANK_RANGE[square];\n    let forward = occupied.intersect(range);\n    let reverse = forward.rbit64();\n    forward = forward.minus64((0, $9894c45c69033325$export$1cb45477e81f9503).fromSquare(square));\n    reverse = reverse.minus64((0, $9894c45c69033325$export$1cb45477e81f9503).fromSquare(63 - square));\n    return forward.xor(reverse.rbit64()).intersect(range);\n};\nconst $9fc1d75359bd39d5$export$b599b52d035a6fc7 = (square, occupied)=>{\n    const bit = (0, $9894c45c69033325$export$1cb45477e81f9503).fromSquare(square);\n    return $9fc1d75359bd39d5$var$hyperbola(bit, $9fc1d75359bd39d5$var$DIAG_RANGE[square], occupied).xor($9fc1d75359bd39d5$var$hyperbola(bit, $9fc1d75359bd39d5$var$ANTI_DIAG_RANGE[square], occupied));\n};\nconst $9fc1d75359bd39d5$export$1f4e7eaa3e729013 = (square, occupied)=>$9fc1d75359bd39d5$var$fileAttacks(square, occupied).xor($9fc1d75359bd39d5$var$rankAttacks(square, occupied));\nconst $9fc1d75359bd39d5$export$91813132f8c8e3a9 = (square, occupied)=>$9fc1d75359bd39d5$export$b599b52d035a6fc7(square, occupied).xor($9fc1d75359bd39d5$export$1f4e7eaa3e729013(square, occupied));\nconst $9fc1d75359bd39d5$export$798972466b295256 = (piece, square, occupied)=>{\n    switch(piece.role){\n        case 'pawn':\n            return $9fc1d75359bd39d5$export$891089f6415f4f9e(piece.color, square);\n        case 'knight':\n            return $9fc1d75359bd39d5$export$f98f014d8442d39e(square);\n        case 'bishop':\n            return $9fc1d75359bd39d5$export$b599b52d035a6fc7(square, occupied);\n        case 'rook':\n            return $9fc1d75359bd39d5$export$1f4e7eaa3e729013(square, occupied);\n        case 'queen':\n            return $9fc1d75359bd39d5$export$91813132f8c8e3a9(square, occupied);\n        case 'king':\n            return $9fc1d75359bd39d5$export$a60166eda477d9f1(square);\n    }\n};\nconst $9fc1d75359bd39d5$export$e006947b4f05482d = (a, b)=>{\n    const other = (0, $9894c45c69033325$export$1cb45477e81f9503).fromSquare(b);\n    if ($9fc1d75359bd39d5$var$RANK_RANGE[a].intersects(other)) return $9fc1d75359bd39d5$var$RANK_RANGE[a].with(a);\n    if ($9fc1d75359bd39d5$var$ANTI_DIAG_RANGE[a].intersects(other)) return $9fc1d75359bd39d5$var$ANTI_DIAG_RANGE[a].with(a);\n    if ($9fc1d75359bd39d5$var$DIAG_RANGE[a].intersects(other)) return $9fc1d75359bd39d5$var$DIAG_RANGE[a].with(a);\n    if ($9fc1d75359bd39d5$var$FILE_RANGE[a].intersects(other)) return $9fc1d75359bd39d5$var$FILE_RANGE[a].with(a);\n    return (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n};\nconst $9fc1d75359bd39d5$export$cf95c51b03f10bae = (a, b)=>$9fc1d75359bd39d5$export$e006947b4f05482d(a, b).intersect((0, $9894c45c69033325$export$1cb45477e81f9503).full().shl64(a).xor((0, $9894c45c69033325$export$1cb45477e81f9503).full().shl64(b))).withoutFirst();\n\n\n\n\nclass $4f484c5772f22add$export$dc537a3a3893548e {\n    constructor(){}\n    static default() {\n        const board = new $4f484c5772f22add$export$dc537a3a3893548e();\n        board.reset();\n        return board;\n    }\n    /**\n     * Resets all pieces to the default starting position for standard chess.\n     */ reset() {\n        this.occupied = new (0, $9894c45c69033325$export$1cb45477e81f9503)(0xffff, 4294901760);\n        this.promoted = (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n        this.white = new (0, $9894c45c69033325$export$1cb45477e81f9503)(0xffff, 0);\n        this.black = new (0, $9894c45c69033325$export$1cb45477e81f9503)(0, 4294901760);\n        this.pawn = new (0, $9894c45c69033325$export$1cb45477e81f9503)(0xff00, 16711680);\n        this.knight = new (0, $9894c45c69033325$export$1cb45477e81f9503)(0x42, 1107296256);\n        this.bishop = new (0, $9894c45c69033325$export$1cb45477e81f9503)(0x24, 603979776);\n        this.rook = new (0, $9894c45c69033325$export$1cb45477e81f9503)(0x81, 2164260864);\n        this.queen = new (0, $9894c45c69033325$export$1cb45477e81f9503)(0x8, 134217728);\n        this.king = new (0, $9894c45c69033325$export$1cb45477e81f9503)(0x10, 268435456);\n    }\n    static empty() {\n        const board = new $4f484c5772f22add$export$dc537a3a3893548e();\n        board.clear();\n        return board;\n    }\n    clear() {\n        this.occupied = (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n        this.promoted = (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n        for (const color of (0, $c489d07ce8bc1a25$export$56d196d2844d1ca1))this[color] = (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n        for (const role of (0, $c489d07ce8bc1a25$export$d1cfdc29cbc61821))this[role] = (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n    }\n    clone() {\n        const board = new $4f484c5772f22add$export$dc537a3a3893548e();\n        board.occupied = this.occupied;\n        board.promoted = this.promoted;\n        for (const color of (0, $c489d07ce8bc1a25$export$56d196d2844d1ca1))board[color] = this[color];\n        for (const role of (0, $c489d07ce8bc1a25$export$d1cfdc29cbc61821))board[role] = this[role];\n        return board;\n    }\n    getColor(square) {\n        if (this.white.has(square)) return 'white';\n        if (this.black.has(square)) return 'black';\n        return;\n    }\n    getRole(square) {\n        for (const role of (0, $c489d07ce8bc1a25$export$d1cfdc29cbc61821)){\n            if (this[role].has(square)) return role;\n        }\n        return;\n    }\n    get(square) {\n        const color = this.getColor(square);\n        if (!color) return;\n        const role = this.getRole(square);\n        const promoted = this.promoted.has(square);\n        return {\n            color: color,\n            role: role,\n            promoted: promoted\n        };\n    }\n    /**\n     * Removes and returns the piece from the given `square`, if any.\n     */ take(square) {\n        const piece = this.get(square);\n        if (piece) {\n            this.occupied = this.occupied.without(square);\n            this[piece.color] = this[piece.color].without(square);\n            this[piece.role] = this[piece.role].without(square);\n            if (piece.promoted) this.promoted = this.promoted.without(square);\n        }\n        return piece;\n    }\n    /**\n     * Put `piece` onto `square`, potentially replacing an existing piece.\n     * Returns the existing piece, if any.\n     */ set(square, piece) {\n        const old = this.take(square);\n        this.occupied = this.occupied.with(square);\n        this[piece.color] = this[piece.color].with(square);\n        this[piece.role] = this[piece.role].with(square);\n        if (piece.promoted) this.promoted = this.promoted.with(square);\n        return old;\n    }\n    has(square) {\n        return this.occupied.has(square);\n    }\n    *[Symbol.iterator]() {\n        for (const square of this.occupied)yield [\n            square,\n            this.get(square)\n        ];\n    }\n    pieces(color, role) {\n        return this[color].intersect(this[role]);\n    }\n    rooksAndQueens() {\n        return this.rook.union(this.queen);\n    }\n    bishopsAndQueens() {\n        return this.bishop.union(this.queen);\n    }\n    /**\n     * Finds the unique king of the given `color`, if any.\n     */ kingOf(color) {\n        return this.pieces(color, 'king').singleSquare();\n    }\n}\nconst $4f484c5772f22add$export$2df5e23f048ea965 = (left, right)=>left.white.equals(right.white) && left.promoted.equals(right.promoted) && (0, $c489d07ce8bc1a25$export$d1cfdc29cbc61821).every((role)=>left[role].equals(right[role]));\n\n\n\n\n\nvar $9c49db522b46d242$export$5426f43bd8f77457;\n(function(IllegalSetup) {\n    IllegalSetup[\"Empty\"] = \"ERR_EMPTY\";\n    IllegalSetup[\"OppositeCheck\"] = \"ERR_OPPOSITE_CHECK\";\n    IllegalSetup[\"PawnsOnBackrank\"] = \"ERR_PAWNS_ON_BACKRANK\";\n    IllegalSetup[\"Kings\"] = \"ERR_KINGS\";\n    IllegalSetup[\"Variant\"] = \"ERR_VARIANT\";\n})($9c49db522b46d242$export$5426f43bd8f77457 || ($9c49db522b46d242$export$5426f43bd8f77457 = {}));\nclass $9c49db522b46d242$export$e965a47eea052e24 extends Error {\n}\nconst $9c49db522b46d242$var$attacksTo = (square, attacker, board, occupied)=>board[attacker].intersect((0, $9fc1d75359bd39d5$export$1f4e7eaa3e729013)(square, occupied).intersect(board.rooksAndQueens()).union((0, $9fc1d75359bd39d5$export$b599b52d035a6fc7)(square, occupied).intersect(board.bishopsAndQueens())).union((0, $9fc1d75359bd39d5$export$f98f014d8442d39e)(square).intersect(board.knight)).union((0, $9fc1d75359bd39d5$export$a60166eda477d9f1)(square).intersect(board.king)).union((0, $9fc1d75359bd39d5$export$891089f6415f4f9e)((0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(attacker), square).intersect(board.pawn)));\nclass $9c49db522b46d242$export$9e972839f626f452 {\n    constructor(){}\n    static default() {\n        const castles = new $9c49db522b46d242$export$9e972839f626f452();\n        castles.castlingRights = (0, $9894c45c69033325$export$1cb45477e81f9503).corners();\n        castles.rook = {\n            white: {\n                a: 0,\n                h: 7\n            },\n            black: {\n                a: 56,\n                h: 63\n            }\n        };\n        castles.path = {\n            white: {\n                a: new (0, $9894c45c69033325$export$1cb45477e81f9503)(0xe, 0),\n                h: new (0, $9894c45c69033325$export$1cb45477e81f9503)(0x60, 0)\n            },\n            black: {\n                a: new (0, $9894c45c69033325$export$1cb45477e81f9503)(0, 0x0e000000),\n                h: new (0, $9894c45c69033325$export$1cb45477e81f9503)(0, 0x60000000)\n            }\n        };\n        return castles;\n    }\n    static empty() {\n        const castles = new $9c49db522b46d242$export$9e972839f626f452();\n        castles.castlingRights = (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n        castles.rook = {\n            white: {\n                a: undefined,\n                h: undefined\n            },\n            black: {\n                a: undefined,\n                h: undefined\n            }\n        };\n        castles.path = {\n            white: {\n                a: (0, $9894c45c69033325$export$1cb45477e81f9503).empty(),\n                h: (0, $9894c45c69033325$export$1cb45477e81f9503).empty()\n            },\n            black: {\n                a: (0, $9894c45c69033325$export$1cb45477e81f9503).empty(),\n                h: (0, $9894c45c69033325$export$1cb45477e81f9503).empty()\n            }\n        };\n        return castles;\n    }\n    clone() {\n        const castles = new $9c49db522b46d242$export$9e972839f626f452();\n        castles.castlingRights = this.castlingRights;\n        castles.rook = {\n            white: {\n                a: this.rook.white.a,\n                h: this.rook.white.h\n            },\n            black: {\n                a: this.rook.black.a,\n                h: this.rook.black.h\n            }\n        };\n        castles.path = {\n            white: {\n                a: this.path.white.a,\n                h: this.path.white.h\n            },\n            black: {\n                a: this.path.black.a,\n                h: this.path.black.h\n            }\n        };\n        return castles;\n    }\n    add(color, side, king, rook) {\n        const kingTo = (0, $ced645034f45bdd3$export$9d0713081c523620)(color, side);\n        const rookTo = (0, $ced645034f45bdd3$export$d958227fca9654a5)(color, side);\n        this.castlingRights = this.castlingRights.with(rook);\n        this.rook[color][side] = rook;\n        this.path[color][side] = (0, $9fc1d75359bd39d5$export$cf95c51b03f10bae)(rook, rookTo).with(rookTo).union((0, $9fc1d75359bd39d5$export$cf95c51b03f10bae)(king, kingTo).with(kingTo)).without(king).without(rook);\n    }\n    static fromSetup(setup) {\n        const castles = $9c49db522b46d242$export$9e972839f626f452.empty();\n        const rooks = setup.castlingRights.intersect(setup.board.rook);\n        for (const color of (0, $c489d07ce8bc1a25$export$56d196d2844d1ca1)){\n            const backrank = (0, $9894c45c69033325$export$1cb45477e81f9503).backrank(color);\n            const king = setup.board.kingOf(color);\n            if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(king) || !backrank.has(king)) continue;\n            const side = rooks.intersect(setup.board[color]).intersect(backrank);\n            const aSide = side.first();\n            if ((0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(aSide) && aSide < king) castles.add(color, 'a', king, aSide);\n            const hSide = side.last();\n            if ((0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(hSide) && king < hSide) castles.add(color, 'h', king, hSide);\n        }\n        return castles;\n    }\n    discardRook(square) {\n        if (this.castlingRights.has(square)) {\n            this.castlingRights = this.castlingRights.without(square);\n            for (const color of (0, $c489d07ce8bc1a25$export$56d196d2844d1ca1)){\n                for (const side of (0, $c489d07ce8bc1a25$export$2ac9b71d100b39a1))if (this.rook[color][side] === square) this.rook[color][side] = undefined;\n            }\n        }\n    }\n    discardColor(color) {\n        this.castlingRights = this.castlingRights.diff((0, $9894c45c69033325$export$1cb45477e81f9503).backrank(color));\n        this.rook[color].a = undefined;\n        this.rook[color].h = undefined;\n    }\n}\nclass $9c49db522b46d242$export$13807d9ee5a34a42 {\n    constructor(rules){\n        this.rules = rules;\n    }\n    reset() {\n        this.board = (0, $4f484c5772f22add$export$dc537a3a3893548e).default();\n        this.pockets = undefined;\n        this.turn = 'white';\n        this.castles = $9c49db522b46d242$export$9e972839f626f452.default();\n        this.epSquare = undefined;\n        this.remainingChecks = undefined;\n        this.halfmoves = 0;\n        this.fullmoves = 1;\n    }\n    setupUnchecked(setup) {\n        this.board = setup.board.clone();\n        this.board.promoted = (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n        this.pockets = undefined;\n        this.turn = setup.turn;\n        this.castles = $9c49db522b46d242$export$9e972839f626f452.fromSetup(setup);\n        this.epSquare = $9c49db522b46d242$var$validEpSquare(this, setup.epSquare);\n        this.remainingChecks = undefined;\n        this.halfmoves = setup.halfmoves;\n        this.fullmoves = setup.fullmoves;\n    }\n    // When subclassing overwrite at least:\n    //\n    // - static default()\n    // - static fromSetup()\n    // - static clone()\n    //\n    // - dests()\n    // - isVariantEnd()\n    // - variantOutcome()\n    // - hasInsufficientMaterial()\n    // - isStandardMaterial()\n    kingAttackers(square, attacker, occupied) {\n        return $9c49db522b46d242$var$attacksTo(square, attacker, this.board, occupied);\n    }\n    playCaptureAt(square, captured) {\n        this.halfmoves = 0;\n        if (captured.role === 'rook') this.castles.discardRook(square);\n        if (this.pockets) this.pockets[(0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(captured.color)][captured.promoted ? 'pawn' : captured.role]++;\n    }\n    ctx() {\n        const variantEnd = this.isVariantEnd();\n        const king = this.board.kingOf(this.turn);\n        if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(king)) return {\n            king: king,\n            blockers: (0, $9894c45c69033325$export$1cb45477e81f9503).empty(),\n            checkers: (0, $9894c45c69033325$export$1cb45477e81f9503).empty(),\n            variantEnd: variantEnd,\n            mustCapture: false\n        };\n        const snipers = (0, $9fc1d75359bd39d5$export$1f4e7eaa3e729013)(king, (0, $9894c45c69033325$export$1cb45477e81f9503).empty()).intersect(this.board.rooksAndQueens()).union((0, $9fc1d75359bd39d5$export$b599b52d035a6fc7)(king, (0, $9894c45c69033325$export$1cb45477e81f9503).empty()).intersect(this.board.bishopsAndQueens())).intersect(this.board[(0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(this.turn)]);\n        let blockers = (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n        for (const sniper of snipers){\n            const b = (0, $9fc1d75359bd39d5$export$cf95c51b03f10bae)(king, sniper).intersect(this.board.occupied);\n            if (!b.moreThanOne()) blockers = blockers.union(b);\n        }\n        const checkers = this.kingAttackers(king, (0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(this.turn), this.board.occupied);\n        return {\n            king: king,\n            blockers: blockers,\n            checkers: checkers,\n            variantEnd: variantEnd,\n            mustCapture: false\n        };\n    }\n    clone() {\n        var _a, _b;\n        const pos = new this.constructor();\n        pos.board = this.board.clone();\n        pos.pockets = (_a = this.pockets) === null || _a === void 0 ? void 0 : _a.clone();\n        pos.turn = this.turn;\n        pos.castles = this.castles.clone();\n        pos.epSquare = this.epSquare;\n        pos.remainingChecks = (_b = this.remainingChecks) === null || _b === void 0 ? void 0 : _b.clone();\n        pos.halfmoves = this.halfmoves;\n        pos.fullmoves = this.fullmoves;\n        return pos;\n    }\n    validate() {\n        if (this.board.occupied.isEmpty()) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9c49db522b46d242$export$e965a47eea052e24($9c49db522b46d242$export$5426f43bd8f77457.Empty));\n        if (this.board.king.size() !== 2) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9c49db522b46d242$export$e965a47eea052e24($9c49db522b46d242$export$5426f43bd8f77457.Kings));\n        if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(this.board.kingOf(this.turn))) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9c49db522b46d242$export$e965a47eea052e24($9c49db522b46d242$export$5426f43bd8f77457.Kings));\n        const otherKing = this.board.kingOf((0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(this.turn));\n        if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(otherKing)) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9c49db522b46d242$export$e965a47eea052e24($9c49db522b46d242$export$5426f43bd8f77457.Kings));\n        if (this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty()) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9c49db522b46d242$export$e965a47eea052e24($9c49db522b46d242$export$5426f43bd8f77457.OppositeCheck));\n        if ((0, $9894c45c69033325$export$1cb45477e81f9503).backranks().intersects(this.board.pawn)) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9c49db522b46d242$export$e965a47eea052e24($9c49db522b46d242$export$5426f43bd8f77457.PawnsOnBackrank));\n        return (0, $0b15f372ed432f56$export$8fdcabde73f49165).ok(undefined);\n    }\n    dropDests(_ctx) {\n        return (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n    }\n    dests(square, ctx) {\n        ctx = ctx || this.ctx();\n        if (ctx.variantEnd) return (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n        const piece = this.board.get(square);\n        if (!piece || piece.color !== this.turn) return (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n        let pseudo, legal;\n        if (piece.role === 'pawn') {\n            pseudo = (0, $9fc1d75359bd39d5$export$891089f6415f4f9e)(this.turn, square).intersect(this.board[(0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(this.turn)]);\n            const delta = this.turn === 'white' ? 8 : -8;\n            const step = square + delta;\n            if (0 <= step && step < 64 && !this.board.occupied.has(step)) {\n                pseudo = pseudo.with(step);\n                const canDoubleStep = this.turn === 'white' ? square < 16 : square >= 48;\n                const doubleStep = step + delta;\n                if (canDoubleStep && !this.board.occupied.has(doubleStep)) pseudo = pseudo.with(doubleStep);\n            }\n            if ((0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(this.epSquare) && $9c49db522b46d242$var$canCaptureEp(this, square, ctx)) legal = (0, $9894c45c69033325$export$1cb45477e81f9503).fromSquare(this.epSquare);\n        } else if (piece.role === 'bishop') pseudo = (0, $9fc1d75359bd39d5$export$b599b52d035a6fc7)(square, this.board.occupied);\n        else if (piece.role === 'knight') pseudo = (0, $9fc1d75359bd39d5$export$f98f014d8442d39e)(square);\n        else if (piece.role === 'rook') pseudo = (0, $9fc1d75359bd39d5$export$1f4e7eaa3e729013)(square, this.board.occupied);\n        else if (piece.role === 'queen') pseudo = (0, $9fc1d75359bd39d5$export$91813132f8c8e3a9)(square, this.board.occupied);\n        else pseudo = (0, $9fc1d75359bd39d5$export$a60166eda477d9f1)(square);\n        pseudo = pseudo.diff(this.board[this.turn]);\n        if ((0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(ctx.king)) {\n            if (piece.role === 'king') {\n                const occ = this.board.occupied.without(square);\n                for (const to of pseudo)if (this.kingAttackers(to, (0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(this.turn), occ).nonEmpty()) pseudo = pseudo.without(to);\n                return pseudo.union($9c49db522b46d242$var$castlingDest(this, 'a', ctx)).union($9c49db522b46d242$var$castlingDest(this, 'h', ctx));\n            }\n            if (ctx.checkers.nonEmpty()) {\n                const checker = ctx.checkers.singleSquare();\n                if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(checker)) return (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n                pseudo = pseudo.intersect((0, $9fc1d75359bd39d5$export$cf95c51b03f10bae)(checker, ctx.king).with(checker));\n            }\n            if (ctx.blockers.has(square)) pseudo = pseudo.intersect((0, $9fc1d75359bd39d5$export$e006947b4f05482d)(square, ctx.king));\n        }\n        if (legal) pseudo = pseudo.union(legal);\n        return pseudo;\n    }\n    isVariantEnd() {\n        return false;\n    }\n    variantOutcome(_ctx) {\n        return;\n    }\n    hasInsufficientMaterial(color) {\n        if (this.board[color].intersect(this.board.pawn.union(this.board.rooksAndQueens())).nonEmpty()) return false;\n        if (this.board[color].intersects(this.board.knight)) return this.board[color].size() <= 2 && this.board[(0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(color)].diff(this.board.king).diff(this.board.queen).isEmpty();\n        if (this.board[color].intersects(this.board.bishop)) {\n            const sameColor = !this.board.bishop.intersects((0, $9894c45c69033325$export$1cb45477e81f9503).darkSquares()) || !this.board.bishop.intersects((0, $9894c45c69033325$export$1cb45477e81f9503).lightSquares());\n            return sameColor && this.board.pawn.isEmpty() && this.board.knight.isEmpty();\n        }\n        return true;\n    }\n    // The following should be identical in all subclasses\n    toSetup() {\n        var _a, _b;\n        return {\n            board: this.board.clone(),\n            pockets: (_a = this.pockets) === null || _a === void 0 ? void 0 : _a.clone(),\n            turn: this.turn,\n            castlingRights: this.castles.castlingRights,\n            epSquare: $9c49db522b46d242$var$legalEpSquare(this),\n            remainingChecks: (_b = this.remainingChecks) === null || _b === void 0 ? void 0 : _b.clone(),\n            halfmoves: Math.min(this.halfmoves, 150),\n            fullmoves: Math.min(Math.max(this.fullmoves, 1), 9999)\n        };\n    }\n    isInsufficientMaterial() {\n        return (0, $c489d07ce8bc1a25$export$56d196d2844d1ca1).every((color)=>this.hasInsufficientMaterial(color));\n    }\n    hasDests(ctx) {\n        ctx = ctx || this.ctx();\n        for (const square of this.board[this.turn]){\n            if (this.dests(square, ctx).nonEmpty()) return true;\n        }\n        return this.dropDests(ctx).nonEmpty();\n    }\n    isLegal(move, ctx) {\n        if ((0, $c489d07ce8bc1a25$export$90ffe53e9bf2dee8)(move)) {\n            if (!this.pockets || this.pockets[this.turn][move.role] <= 0) return false;\n            if (move.role === 'pawn' && (0, $9894c45c69033325$export$1cb45477e81f9503).backranks().has(move.to)) return false;\n            return this.dropDests(ctx).has(move.to);\n        } else {\n            if (move.promotion === 'pawn') return false;\n            if (move.promotion === 'king' && this.rules !== 'antichess') return false;\n            if (!!move.promotion !== (this.board.pawn.has(move.from) && (0, $9894c45c69033325$export$1cb45477e81f9503).backranks().has(move.to))) return false;\n            const dests = this.dests(move.from, ctx);\n            return dests.has(move.to) || dests.has($9c49db522b46d242$export$c027268f00e9726(this, move).to);\n        }\n    }\n    isCheck() {\n        const king = this.board.kingOf(this.turn);\n        return (0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(king) && this.kingAttackers(king, (0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(this.turn), this.board.occupied).nonEmpty();\n    }\n    isEnd(ctx) {\n        if (ctx ? ctx.variantEnd : this.isVariantEnd()) return true;\n        return this.isInsufficientMaterial() || !this.hasDests(ctx);\n    }\n    isCheckmate(ctx) {\n        ctx = ctx || this.ctx();\n        return !ctx.variantEnd && ctx.checkers.nonEmpty() && !this.hasDests(ctx);\n    }\n    isStalemate(ctx) {\n        ctx = ctx || this.ctx();\n        return !ctx.variantEnd && ctx.checkers.isEmpty() && !this.hasDests(ctx);\n    }\n    outcome(ctx) {\n        const variantOutcome = this.variantOutcome(ctx);\n        if (variantOutcome) return variantOutcome;\n        ctx = ctx || this.ctx();\n        if (this.isCheckmate(ctx)) return {\n            winner: (0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(this.turn)\n        };\n        else if (this.isInsufficientMaterial() || this.isStalemate(ctx)) return {\n            winner: undefined\n        };\n        else return;\n    }\n    allDests(ctx) {\n        ctx = ctx || this.ctx();\n        const d = new Map();\n        if (ctx.variantEnd) return d;\n        for (const square of this.board[this.turn])d.set(square, this.dests(square, ctx));\n        return d;\n    }\n    play(move) {\n        const turn = this.turn;\n        const epSquare = this.epSquare;\n        const castling = $9c49db522b46d242$export$4cb9b6e3b2f07aa1(this, move);\n        this.epSquare = undefined;\n        this.halfmoves += 1;\n        if (turn === 'black') this.fullmoves += 1;\n        this.turn = (0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(turn);\n        if ((0, $c489d07ce8bc1a25$export$90ffe53e9bf2dee8)(move)) {\n            this.board.set(move.to, {\n                role: move.role,\n                color: turn\n            });\n            if (this.pockets) this.pockets[turn][move.role]--;\n            if (move.role === 'pawn') this.halfmoves = 0;\n        } else {\n            const piece = this.board.take(move.from);\n            if (!piece) return;\n            let epCapture;\n            if (piece.role === 'pawn') {\n                this.halfmoves = 0;\n                if (move.to === epSquare) epCapture = this.board.take(move.to + (turn === 'white' ? -8 : 8));\n                const delta = move.from - move.to;\n                if (Math.abs(delta) === 16 && 8 <= move.from && move.from <= 55) this.epSquare = move.from + move.to >> 1;\n                if (move.promotion) {\n                    piece.role = move.promotion;\n                    piece.promoted = !!this.pockets;\n                }\n            } else if (piece.role === 'rook') this.castles.discardRook(move.from);\n            else if (piece.role === 'king') {\n                if (castling) {\n                    const rookFrom = this.castles.rook[turn][castling];\n                    if ((0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(rookFrom)) {\n                        const rook = this.board.take(rookFrom);\n                        this.board.set((0, $ced645034f45bdd3$export$9d0713081c523620)(turn, castling), piece);\n                        if (rook) this.board.set((0, $ced645034f45bdd3$export$d958227fca9654a5)(turn, castling), rook);\n                    }\n                }\n                this.castles.discardColor(turn);\n            }\n            if (!castling) {\n                const capture = this.board.set(move.to, piece) || epCapture;\n                if (capture) this.playCaptureAt(move.to, capture);\n            }\n        }\n        if (this.remainingChecks) {\n            if (this.isCheck()) this.remainingChecks[turn] = Math.max(this.remainingChecks[turn] - 1, 0);\n        }\n    }\n}\nclass $9c49db522b46d242$export$a4d6ea685c300d39 extends $9c49db522b46d242$export$13807d9ee5a34a42 {\n    constructor(){\n        super('chess');\n    }\n    static default() {\n        const pos = new this();\n        pos.reset();\n        return pos;\n    }\n    static fromSetup(setup) {\n        const pos = new this();\n        pos.setupUnchecked(setup);\n        return pos.validate().map((_)=>pos);\n    }\n    clone() {\n        return super.clone();\n    }\n}\nconst $9c49db522b46d242$var$validEpSquare = (pos, square)=>{\n    if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(square)) return;\n    const epRank = pos.turn === 'white' ? 5 : 2;\n    const forward = pos.turn === 'white' ? 8 : -8;\n    if ((0, $ced645034f45bdd3$export$8ec54076fe05cd3f)(square) !== epRank) return;\n    if (pos.board.occupied.has(square + forward)) return;\n    const pawn = square - forward;\n    if (!pos.board.pawn.has(pawn) || !pos.board[(0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(pos.turn)].has(pawn)) return;\n    return square;\n};\nconst $9c49db522b46d242$var$legalEpSquare = (pos)=>{\n    if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(pos.epSquare)) return;\n    const ctx = pos.ctx();\n    const ourPawns = pos.board.pieces(pos.turn, 'pawn');\n    const candidates = ourPawns.intersect((0, $9fc1d75359bd39d5$export$891089f6415f4f9e)((0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(pos.turn), pos.epSquare));\n    for (const candidate of candidates){\n        if (pos.dests(candidate, ctx).has(pos.epSquare)) return pos.epSquare;\n    }\n    return;\n};\nconst $9c49db522b46d242$var$canCaptureEp = (pos, pawnFrom, ctx)=>{\n    if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(pos.epSquare)) return false;\n    if (!(0, $9fc1d75359bd39d5$export$891089f6415f4f9e)(pos.turn, pawnFrom).has(pos.epSquare)) return false;\n    if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(ctx.king)) return true;\n    const delta = pos.turn === 'white' ? 8 : -8;\n    const captured = pos.epSquare - delta;\n    return pos.kingAttackers(ctx.king, (0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(pos.turn), pos.board.occupied.toggle(pawnFrom).toggle(captured).with(pos.epSquare)).without(captured).isEmpty();\n};\nconst $9c49db522b46d242$var$castlingDest = (pos, side, ctx)=>{\n    if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(ctx.king) || ctx.checkers.nonEmpty()) return (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n    const rook = pos.castles.rook[pos.turn][side];\n    if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(rook)) return (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n    if (pos.castles.path[pos.turn][side].intersects(pos.board.occupied)) return (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n    const kingTo = (0, $ced645034f45bdd3$export$9d0713081c523620)(pos.turn, side);\n    const kingPath = (0, $9fc1d75359bd39d5$export$cf95c51b03f10bae)(ctx.king, kingTo);\n    const occ = pos.board.occupied.without(ctx.king);\n    for (const sq of kingPath){\n        if (pos.kingAttackers(sq, (0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(pos.turn), occ).nonEmpty()) return (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n    }\n    const rookTo = (0, $ced645034f45bdd3$export$d958227fca9654a5)(pos.turn, side);\n    const after = pos.board.occupied.toggle(ctx.king).toggle(rook).toggle(rookTo);\n    if (pos.kingAttackers(kingTo, (0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(pos.turn), after).nonEmpty()) return (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n    return (0, $9894c45c69033325$export$1cb45477e81f9503).fromSquare(rook);\n};\nconst $9c49db522b46d242$export$2212a30ce213ff8b = (pos, square, ctx)=>{\n    if (ctx.variantEnd) return (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n    const piece = pos.board.get(square);\n    if (!piece || piece.color !== pos.turn) return (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n    let pseudo = (0, $9fc1d75359bd39d5$export$798972466b295256)(piece, square, pos.board.occupied);\n    if (piece.role === 'pawn') {\n        let captureTargets = pos.board[(0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(pos.turn)];\n        if ((0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(pos.epSquare)) captureTargets = captureTargets.with(pos.epSquare);\n        pseudo = pseudo.intersect(captureTargets);\n        const delta = pos.turn === 'white' ? 8 : -8;\n        const step = square + delta;\n        if (0 <= step && step < 64 && !pos.board.occupied.has(step)) {\n            pseudo = pseudo.with(step);\n            const canDoubleStep = pos.turn === 'white' ? square < 16 : square >= 48;\n            const doubleStep = step + delta;\n            if (canDoubleStep && !pos.board.occupied.has(doubleStep)) pseudo = pseudo.with(doubleStep);\n        }\n        return pseudo;\n    } else pseudo = pseudo.diff(pos.board[pos.turn]);\n    if (square === ctx.king) return pseudo.union($9c49db522b46d242$var$castlingDest(pos, 'a', ctx)).union($9c49db522b46d242$var$castlingDest(pos, 'h', ctx));\n    else return pseudo;\n};\nconst $9c49db522b46d242$export$624b05aa8bdfb977 = (left, right)=>{\n    var _a, _b;\n    return left.rules === right.rules && (0, $4f484c5772f22add$export$2df5e23f048ea965)(left.board, right.board) && (right.pockets && ((_a = left.pockets) === null || _a === void 0 ? void 0 : _a.equals(right.pockets)) || !left.pockets && !right.pockets) && left.turn === right.turn && left.castles.castlingRights.equals(right.castles.castlingRights) && $9c49db522b46d242$var$legalEpSquare(left) === $9c49db522b46d242$var$legalEpSquare(right) && (right.remainingChecks && ((_b = left.remainingChecks) === null || _b === void 0 ? void 0 : _b.equals(right.remainingChecks)) || !left.remainingChecks && !right.remainingChecks);\n};\nconst $9c49db522b46d242$export$4cb9b6e3b2f07aa1 = (pos, move)=>{\n    if ((0, $c489d07ce8bc1a25$export$90ffe53e9bf2dee8)(move)) return;\n    const delta = move.to - move.from;\n    if (Math.abs(delta) !== 2 && !pos.board[pos.turn].has(move.to)) return;\n    if (!pos.board.king.has(move.from)) return;\n    return delta > 0 ? 'h' : 'a';\n};\nconst $9c49db522b46d242$export$c027268f00e9726 = (pos, move)=>{\n    const side = $9c49db522b46d242$export$4cb9b6e3b2f07aa1(pos, move);\n    if (!side) return move;\n    const rookFrom = pos.castles.rook[pos.turn][side];\n    return {\n        from: move.from,\n        to: (0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(rookFrom) ? rookFrom : move.to\n    };\n};\nconst $9c49db522b46d242$export$f84506c6015614a9 = (board, color)=>{\n    const promoted = Math.max(board.pieces(color, 'queen').size() - 1, 0) + Math.max(board.pieces(color, 'rook').size() - 2, 0) + Math.max(board.pieces(color, 'knight').size() - 2, 0) + Math.max(board.pieces(color, 'bishop').intersect((0, $9894c45c69033325$export$1cb45477e81f9503).lightSquares()).size() - 1, 0) + Math.max(board.pieces(color, 'bishop').intersect((0, $9894c45c69033325$export$1cb45477e81f9503).darkSquares()).size() - 1, 0);\n    return board.pieces(color, 'pawn').size() + promoted <= 8;\n};\nconst $9c49db522b46d242$export$bd445a4f8370b163 = (pos)=>(0, $c489d07ce8bc1a25$export$56d196d2844d1ca1).every((color)=>$9c49db522b46d242$export$f84506c6015614a9(pos.board, color));\nconst $9c49db522b46d242$export$52095c4625d3b79d = (pos)=>{\n    const ourKing = pos.board.kingOf(pos.turn);\n    if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(ourKing)) return false;\n    const checkers = pos.kingAttackers(ourKing, (0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(pos.turn), pos.board.occupied);\n    if (checkers.isEmpty()) return false;\n    if ((0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(pos.epSquare)) {\n        // The pushed pawn must be the only checker, or it has uncovered\n        // check by a single sliding piece.\n        const pushedTo = pos.epSquare ^ 8;\n        const pushedFrom = pos.epSquare ^ 24;\n        return checkers.moreThanOne() || checkers.first() !== pushedTo && pos.kingAttackers(ourKing, (0, $ced645034f45bdd3$export$a27c3a1c44ba515b)(pos.turn), pos.board.occupied.without(pushedTo).with(pushedFrom)).nonEmpty();\n    } else if (pos.rules === 'atomic') // Other king moving away can cause many checks to be given at the same\n    // time. Not checking details, or even that the king is close enough.\n    return false;\n    else // Sliding checkers aligned with king.\n    return checkers.size() > 2 || checkers.size() === 2 && (0, $9fc1d75359bd39d5$export$e006947b4f05482d)(checkers.first(), checkers.last()).has(ourKing);\n};\n\nvar $9d83a5ecbd86440e$exports = {};\n\n$parcel$export($9d83a5ecbd86440e$exports, \"INITIAL_BOARD_FEN\", function () { return $9d83a5ecbd86440e$export$a7af5e4473279ca4; });\n$parcel$export($9d83a5ecbd86440e$exports, \"INITIAL_EPD\", function () { return $9d83a5ecbd86440e$export$f55e4ecc51581d46; });\n$parcel$export($9d83a5ecbd86440e$exports, \"INITIAL_FEN\", function () { return $9d83a5ecbd86440e$export$e7275301a68905e5; });\n$parcel$export($9d83a5ecbd86440e$exports, \"EMPTY_BOARD_FEN\", function () { return $9d83a5ecbd86440e$export$cf2dfba1ebb0c02f; });\n$parcel$export($9d83a5ecbd86440e$exports, \"EMPTY_EPD\", function () { return $9d83a5ecbd86440e$export$a8056043964453a9; });\n$parcel$export($9d83a5ecbd86440e$exports, \"EMPTY_FEN\", function () { return $9d83a5ecbd86440e$export$5dd74b96db3f93aa; });\n$parcel$export($9d83a5ecbd86440e$exports, \"InvalidFen\", function () { return $9d83a5ecbd86440e$export$c3be932223332a30; });\n$parcel$export($9d83a5ecbd86440e$exports, \"FenError\", function () { return $9d83a5ecbd86440e$export$e160fb1161fc30ea; });\n$parcel$export($9d83a5ecbd86440e$exports, \"parseBoardFen\", function () { return $9d83a5ecbd86440e$export$1fedd4affc50d07d; });\n$parcel$export($9d83a5ecbd86440e$exports, \"parsePockets\", function () { return $9d83a5ecbd86440e$export$b5493de85cc66c92; });\n$parcel$export($9d83a5ecbd86440e$exports, \"parseCastlingFen\", function () { return $9d83a5ecbd86440e$export$4d18bb43bf7a3116; });\n$parcel$export($9d83a5ecbd86440e$exports, \"parseRemainingChecks\", function () { return $9d83a5ecbd86440e$export$fca9881f86ac8234; });\n$parcel$export($9d83a5ecbd86440e$exports, \"parseFen\", function () { return $9d83a5ecbd86440e$export$d6cccad725f80cdb; });\n$parcel$export($9d83a5ecbd86440e$exports, \"parsePiece\", function () { return $9d83a5ecbd86440e$export$49ab54498a5f7b98; });\n$parcel$export($9d83a5ecbd86440e$exports, \"makePiece\", function () { return $9d83a5ecbd86440e$export$d7c07e9c8afa4b1f; });\n$parcel$export($9d83a5ecbd86440e$exports, \"makeBoardFen\", function () { return $9d83a5ecbd86440e$export$df21f977b5ae750e; });\n$parcel$export($9d83a5ecbd86440e$exports, \"makePocket\", function () { return $9d83a5ecbd86440e$export$cabb40a7cab9b9b6; });\n$parcel$export($9d83a5ecbd86440e$exports, \"makePockets\", function () { return $9d83a5ecbd86440e$export$10f55b5fe2f0ee58; });\n$parcel$export($9d83a5ecbd86440e$exports, \"makeCastlingFen\", function () { return $9d83a5ecbd86440e$export$38938fa8a3afa51d; });\n$parcel$export($9d83a5ecbd86440e$exports, \"makeRemainingChecks\", function () { return $9d83a5ecbd86440e$export$13fac14d3ea80023; });\n$parcel$export($9d83a5ecbd86440e$exports, \"makeFen\", function () { return $9d83a5ecbd86440e$export$1c84988fe62ae4c9; });\n\n\n\n\n\nclass $a4364a4b65f8973f$export$ef284b30650dc04c {\n    constructor(){}\n    static empty() {\n        const m = new $a4364a4b65f8973f$export$ef284b30650dc04c();\n        for (const role of (0, $c489d07ce8bc1a25$export$d1cfdc29cbc61821))m[role] = 0;\n        return m;\n    }\n    static fromBoard(board, color) {\n        const m = new $a4364a4b65f8973f$export$ef284b30650dc04c();\n        for (const role of (0, $c489d07ce8bc1a25$export$d1cfdc29cbc61821))m[role] = board.pieces(color, role).size();\n        return m;\n    }\n    clone() {\n        const m = new $a4364a4b65f8973f$export$ef284b30650dc04c();\n        for (const role of (0, $c489d07ce8bc1a25$export$d1cfdc29cbc61821))m[role] = this[role];\n        return m;\n    }\n    equals(other) {\n        return (0, $c489d07ce8bc1a25$export$d1cfdc29cbc61821).every((role)=>this[role] === other[role]);\n    }\n    add(other) {\n        const m = new $a4364a4b65f8973f$export$ef284b30650dc04c();\n        for (const role of (0, $c489d07ce8bc1a25$export$d1cfdc29cbc61821))m[role] = this[role] + other[role];\n        return m;\n    }\n    subtract(other) {\n        const m = new $a4364a4b65f8973f$export$ef284b30650dc04c();\n        for (const role of (0, $c489d07ce8bc1a25$export$d1cfdc29cbc61821))m[role] = this[role] - other[role];\n        return m;\n    }\n    nonEmpty() {\n        return (0, $c489d07ce8bc1a25$export$d1cfdc29cbc61821).some((role)=>this[role] > 0);\n    }\n    isEmpty() {\n        return !this.nonEmpty();\n    }\n    hasPawns() {\n        return this.pawn > 0;\n    }\n    hasNonPawns() {\n        return this.knight > 0 || this.bishop > 0 || this.rook > 0 || this.queen > 0 || this.king > 0;\n    }\n    size() {\n        return this.pawn + this.knight + this.bishop + this.rook + this.queen + this.king;\n    }\n}\nclass $a4364a4b65f8973f$export$a2d8b23205c25948 {\n    constructor(white, black){\n        this.white = white;\n        this.black = black;\n    }\n    static empty() {\n        return new $a4364a4b65f8973f$export$a2d8b23205c25948($a4364a4b65f8973f$export$ef284b30650dc04c.empty(), $a4364a4b65f8973f$export$ef284b30650dc04c.empty());\n    }\n    static fromBoard(board) {\n        return new $a4364a4b65f8973f$export$a2d8b23205c25948($a4364a4b65f8973f$export$ef284b30650dc04c.fromBoard(board, 'white'), $a4364a4b65f8973f$export$ef284b30650dc04c.fromBoard(board, 'black'));\n    }\n    clone() {\n        return new $a4364a4b65f8973f$export$a2d8b23205c25948(this.white.clone(), this.black.clone());\n    }\n    equals(other) {\n        return this.white.equals(other.white) && this.black.equals(other.black);\n    }\n    add(other) {\n        return new $a4364a4b65f8973f$export$a2d8b23205c25948(this.white.add(other.white), this.black.add(other.black));\n    }\n    subtract(other) {\n        return new $a4364a4b65f8973f$export$a2d8b23205c25948(this.white.subtract(other.white), this.black.subtract(other.black));\n    }\n    count(role) {\n        return this.white[role] + this.black[role];\n    }\n    size() {\n        return this.white.size() + this.black.size();\n    }\n    isEmpty() {\n        return this.white.isEmpty() && this.black.isEmpty();\n    }\n    nonEmpty() {\n        return !this.isEmpty();\n    }\n    hasPawns() {\n        return this.white.hasPawns() || this.black.hasPawns();\n    }\n    hasNonPawns() {\n        return this.white.hasNonPawns() || this.black.hasNonPawns();\n    }\n}\nclass $a4364a4b65f8973f$export$3f36e62a1e5d2e47 {\n    constructor(white, black){\n        this.white = white;\n        this.black = black;\n    }\n    static default() {\n        return new $a4364a4b65f8973f$export$3f36e62a1e5d2e47(3, 3);\n    }\n    clone() {\n        return new $a4364a4b65f8973f$export$3f36e62a1e5d2e47(this.white, this.black);\n    }\n    equals(other) {\n        return this.white === other.white && this.black === other.black;\n    }\n}\nconst $a4364a4b65f8973f$export$648124f978b24aef = ()=>({\n        board: (0, $4f484c5772f22add$export$dc537a3a3893548e).default(),\n        pockets: undefined,\n        turn: 'white',\n        castlingRights: (0, $9894c45c69033325$export$1cb45477e81f9503).corners(),\n        epSquare: undefined,\n        remainingChecks: undefined,\n        halfmoves: 0,\n        fullmoves: 1\n    });\nconst $a4364a4b65f8973f$export$e5a37ff79d23094b = (setup)=>{\n    var _a, _b;\n    return {\n        board: setup.board.clone(),\n        pockets: (_a = setup.pockets) === null || _a === void 0 ? void 0 : _a.clone(),\n        turn: setup.turn,\n        castlingRights: setup.castlingRights,\n        epSquare: setup.epSquare,\n        remainingChecks: (_b = setup.remainingChecks) === null || _b === void 0 ? void 0 : _b.clone(),\n        halfmoves: setup.halfmoves,\n        fullmoves: setup.fullmoves\n    };\n};\nconst $a4364a4b65f8973f$export$eef8cd0b8effa8e5 = (left, right)=>{\n    var _a, _b;\n    return (0, $4f484c5772f22add$export$2df5e23f048ea965)(left.board, right.board) && (right.pockets && ((_a = left.pockets) === null || _a === void 0 ? void 0 : _a.equals(right.pockets)) || !left.pockets && !right.pockets) && left.turn === right.turn && left.castlingRights.equals(right.castlingRights) && left.epSquare === right.epSquare && (right.remainingChecks && ((_b = left.remainingChecks) === null || _b === void 0 ? void 0 : _b.equals(right.remainingChecks)) || !left.remainingChecks && !right.remainingChecks) && left.halfmoves === right.halfmoves && left.fullmoves === right.fullmoves;\n};\n\n\n\n\n\nconst $9d83a5ecbd86440e$export$a7af5e4473279ca4 = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\nconst $9d83a5ecbd86440e$export$f55e4ecc51581d46 = $9d83a5ecbd86440e$export$a7af5e4473279ca4 + ' w KQkq -';\nconst $9d83a5ecbd86440e$export$e7275301a68905e5 = $9d83a5ecbd86440e$export$f55e4ecc51581d46 + ' 0 1';\nconst $9d83a5ecbd86440e$export$cf2dfba1ebb0c02f = '8/8/8/8/8/8/8/8';\nconst $9d83a5ecbd86440e$export$a8056043964453a9 = $9d83a5ecbd86440e$export$cf2dfba1ebb0c02f + ' w - -';\nconst $9d83a5ecbd86440e$export$5dd74b96db3f93aa = $9d83a5ecbd86440e$export$a8056043964453a9 + ' 0 1';\nvar $9d83a5ecbd86440e$export$c3be932223332a30;\n(function(InvalidFen) {\n    InvalidFen[\"Fen\"] = \"ERR_FEN\";\n    InvalidFen[\"Board\"] = \"ERR_BOARD\";\n    InvalidFen[\"Pockets\"] = \"ERR_POCKETS\";\n    InvalidFen[\"Turn\"] = \"ERR_TURN\";\n    InvalidFen[\"Castling\"] = \"ERR_CASTLING\";\n    InvalidFen[\"EpSquare\"] = \"ERR_EP_SQUARE\";\n    InvalidFen[\"RemainingChecks\"] = \"ERR_REMAINING_CHECKS\";\n    InvalidFen[\"Halfmoves\"] = \"ERR_HALFMOVES\";\n    InvalidFen[\"Fullmoves\"] = \"ERR_FULLMOVES\";\n})($9d83a5ecbd86440e$export$c3be932223332a30 || ($9d83a5ecbd86440e$export$c3be932223332a30 = {}));\nclass $9d83a5ecbd86440e$export$e160fb1161fc30ea extends Error {\n}\nconst $9d83a5ecbd86440e$var$nthIndexOf = (haystack, needle, n)=>{\n    let index = haystack.indexOf(needle);\n    while(n-- > 0){\n        if (index === -1) break;\n        index = haystack.indexOf(needle, index + needle.length);\n    }\n    return index;\n};\nconst $9d83a5ecbd86440e$var$parseSmallUint = (str)=>/^\\d{1,4}$/.test(str) ? parseInt(str, 10) : undefined;\nconst $9d83a5ecbd86440e$var$charToPiece = (ch)=>{\n    const role = (0, $ced645034f45bdd3$export$f2f0c9a05dc6f86f)(ch);\n    return role && {\n        role: role,\n        color: ch.toLowerCase() === ch ? 'black' : 'white'\n    };\n};\nconst $9d83a5ecbd86440e$export$1fedd4affc50d07d = (boardPart)=>{\n    const board = (0, $4f484c5772f22add$export$dc537a3a3893548e).empty();\n    let rank = 7;\n    let file = 0;\n    for(let i = 0; i < boardPart.length; i++){\n        const c = boardPart[i];\n        if (c === '/' && file === 8) {\n            file = 0;\n            rank--;\n        } else {\n            const step = parseInt(c, 10);\n            if (step > 0) file += step;\n            else {\n                if (file >= 8 || rank < 0) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.Board));\n                const square = file + rank * 8;\n                const piece = $9d83a5ecbd86440e$var$charToPiece(c);\n                if (!piece) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.Board));\n                if (boardPart[i + 1] === '~') {\n                    piece.promoted = true;\n                    i++;\n                }\n                board.set(square, piece);\n                file++;\n            }\n        }\n    }\n    if (rank !== 0 || file !== 8) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.Board));\n    return (0, $0b15f372ed432f56$export$8fdcabde73f49165).ok(board);\n};\nconst $9d83a5ecbd86440e$export$b5493de85cc66c92 = (pocketPart)=>{\n    if (pocketPart.length > 64) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.Pockets));\n    const pockets = (0, $a4364a4b65f8973f$export$a2d8b23205c25948).empty();\n    for (const c of pocketPart){\n        const piece = $9d83a5ecbd86440e$var$charToPiece(c);\n        if (!piece) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.Pockets));\n        pockets[piece.color][piece.role]++;\n    }\n    return (0, $0b15f372ed432f56$export$8fdcabde73f49165).ok(pockets);\n};\nconst $9d83a5ecbd86440e$export$4d18bb43bf7a3116 = (board, castlingPart)=>{\n    let castlingRights = (0, $9894c45c69033325$export$1cb45477e81f9503).empty();\n    if (castlingPart === '-') return (0, $0b15f372ed432f56$export$8fdcabde73f49165).ok(castlingRights);\n    for (const c of castlingPart){\n        const lower = c.toLowerCase();\n        const color = c === lower ? 'black' : 'white';\n        const rank = color === 'white' ? 0 : 7;\n        if ('a' <= lower && lower <= 'h') castlingRights = castlingRights.with((0, $ced645034f45bdd3$export$4a0d5207d1ffca15)(lower.charCodeAt(0) - 'a'.charCodeAt(0), rank));\n        else if (lower === 'k' || lower === 'q') {\n            const rooksAndKings = board[color].intersect((0, $9894c45c69033325$export$1cb45477e81f9503).backrank(color)).intersect(board.rook.union(board.king));\n            const candidate = lower === 'k' ? rooksAndKings.last() : rooksAndKings.first();\n            castlingRights = castlingRights.with((0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(candidate) && board.rook.has(candidate) ? candidate : (0, $ced645034f45bdd3$export$4a0d5207d1ffca15)(lower === 'k' ? 7 : 0, rank));\n        } else return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.Castling));\n    }\n    if ((0, $c489d07ce8bc1a25$export$56d196d2844d1ca1).some((color)=>(0, $9894c45c69033325$export$1cb45477e81f9503).backrank(color).intersect(castlingRights).size() > 2)) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.Castling));\n    return (0, $0b15f372ed432f56$export$8fdcabde73f49165).ok(castlingRights);\n};\nconst $9d83a5ecbd86440e$export$fca9881f86ac8234 = (part)=>{\n    const parts = part.split('+');\n    if (parts.length === 3 && parts[0] === '') {\n        const white = $9d83a5ecbd86440e$var$parseSmallUint(parts[1]);\n        const black = $9d83a5ecbd86440e$var$parseSmallUint(parts[2]);\n        if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(white) || white > 3 || !(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(black) || black > 3) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.RemainingChecks));\n        return (0, $0b15f372ed432f56$export$8fdcabde73f49165).ok(new (0, $a4364a4b65f8973f$export$3f36e62a1e5d2e47)(3 - white, 3 - black));\n    } else if (parts.length === 2) {\n        const white = $9d83a5ecbd86440e$var$parseSmallUint(parts[0]);\n        const black = $9d83a5ecbd86440e$var$parseSmallUint(parts[1]);\n        if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(white) || white > 3 || !(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(black) || black > 3) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.RemainingChecks));\n        return (0, $0b15f372ed432f56$export$8fdcabde73f49165).ok(new (0, $a4364a4b65f8973f$export$3f36e62a1e5d2e47)(white, black));\n    } else return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.RemainingChecks));\n};\nconst $9d83a5ecbd86440e$export$d6cccad725f80cdb = (fen)=>{\n    const parts = fen.split(/[\\s_]+/);\n    const boardPart = parts.shift();\n    // Board and pockets\n    let board;\n    let pockets = (0, $0b15f372ed432f56$export$8fdcabde73f49165).ok(undefined);\n    if (boardPart.endsWith(']')) {\n        const pocketStart = boardPart.indexOf('[');\n        if (pocketStart === -1) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.Fen));\n        board = $9d83a5ecbd86440e$export$1fedd4affc50d07d(boardPart.slice(0, pocketStart));\n        pockets = $9d83a5ecbd86440e$export$b5493de85cc66c92(boardPart.slice(pocketStart + 1, -1));\n    } else {\n        const pocketStart = $9d83a5ecbd86440e$var$nthIndexOf(boardPart, '/', 7);\n        if (pocketStart === -1) board = $9d83a5ecbd86440e$export$1fedd4affc50d07d(boardPart);\n        else {\n            board = $9d83a5ecbd86440e$export$1fedd4affc50d07d(boardPart.slice(0, pocketStart));\n            pockets = $9d83a5ecbd86440e$export$b5493de85cc66c92(boardPart.slice(pocketStart + 1));\n        }\n    }\n    // Turn\n    let turn;\n    const turnPart = parts.shift();\n    if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(turnPart) || turnPart === 'w') turn = 'white';\n    else if (turnPart === 'b') turn = 'black';\n    else return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.Turn));\n    return board.chain((board)=>{\n        // Castling\n        const castlingPart = parts.shift();\n        const castlingRights = (0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(castlingPart) ? $9d83a5ecbd86440e$export$4d18bb43bf7a3116(board, castlingPart) : (0, $0b15f372ed432f56$export$8fdcabde73f49165).ok((0, $9894c45c69033325$export$1cb45477e81f9503).empty());\n        // En passant square\n        const epPart = parts.shift();\n        let epSquare;\n        if ((0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(epPart) && epPart !== '-') {\n            epSquare = (0, $ced645034f45bdd3$export$c6ba26669b4144a1)(epPart);\n            if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(epSquare)) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.EpSquare));\n        }\n        // Halfmoves or remaining checks\n        let halfmovePart = parts.shift();\n        let earlyRemainingChecks;\n        if ((0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(halfmovePart) && halfmovePart.includes('+')) {\n            earlyRemainingChecks = $9d83a5ecbd86440e$export$fca9881f86ac8234(halfmovePart);\n            halfmovePart = parts.shift();\n        }\n        const halfmoves = (0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(halfmovePart) ? $9d83a5ecbd86440e$var$parseSmallUint(halfmovePart) : 0;\n        if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(halfmoves)) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.Halfmoves));\n        const fullmovesPart = parts.shift();\n        const fullmoves = (0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(fullmovesPart) ? $9d83a5ecbd86440e$var$parseSmallUint(fullmovesPart) : 1;\n        if (!(0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(fullmoves)) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.Fullmoves));\n        const remainingChecksPart = parts.shift();\n        let remainingChecks = (0, $0b15f372ed432f56$export$8fdcabde73f49165).ok(undefined);\n        if ((0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(remainingChecksPart)) {\n            if ((0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(earlyRemainingChecks)) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.RemainingChecks));\n            remainingChecks = $9d83a5ecbd86440e$export$fca9881f86ac8234(remainingChecksPart);\n        } else if ((0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(earlyRemainingChecks)) remainingChecks = earlyRemainingChecks;\n        if (parts.length > 0) return (0, $0b15f372ed432f56$export$8fdcabde73f49165).err(new $9d83a5ecbd86440e$export$e160fb1161fc30ea($9d83a5ecbd86440e$export$c3be932223332a30.Fen));\n        return pockets.chain((pockets)=>castlingRights.chain((castlingRights)=>remainingChecks.map((remainingChecks)=>{\n                    return {\n                        board: board,\n                        pockets: pockets,\n                        turn: turn,\n                        castlingRights: castlingRights,\n                        remainingChecks: remainingChecks,\n                        epSquare: epSquare,\n                        halfmoves: halfmoves,\n                        fullmoves: Math.max(1, fullmoves)\n                    };\n                })));\n    });\n};\nconst $9d83a5ecbd86440e$export$49ab54498a5f7b98 = (str)=>{\n    if (!str) return;\n    const piece = $9d83a5ecbd86440e$var$charToPiece(str[0]);\n    if (!piece) return;\n    if (str.length === 2 && str[1] === '~') piece.promoted = true;\n    else if (str.length > 1) return;\n    return piece;\n};\nconst $9d83a5ecbd86440e$export$d7c07e9c8afa4b1f = (piece)=>{\n    let r = (0, $ced645034f45bdd3$export$f10eeb6aa79a8bf2)(piece.role);\n    if (piece.color === 'white') r = r.toUpperCase();\n    if (piece.promoted) r += '~';\n    return r;\n};\nconst $9d83a5ecbd86440e$export$df21f977b5ae750e = (board)=>{\n    let fen = '';\n    let empty = 0;\n    for(let rank = 7; rank >= 0; rank--)for(let file = 0; file < 8; file++){\n        const square = file + rank * 8;\n        const piece = board.get(square);\n        if (!piece) empty++;\n        else {\n            if (empty > 0) {\n                fen += empty;\n                empty = 0;\n            }\n            fen += $9d83a5ecbd86440e$export$d7c07e9c8afa4b1f(piece);\n        }\n        if (file === 7) {\n            if (empty > 0) {\n                fen += empty;\n                empty = 0;\n            }\n            if (rank !== 0) fen += '/';\n        }\n    }\n    return fen;\n};\nconst $9d83a5ecbd86440e$export$cabb40a7cab9b9b6 = (material)=>(0, $c489d07ce8bc1a25$export$d1cfdc29cbc61821).map((role)=>(0, $ced645034f45bdd3$export$f10eeb6aa79a8bf2)(role).repeat(material[role])).join('');\nconst $9d83a5ecbd86440e$export$10f55b5fe2f0ee58 = (pocket)=>$9d83a5ecbd86440e$export$cabb40a7cab9b9b6(pocket.white).toUpperCase() + $9d83a5ecbd86440e$export$cabb40a7cab9b9b6(pocket.black);\nconst $9d83a5ecbd86440e$export$38938fa8a3afa51d = (board, castlingRights)=>{\n    let fen = '';\n    for (const color of (0, $c489d07ce8bc1a25$export$56d196d2844d1ca1)){\n        const backrank = (0, $9894c45c69033325$export$1cb45477e81f9503).backrank(color);\n        let king = board.kingOf(color);\n        if ((0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(king) && !backrank.has(king)) king = undefined;\n        const candidates = board.pieces(color, 'rook').intersect(backrank);\n        for (const rook of castlingRights.intersect(backrank).reversed()){\n            if (rook === candidates.first() && (0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(king) && rook < king) fen += color === 'white' ? 'Q' : 'q';\n            else if (rook === candidates.last() && (0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(king) && king < rook) fen += color === 'white' ? 'K' : 'k';\n            else {\n                const file = (0, $c489d07ce8bc1a25$export$603b1d1551079add)[(0, $ced645034f45bdd3$export$4e7f80514dc39415)(rook)];\n                fen += color === 'white' ? file.toUpperCase() : file;\n            }\n        }\n    }\n    return fen || '-';\n};\nconst $9d83a5ecbd86440e$export$13fac14d3ea80023 = (checks)=>`${checks.white}+${checks.black}`;\nconst $9d83a5ecbd86440e$export$1c84988fe62ae4c9 = (setup, opts)=>[\n        $9d83a5ecbd86440e$export$df21f977b5ae750e(setup.board) + (setup.pockets ? `[${$9d83a5ecbd86440e$export$10f55b5fe2f0ee58(setup.pockets)}]` : ''),\n        setup.turn[0],\n        $9d83a5ecbd86440e$export$38938fa8a3afa51d(setup.board, setup.castlingRights),\n        (0, $ced645034f45bdd3$export$43f40ad3fa1d5c97)(setup.epSquare) ? (0, $ced645034f45bdd3$export$232f91fc931f1158)(setup.epSquare) : '-',\n        ...setup.remainingChecks ? [\n            $9d83a5ecbd86440e$export$13fac14d3ea80023(setup.remainingChecks)\n        ] : [],\n        ...(opts === null || opts === void 0 ? void 0 : opts.epd) ? [] : [\n            Math.max(0, Math.min(setup.halfmoves, 9999)),\n            Math.max(1, Math.min(setup.fullmoves, 9999))\n        ]\n    ].join(' ');\n\n\nconst $89afb1487ee9ea89$export$8f45430ccf837300 = [\n    'white',\n    'black'\n];\nconst $89afb1487ee9ea89$export$3a444357c5f65f65 = [\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h'\n];\nconst $89afb1487ee9ea89$export$d8e4e3952f325c95 = [\n    '1',\n    '2',\n    '3',\n    '4',\n    '5',\n    '6',\n    '7',\n    '8'\n];\n\n\nconst $12cc5d8f1c8e91f5$export$978f7ef4c67d166e = [\n    ...$89afb1487ee9ea89$export$d8e4e3952f325c95\n].reverse();\nconst $12cc5d8f1c8e91f5$export$ade7a30951d0bc54 = Array.prototype.concat(...$89afb1487ee9ea89$export$3a444357c5f65f65.map((c)=>$89afb1487ee9ea89$export$d8e4e3952f325c95.map((r)=>c + r)));\nconst $12cc5d8f1c8e91f5$export$fe9f8b727818c0ae = (pos)=>$12cc5d8f1c8e91f5$export$ade7a30951d0bc54[8 * pos[0] + pos[1]];\nconst $12cc5d8f1c8e91f5$export$e2878eba51f22d11 = (k)=>[\n        k.charCodeAt(0) - 97,\n        k.charCodeAt(1) - 49\n    ];\nconst $12cc5d8f1c8e91f5$export$ab796e79c29e0864 = (uci)=>{\n    if (!uci) return undefined;\n    if (uci[1] === '@') return [\n        uci.slice(2, 4)\n    ];\n    return [\n        uci.slice(0, 2),\n        uci.slice(2, 4)\n    ];\n};\nconst $12cc5d8f1c8e91f5$export$26773b74d67e09c2 = $12cc5d8f1c8e91f5$export$ade7a30951d0bc54.map($12cc5d8f1c8e91f5$export$e2878eba51f22d11);\nfunction $12cc5d8f1c8e91f5$export$7c73462e0d25e514(f) {\n    let v;\n    const ret = ()=>{\n        if (v === undefined) v = f();\n        return v;\n    };\n    ret.clear = ()=>{\n        v = undefined;\n    };\n    return ret;\n}\nconst $12cc5d8f1c8e91f5$export$9dc4ecf953986f04 = ()=>{\n    let startAt;\n    return {\n        start () {\n            startAt = performance.now();\n        },\n        cancel () {\n            startAt = undefined;\n        },\n        stop () {\n            if (!startAt) return 0;\n            const time = performance.now() - startAt;\n            startAt = undefined;\n            return time;\n        }\n    };\n};\nconst $12cc5d8f1c8e91f5$export$a27c3a1c44ba515b = (c)=>c === 'white' ? 'black' : 'white';\nconst $12cc5d8f1c8e91f5$export$e4884e1734dcd545 = (pos1, pos2)=>{\n    const dx = pos1[0] - pos2[0], dy = pos1[1] - pos2[1];\n    return dx * dx + dy * dy;\n};\nconst $12cc5d8f1c8e91f5$export$e329b1a538c004fa = (p1, p2)=>p1.role === p2.role && p1.color === p2.color;\nconst $12cc5d8f1c8e91f5$export$2135ad75550a2ff4 = (bounds)=>(pos, asWhite)=>[\n            (asWhite ? pos[0] : 7 - pos[0]) * bounds.width / 8,\n            (asWhite ? 7 - pos[1] : pos[1]) * bounds.height / 8\n        ];\nconst $12cc5d8f1c8e91f5$export$d73ee8ef04f5226a = (el, pos)=>{\n    el.style.transform = `translate(${pos[0]}px,${pos[1]}px)`;\n};\nconst $12cc5d8f1c8e91f5$export$f8afaca97e230dc6 = (el, pos, scale = 1)=>{\n    el.style.transform = `translate(${pos[0]}px,${pos[1]}px) scale(${scale})`;\n};\nconst $12cc5d8f1c8e91f5$export$8cb512849e51eaf5 = (el, v)=>{\n    el.style.visibility = v ? 'visible' : 'hidden';\n};\nconst $12cc5d8f1c8e91f5$export$33052595192f7117 = (e)=>{\n    var _a;\n    if (e.clientX || e.clientX === 0) return [\n        e.clientX,\n        e.clientY\n    ];\n    if ((_a = e.targetTouches) === null || _a === void 0 ? void 0 : _a[0]) return [\n        e.targetTouches[0].clientX,\n        e.targetTouches[0].clientY\n    ];\n    return; // touchend has no position!\n};\nconst $12cc5d8f1c8e91f5$export$947a472b5b3020ba = (e)=>e.button === 2;\nconst $12cc5d8f1c8e91f5$export$3d7cd8ed57263b30 = (tagName, className)=>{\n    const el = document.createElement(tagName);\n    if (className) el.className = className;\n    return el;\n};\nfunction $12cc5d8f1c8e91f5$export$1c17f680299a31f7(key, asWhite, bounds) {\n    const pos = $12cc5d8f1c8e91f5$export$e2878eba51f22d11(key);\n    if (!asWhite) {\n        pos[0] = 7 - pos[0];\n        pos[1] = 7 - pos[1];\n    }\n    return [\n        bounds.left + bounds.width * pos[0] / 8 + bounds.width / 16,\n        bounds.top + bounds.height * (7 - pos[1]) / 8 + bounds.height / 16\n    ];\n}\n\n\n\nconst $e201ff49adfb06e2$var$diff = (a, b)=>Math.abs(a - b);\nconst $e201ff49adfb06e2$var$pawn = (color)=>(x1, y1, x2, y2)=>$e201ff49adfb06e2$var$diff(x1, x2) < 2 && (color === 'white' ? y2 === y1 + 1 || y1 <= 1 && y2 === y1 + 2 && x1 === x2 : y2 === y1 - 1 || y1 >= 6 && y2 === y1 - 2 && x1 === x2);\nconst $e201ff49adfb06e2$export$5584fb45fd3a6d08 = (x1, y1, x2, y2)=>{\n    const xd = $e201ff49adfb06e2$var$diff(x1, x2);\n    const yd = $e201ff49adfb06e2$var$diff(y1, y2);\n    return xd === 1 && yd === 2 || xd === 2 && yd === 1;\n};\nconst $e201ff49adfb06e2$var$bishop = (x1, y1, x2, y2)=>{\n    return $e201ff49adfb06e2$var$diff(x1, x2) === $e201ff49adfb06e2$var$diff(y1, y2);\n};\nconst $e201ff49adfb06e2$var$rook = (x1, y1, x2, y2)=>{\n    return x1 === x2 || y1 === y2;\n};\nconst $e201ff49adfb06e2$export$b9d1aa6d9cf991c6 = (x1, y1, x2, y2)=>{\n    return $e201ff49adfb06e2$var$bishop(x1, y1, x2, y2) || $e201ff49adfb06e2$var$rook(x1, y1, x2, y2);\n};\nconst $e201ff49adfb06e2$var$king = (color, rookFiles, canCastle)=>(x1, y1, x2, y2)=>$e201ff49adfb06e2$var$diff(x1, x2) < 2 && $e201ff49adfb06e2$var$diff(y1, y2) < 2 || canCastle && y1 === y2 && y1 === (color === 'white' ? 0 : 7) && (x1 === 4 && (x2 === 2 && rookFiles.includes(0) || x2 === 6 && rookFiles.includes(7)) || rookFiles.includes(x2));\nfunction $e201ff49adfb06e2$var$rookFilesOf(pieces, color) {\n    const backrank = color === 'white' ? '1' : '8';\n    const files = [];\n    for (const [key, piece] of pieces)if (key[1] === backrank && piece.color === color && piece.role === 'rook') files.push($12cc5d8f1c8e91f5$export$e2878eba51f22d11(key)[0]);\n    return files;\n}\nfunction $e201ff49adfb06e2$export$99ff1a176ab1ff90(pieces, key, canCastle) {\n    const piece = pieces.get(key);\n    if (!piece) return [];\n    const pos = $12cc5d8f1c8e91f5$export$e2878eba51f22d11(key), r = piece.role, mobility = r === 'pawn' ? $e201ff49adfb06e2$var$pawn(piece.color) : r === 'knight' ? $e201ff49adfb06e2$export$5584fb45fd3a6d08 : r === 'bishop' ? $e201ff49adfb06e2$var$bishop : r === 'rook' ? $e201ff49adfb06e2$var$rook : r === 'queen' ? $e201ff49adfb06e2$export$b9d1aa6d9cf991c6 : $e201ff49adfb06e2$var$king(piece.color, $e201ff49adfb06e2$var$rookFilesOf(pieces, piece.color), canCastle);\n    return $12cc5d8f1c8e91f5$export$26773b74d67e09c2.filter((pos2)=>(pos[0] !== pos2[0] || pos[1] !== pos2[1]) && mobility(pos[0], pos[1], pos2[0], pos2[1])).map($12cc5d8f1c8e91f5$export$fe9f8b727818c0ae);\n}\n\n\nfunction $e9a4281a8a1ce8a6$export$6511920ae9f0cd34(f, ...args) {\n    if (f) setTimeout(()=>f(...args), 1);\n}\nfunction $e9a4281a8a1ce8a6$export$e798007c48b456cd(state) {\n    state.orientation = (0, $12cc5d8f1c8e91f5$export$a27c3a1c44ba515b)(state.orientation);\n    state.animation.current = state.draggable.current = state.selected = undefined;\n}\nfunction $e9a4281a8a1ce8a6$export$aad8462122ac592b(state) {\n    state.lastMove = undefined;\n    $e9a4281a8a1ce8a6$export$fe412c270a34f415(state);\n    $e9a4281a8a1ce8a6$export$f92a111f74a3f7c7(state);\n    $e9a4281a8a1ce8a6$export$9e6f418e5ea6b92c(state);\n}\nfunction $e9a4281a8a1ce8a6$export$20a063d1402ff7ff(state, pieces) {\n    for (const [key, piece] of pieces)if (piece) state.pieces.set(key, piece);\n    else state.pieces.delete(key);\n}\nfunction $e9a4281a8a1ce8a6$export$6503933b06013bb6(state, color) {\n    state.check = undefined;\n    if (color === true) color = state.turnColor;\n    if (color) {\n        for (const [k, p] of state.pieces)if (p.role === 'king' && p.color === color) state.check = k;\n    }\n}\nfunction $e9a4281a8a1ce8a6$var$setPremove(state, orig, dest, meta) {\n    $e9a4281a8a1ce8a6$export$9e6f418e5ea6b92c(state);\n    state.premovable.current = [\n        orig,\n        dest\n    ];\n    $e9a4281a8a1ce8a6$export$6511920ae9f0cd34(state.premovable.events.set, orig, dest, meta);\n}\nfunction $e9a4281a8a1ce8a6$export$f92a111f74a3f7c7(state) {\n    if (state.premovable.current) {\n        state.premovable.current = undefined;\n        $e9a4281a8a1ce8a6$export$6511920ae9f0cd34(state.premovable.events.unset);\n    }\n}\nfunction $e9a4281a8a1ce8a6$var$setPredrop(state, role, key) {\n    $e9a4281a8a1ce8a6$export$f92a111f74a3f7c7(state);\n    state.predroppable.current = {\n        role: role,\n        key: key\n    };\n    $e9a4281a8a1ce8a6$export$6511920ae9f0cd34(state.predroppable.events.set, role, key);\n}\nfunction $e9a4281a8a1ce8a6$export$9e6f418e5ea6b92c(state) {\n    const pd = state.predroppable;\n    if (pd.current) {\n        pd.current = undefined;\n        $e9a4281a8a1ce8a6$export$6511920ae9f0cd34(pd.events.unset);\n    }\n}\nfunction $e9a4281a8a1ce8a6$var$tryAutoCastle(state, orig, dest) {\n    if (!state.autoCastle) return false;\n    const king = state.pieces.get(orig);\n    if (!king || king.role !== 'king') return false;\n    const origPos = (0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(orig);\n    const destPos = (0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(dest);\n    if (origPos[1] !== 0 && origPos[1] !== 7 || origPos[1] !== destPos[1]) return false;\n    if (origPos[0] === 4 && !state.pieces.has(dest)) {\n        if (destPos[0] === 6) dest = (0, $12cc5d8f1c8e91f5$export$fe9f8b727818c0ae)([\n            7,\n            destPos[1]\n        ]);\n        else if (destPos[0] === 2) dest = (0, $12cc5d8f1c8e91f5$export$fe9f8b727818c0ae)([\n            0,\n            destPos[1]\n        ]);\n    }\n    const rook = state.pieces.get(dest);\n    if (!rook || rook.color !== king.color || rook.role !== 'rook') return false;\n    state.pieces.delete(orig);\n    state.pieces.delete(dest);\n    if (origPos[0] < destPos[0]) {\n        state.pieces.set((0, $12cc5d8f1c8e91f5$export$fe9f8b727818c0ae)([\n            6,\n            destPos[1]\n        ]), king);\n        state.pieces.set((0, $12cc5d8f1c8e91f5$export$fe9f8b727818c0ae)([\n            5,\n            destPos[1]\n        ]), rook);\n    } else {\n        state.pieces.set((0, $12cc5d8f1c8e91f5$export$fe9f8b727818c0ae)([\n            2,\n            destPos[1]\n        ]), king);\n        state.pieces.set((0, $12cc5d8f1c8e91f5$export$fe9f8b727818c0ae)([\n            3,\n            destPos[1]\n        ]), rook);\n    }\n    return true;\n}\nfunction $e9a4281a8a1ce8a6$export$13f6ca6271343510(state, orig, dest) {\n    const origPiece = state.pieces.get(orig), destPiece = state.pieces.get(dest);\n    if (orig === dest || !origPiece) return false;\n    const captured = destPiece && destPiece.color !== origPiece.color ? destPiece : undefined;\n    if (dest === state.selected) $e9a4281a8a1ce8a6$export$fe412c270a34f415(state);\n    $e9a4281a8a1ce8a6$export$6511920ae9f0cd34(state.events.move, orig, dest, captured);\n    if (!$e9a4281a8a1ce8a6$var$tryAutoCastle(state, orig, dest)) {\n        state.pieces.set(dest, origPiece);\n        state.pieces.delete(orig);\n    }\n    state.lastMove = [\n        orig,\n        dest\n    ];\n    state.check = undefined;\n    $e9a4281a8a1ce8a6$export$6511920ae9f0cd34(state.events.change);\n    return captured || true;\n}\nfunction $e9a4281a8a1ce8a6$export$13886f9573facc29(state, piece, key, force) {\n    if (state.pieces.has(key)) {\n        if (force) state.pieces.delete(key);\n        else return false;\n    }\n    $e9a4281a8a1ce8a6$export$6511920ae9f0cd34(state.events.dropNewPiece, piece, key);\n    state.pieces.set(key, piece);\n    state.lastMove = [\n        key\n    ];\n    state.check = undefined;\n    $e9a4281a8a1ce8a6$export$6511920ae9f0cd34(state.events.change);\n    state.movable.dests = undefined;\n    state.turnColor = (0, $12cc5d8f1c8e91f5$export$a27c3a1c44ba515b)(state.turnColor);\n    return true;\n}\nfunction $e9a4281a8a1ce8a6$var$baseUserMove(state, orig, dest) {\n    const result = $e9a4281a8a1ce8a6$export$13f6ca6271343510(state, orig, dest);\n    if (result) {\n        state.movable.dests = undefined;\n        state.turnColor = (0, $12cc5d8f1c8e91f5$export$a27c3a1c44ba515b)(state.turnColor);\n        state.animation.current = undefined;\n    }\n    return result;\n}\nfunction $e9a4281a8a1ce8a6$export$843c446e2e718822(state, orig, dest) {\n    if ($e9a4281a8a1ce8a6$export$a4ef2b0c3fa55ad2(state, orig, dest)) {\n        const result = $e9a4281a8a1ce8a6$var$baseUserMove(state, orig, dest);\n        if (result) {\n            const holdTime = state.hold.stop();\n            $e9a4281a8a1ce8a6$export$fe412c270a34f415(state);\n            const metadata = {\n                premove: false,\n                ctrlKey: state.stats.ctrlKey,\n                holdTime: holdTime\n            };\n            if (result !== true) metadata.captured = result;\n            $e9a4281a8a1ce8a6$export$6511920ae9f0cd34(state.movable.events.after, orig, dest, metadata);\n            return true;\n        }\n    } else if ($e9a4281a8a1ce8a6$var$canPremove(state, orig, dest)) {\n        $e9a4281a8a1ce8a6$var$setPremove(state, orig, dest, {\n            ctrlKey: state.stats.ctrlKey\n        });\n        $e9a4281a8a1ce8a6$export$fe412c270a34f415(state);\n        return true;\n    }\n    $e9a4281a8a1ce8a6$export$fe412c270a34f415(state);\n    return false;\n}\nfunction $e9a4281a8a1ce8a6$export$b2b9f46b948033b0(state, orig, dest, force) {\n    const piece = state.pieces.get(orig);\n    if (piece && ($e9a4281a8a1ce8a6$var$canDrop(state, orig, dest) || force)) {\n        state.pieces.delete(orig);\n        $e9a4281a8a1ce8a6$export$13886f9573facc29(state, piece, dest, force);\n        $e9a4281a8a1ce8a6$export$6511920ae9f0cd34(state.movable.events.afterNewPiece, piece.role, dest, {\n            premove: false,\n            predrop: false\n        });\n    } else if (piece && $e9a4281a8a1ce8a6$var$canPredrop(state, orig, dest)) $e9a4281a8a1ce8a6$var$setPredrop(state, piece.role, dest);\n    else {\n        $e9a4281a8a1ce8a6$export$f92a111f74a3f7c7(state);\n        $e9a4281a8a1ce8a6$export$9e6f418e5ea6b92c(state);\n    }\n    state.pieces.delete(orig);\n    $e9a4281a8a1ce8a6$export$fe412c270a34f415(state);\n}\nfunction $e9a4281a8a1ce8a6$export$6073914ea697a63e(state, key, force) {\n    $e9a4281a8a1ce8a6$export$6511920ae9f0cd34(state.events.select, key);\n    if (state.selected) {\n        if (state.selected === key && !state.draggable.enabled) {\n            $e9a4281a8a1ce8a6$export$fe412c270a34f415(state);\n            state.hold.cancel();\n            return;\n        } else if ((state.selectable.enabled || force) && state.selected !== key) {\n            if ($e9a4281a8a1ce8a6$export$843c446e2e718822(state, state.selected, key)) {\n                state.stats.dragged = false;\n                return;\n            }\n        }\n    }\n    if ((state.selectable.enabled || state.draggable.enabled) && ($e9a4281a8a1ce8a6$var$isMovable(state, key) || $e9a4281a8a1ce8a6$var$isPremovable(state, key))) {\n        $e9a4281a8a1ce8a6$export$5a4818cec1656a71(state, key);\n        state.hold.start();\n    }\n}\nfunction $e9a4281a8a1ce8a6$export$5a4818cec1656a71(state, key) {\n    state.selected = key;\n    if ($e9a4281a8a1ce8a6$var$isPremovable(state, key)) // calculate chess premoves if custom premoves are not passed\n    {\n        if (!state.premovable.customDests) state.premovable.dests = (0, $e201ff49adfb06e2$export$99ff1a176ab1ff90)(state.pieces, key, state.premovable.castle);\n    } else state.premovable.dests = undefined;\n}\nfunction $e9a4281a8a1ce8a6$export$fe412c270a34f415(state) {\n    state.selected = undefined;\n    state.premovable.dests = undefined;\n    state.hold.cancel();\n}\nfunction $e9a4281a8a1ce8a6$var$isMovable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return !!piece && (state.movable.color === 'both' || state.movable.color === piece.color && state.turnColor === piece.color);\n}\nconst $e9a4281a8a1ce8a6$export$a4ef2b0c3fa55ad2 = (state, orig, dest)=>{\n    var _a, _b;\n    return orig !== dest && $e9a4281a8a1ce8a6$var$isMovable(state, orig) && (state.movable.free || !!((_b = (_a = state.movable.dests) === null || _a === void 0 ? void 0 : _a.get(orig)) === null || _b === void 0 ? void 0 : _b.includes(dest)));\n};\nfunction $e9a4281a8a1ce8a6$var$canDrop(state, orig, dest) {\n    const piece = state.pieces.get(orig);\n    return !!piece && (orig === dest || !state.pieces.has(dest)) && (state.movable.color === 'both' || state.movable.color === piece.color && state.turnColor === piece.color);\n}\nfunction $e9a4281a8a1ce8a6$var$isPremovable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return !!piece && state.premovable.enabled && state.movable.color === piece.color && state.turnColor !== piece.color;\n}\nfunction $e9a4281a8a1ce8a6$var$canPremove(state, orig, dest) {\n    var _a, _b;\n    const validPremoves = (_b = (_a = state.premovable.customDests) === null || _a === void 0 ? void 0 : _a.get(orig)) !== null && _b !== void 0 ? _b : (0, $e201ff49adfb06e2$export$99ff1a176ab1ff90)(state.pieces, orig, state.premovable.castle);\n    return orig !== dest && $e9a4281a8a1ce8a6$var$isPremovable(state, orig) && validPremoves.includes(dest);\n}\nfunction $e9a4281a8a1ce8a6$var$canPredrop(state, orig, dest) {\n    const piece = state.pieces.get(orig);\n    const destPiece = state.pieces.get(dest);\n    return !!piece && (!destPiece || destPiece.color !== state.movable.color) && state.predroppable.enabled && (piece.role !== 'pawn' || dest[1] !== '1' && dest[1] !== '8') && state.movable.color === piece.color && state.turnColor !== piece.color;\n}\nfunction $e9a4281a8a1ce8a6$export$fe8f97248bbe2d04(state, orig) {\n    const piece = state.pieces.get(orig);\n    return !!piece && state.draggable.enabled && (state.movable.color === 'both' || state.movable.color === piece.color && (state.turnColor === piece.color || state.premovable.enabled));\n}\nfunction $e9a4281a8a1ce8a6$export$d04320a93cdae73d(state) {\n    const move = state.premovable.current;\n    if (!move) return false;\n    const orig = move[0], dest = move[1];\n    let success = false;\n    if ($e9a4281a8a1ce8a6$export$a4ef2b0c3fa55ad2(state, orig, dest)) {\n        const result = $e9a4281a8a1ce8a6$var$baseUserMove(state, orig, dest);\n        if (result) {\n            const metadata = {\n                premove: true\n            };\n            if (result !== true) metadata.captured = result;\n            $e9a4281a8a1ce8a6$export$6511920ae9f0cd34(state.movable.events.after, orig, dest, metadata);\n            success = true;\n        }\n    }\n    $e9a4281a8a1ce8a6$export$f92a111f74a3f7c7(state);\n    return success;\n}\nfunction $e9a4281a8a1ce8a6$export$8efa9460c0cedd9e(state, validate) {\n    const drop = state.predroppable.current;\n    let success = false;\n    if (!drop) return false;\n    if (validate(drop)) {\n        const piece = {\n            role: drop.role,\n            color: state.movable.color\n        };\n        if ($e9a4281a8a1ce8a6$export$13886f9573facc29(state, piece, drop.key)) {\n            $e9a4281a8a1ce8a6$export$6511920ae9f0cd34(state.movable.events.afterNewPiece, drop.role, drop.key, {\n                premove: false,\n                predrop: true\n            });\n            success = true;\n        }\n    }\n    $e9a4281a8a1ce8a6$export$9e6f418e5ea6b92c(state);\n    return success;\n}\nfunction $e9a4281a8a1ce8a6$export$e47a3d6268102bb5(state) {\n    $e9a4281a8a1ce8a6$export$f92a111f74a3f7c7(state);\n    $e9a4281a8a1ce8a6$export$9e6f418e5ea6b92c(state);\n    $e9a4281a8a1ce8a6$export$fe412c270a34f415(state);\n}\nfunction $e9a4281a8a1ce8a6$export$fa6813432f753b0d(state) {\n    state.movable.color = state.movable.dests = state.animation.current = undefined;\n    $e9a4281a8a1ce8a6$export$e47a3d6268102bb5(state);\n}\nfunction $e9a4281a8a1ce8a6$export$102bdd581884418b(pos, asWhite, bounds) {\n    let file = Math.floor(8 * (pos[0] - bounds.left) / bounds.width);\n    if (!asWhite) file = 7 - file;\n    let rank = 7 - Math.floor(8 * (pos[1] - bounds.top) / bounds.height);\n    if (!asWhite) rank = 7 - rank;\n    return file >= 0 && file < 8 && rank >= 0 && rank < 8 ? (0, $12cc5d8f1c8e91f5$export$fe9f8b727818c0ae)([\n        file,\n        rank\n    ]) : undefined;\n}\nfunction $e9a4281a8a1ce8a6$export$6ee499125a88eb43(orig, pos, asWhite, bounds) {\n    const origPos = (0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(orig);\n    const validSnapPos = (0, $12cc5d8f1c8e91f5$export$26773b74d67e09c2).filter((pos2)=>(0, $e201ff49adfb06e2$export$b9d1aa6d9cf991c6)(origPos[0], origPos[1], pos2[0], pos2[1]) || (0, $e201ff49adfb06e2$export$5584fb45fd3a6d08)(origPos[0], origPos[1], pos2[0], pos2[1]));\n    const validSnapCenters = validSnapPos.map((pos2)=>(0, $12cc5d8f1c8e91f5$export$1c17f680299a31f7)((0, $12cc5d8f1c8e91f5$export$fe9f8b727818c0ae)(pos2), asWhite, bounds));\n    const validSnapDistances = validSnapCenters.map((pos2)=>(0, $12cc5d8f1c8e91f5$export$e4884e1734dcd545)(pos, pos2));\n    const [, closestSnapIndex] = validSnapDistances.reduce((a, b, index)=>a[0] < b ? a : [\n            b,\n            index\n        ], [\n        validSnapDistances[0],\n        0\n    ]);\n    return (0, $12cc5d8f1c8e91f5$export$fe9f8b727818c0ae)(validSnapPos[closestSnapIndex]);\n}\nconst $e9a4281a8a1ce8a6$export$970133fdf67d86cb = (s)=>s.orientation === 'white';\n\n\n\n\nconst $f02efaa0c4f5e00a$export$59ff82fc918bd7e3 = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\nconst $f02efaa0c4f5e00a$var$roles = {\n    p: 'pawn',\n    r: 'rook',\n    n: 'knight',\n    b: 'bishop',\n    q: 'queen',\n    k: 'king'\n};\nconst $f02efaa0c4f5e00a$var$letters = {\n    pawn: 'p',\n    rook: 'r',\n    knight: 'n',\n    bishop: 'b',\n    queen: 'q',\n    king: 'k'\n};\nfunction $f02efaa0c4f5e00a$export$aafa59e2e03f2942(fen) {\n    if (fen === 'start') fen = $f02efaa0c4f5e00a$export$59ff82fc918bd7e3;\n    const pieces = new Map();\n    let row = 7, col = 0;\n    for (const c of fen)switch(c){\n        case ' ':\n        case '[':\n            return pieces;\n        case '/':\n            --row;\n            if (row < 0) return pieces;\n            col = 0;\n            break;\n        case '~':\n            {\n                const piece = pieces.get((0, $12cc5d8f1c8e91f5$export$fe9f8b727818c0ae)([\n                    col - 1,\n                    row\n                ]));\n                if (piece) piece.promoted = true;\n                break;\n            }\n        default:\n            {\n                const nb = c.charCodeAt(0);\n                if (nb < 57) col += nb - 48;\n                else {\n                    const role = c.toLowerCase();\n                    pieces.set((0, $12cc5d8f1c8e91f5$export$fe9f8b727818c0ae)([\n                        col,\n                        row\n                    ]), {\n                        role: $f02efaa0c4f5e00a$var$roles[role],\n                        color: c === role ? 'black' : 'white'\n                    });\n                    ++col;\n                }\n            }\n    }\n    return pieces;\n}\nfunction $f02efaa0c4f5e00a$export$68d8715fc104d294(pieces) {\n    return (0, $12cc5d8f1c8e91f5$export$978f7ef4c67d166e).map((y)=>$89afb1487ee9ea89$export$3a444357c5f65f65.map((x)=>{\n            const piece = pieces.get(x + y);\n            if (piece) {\n                let p = $f02efaa0c4f5e00a$var$letters[piece.role];\n                if (piece.color === 'white') p = p.toUpperCase();\n                if (piece.promoted) p += '~';\n                return p;\n            } else return '1';\n        }).join('')).join('/').replace(/1{2,}/g, (s)=>s.length.toString());\n}\n\n\n\n\nfunction $f210fdc398bed13f$export$d771543c4ed87064(state, config) {\n    if (config.animation) {\n        $f210fdc398bed13f$var$deepMerge(state.animation, config.animation);\n        // no need for such short animations\n        if ((state.animation.duration || 0) < 70) state.animation.enabled = false;\n    }\n}\nfunction $f210fdc398bed13f$export$8d21e34596265fa2(state, config) {\n    var _a, _b, _c;\n    // don't merge destinations and autoShapes. Just override.\n    if ((_a = config.movable) === null || _a === void 0 ? void 0 : _a.dests) state.movable.dests = undefined;\n    if ((_b = config.drawable) === null || _b === void 0 ? void 0 : _b.autoShapes) state.drawable.autoShapes = [];\n    $f210fdc398bed13f$var$deepMerge(state, config);\n    // if a fen was provided, replace the pieces\n    if (config.fen) {\n        state.pieces = (0, $f02efaa0c4f5e00a$export$aafa59e2e03f2942)(config.fen);\n        state.drawable.shapes = ((_c = config.drawable) === null || _c === void 0 ? void 0 : _c.shapes) || [];\n    }\n    // apply config values that could be undefined yet meaningful\n    if ('check' in config) (0, $e9a4281a8a1ce8a6$export$6503933b06013bb6)(state, config.check || false);\n    if ('lastMove' in config && !config.lastMove) state.lastMove = undefined;\n    else if (config.lastMove) state.lastMove = config.lastMove;\n    // fix move/premove dests\n    if (state.selected) (0, $e9a4281a8a1ce8a6$export$5a4818cec1656a71)(state, state.selected);\n    $f210fdc398bed13f$export$d771543c4ed87064(state, config);\n    if (!state.movable.rookCastle && state.movable.dests) {\n        const rank = state.movable.color === 'white' ? '1' : '8', kingStartPos = 'e' + rank, dests = state.movable.dests.get(kingStartPos), king = state.pieces.get(kingStartPos);\n        if (!dests || !king || king.role !== 'king') return;\n        state.movable.dests.set(kingStartPos, dests.filter((d)=>!(d === 'a' + rank && dests.includes('c' + rank)) && !(d === 'h' + rank && dests.includes('g' + rank))));\n    }\n}\nfunction $f210fdc398bed13f$var$deepMerge(base, extend) {\n    for(const key in extend)if (Object.prototype.hasOwnProperty.call(extend, key)) {\n        if (Object.prototype.hasOwnProperty.call(base, key) && $f210fdc398bed13f$var$isPlainObject(base[key]) && $f210fdc398bed13f$var$isPlainObject(extend[key])) $f210fdc398bed13f$var$deepMerge(base[key], extend[key]);\n        else base[key] = extend[key];\n    }\n}\nfunction $f210fdc398bed13f$var$isPlainObject(o) {\n    if (typeof o !== 'object' || o === null) return false;\n    const proto = Object.getPrototypeOf(o);\n    return proto === Object.prototype || proto === null;\n}\n\n\n\nconst $eef2d951b1990073$export$bd46b8ab3689edc4 = (mutation, state)=>state.animation.enabled ? $eef2d951b1990073$var$animate(mutation, state) : $eef2d951b1990073$export$b3890eb0ae9dca99(mutation, state);\nfunction $eef2d951b1990073$export$b3890eb0ae9dca99(mutation, state) {\n    const result = mutation(state);\n    state.dom.redraw();\n    return result;\n}\nconst $eef2d951b1990073$var$makePiece = (key, piece)=>({\n        key: key,\n        pos: $12cc5d8f1c8e91f5$export$e2878eba51f22d11(key),\n        piece: piece\n    });\nconst $eef2d951b1990073$var$closer = (piece, pieces)=>pieces.sort((p1, p2)=>$12cc5d8f1c8e91f5$export$e4884e1734dcd545(piece.pos, p1.pos) - $12cc5d8f1c8e91f5$export$e4884e1734dcd545(piece.pos, p2.pos))[0];\nfunction $eef2d951b1990073$var$computePlan(prevPieces, current) {\n    const anims = new Map(), animedOrigs = [], fadings = new Map(), missings = [], news = [], prePieces = new Map();\n    let curP, preP, vector;\n    for (const [k, p] of prevPieces)prePieces.set(k, $eef2d951b1990073$var$makePiece(k, p));\n    for (const key of $12cc5d8f1c8e91f5$export$ade7a30951d0bc54){\n        curP = current.pieces.get(key);\n        preP = prePieces.get(key);\n        if (curP) {\n            if (preP) {\n                if (!$12cc5d8f1c8e91f5$export$e329b1a538c004fa(curP, preP.piece)) {\n                    missings.push(preP);\n                    news.push($eef2d951b1990073$var$makePiece(key, curP));\n                }\n            } else news.push($eef2d951b1990073$var$makePiece(key, curP));\n        } else if (preP) missings.push(preP);\n    }\n    for (const newP of news){\n        preP = $eef2d951b1990073$var$closer(newP, missings.filter((p)=>$12cc5d8f1c8e91f5$export$e329b1a538c004fa(newP.piece, p.piece)));\n        if (preP) {\n            vector = [\n                preP.pos[0] - newP.pos[0],\n                preP.pos[1] - newP.pos[1]\n            ];\n            anims.set(newP.key, vector.concat(vector));\n            animedOrigs.push(preP.key);\n        }\n    }\n    for (const p of missings)if (!animedOrigs.includes(p.key)) fadings.set(p.key, p.piece);\n    return {\n        anims: anims,\n        fadings: fadings\n    };\n}\nfunction $eef2d951b1990073$var$step(state, now) {\n    const cur = state.animation.current;\n    if (cur === undefined) {\n        // animation was canceled :(\n        if (!state.dom.destroyed) state.dom.redrawNow();\n        return;\n    }\n    const rest = 1 - (now - cur.start) * cur.frequency;\n    if (rest <= 0) {\n        state.animation.current = undefined;\n        state.dom.redrawNow();\n    } else {\n        const ease = $eef2d951b1990073$var$easing(rest);\n        for (const cfg of cur.plan.anims.values()){\n            cfg[2] = cfg[0] * ease;\n            cfg[3] = cfg[1] * ease;\n        }\n        state.dom.redrawNow(true); // optimisation: don't render SVG changes during animations\n        requestAnimationFrame((now = performance.now())=>$eef2d951b1990073$var$step(state, now));\n    }\n}\nfunction $eef2d951b1990073$var$animate(mutation, state) {\n    // clone state before mutating it\n    const prevPieces = new Map(state.pieces);\n    const result = mutation(state);\n    const plan = $eef2d951b1990073$var$computePlan(prevPieces, state);\n    if (plan.anims.size || plan.fadings.size) {\n        const alreadyRunning = state.animation.current && state.animation.current.start;\n        state.animation.current = {\n            start: performance.now(),\n            frequency: 1 / state.animation.duration,\n            plan: plan\n        };\n        if (!alreadyRunning) $eef2d951b1990073$var$step(state, performance.now());\n    } else // don't animate, just render right away\n    state.dom.redraw();\n    return result;\n}\n// https://gist.github.com/gre/1650294\nconst $eef2d951b1990073$var$easing = (t)=>t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n\n\n\n\n\n\nconst $ca7a5155221e62eb$var$brushes = [\n    'green',\n    'red',\n    'blue',\n    'yellow'\n];\nfunction $ca7a5155221e62eb$export$b3571188c770cc5a(state, e) {\n    // support one finger touch only\n    if (e.touches && e.touches.length > 1) return;\n    e.stopPropagation();\n    e.preventDefault();\n    e.ctrlKey ? (0, $e9a4281a8a1ce8a6$export$fe412c270a34f415)(state) : (0, $e9a4281a8a1ce8a6$export$e47a3d6268102bb5)(state);\n    const pos = (0, $12cc5d8f1c8e91f5$export$33052595192f7117)(e), orig = (0, $e9a4281a8a1ce8a6$export$102bdd581884418b)(pos, (0, $e9a4281a8a1ce8a6$export$970133fdf67d86cb)(state), state.dom.bounds());\n    if (!orig) return;\n    state.drawable.current = {\n        orig: orig,\n        pos: pos,\n        brush: $ca7a5155221e62eb$var$eventBrush(e),\n        snapToValidMove: state.drawable.defaultSnapToValidMove\n    };\n    $ca7a5155221e62eb$export$816e7b21815d9cf9(state);\n}\nfunction $ca7a5155221e62eb$export$816e7b21815d9cf9(state) {\n    requestAnimationFrame(()=>{\n        const cur = state.drawable.current;\n        if (cur) {\n            const keyAtDomPos = (0, $e9a4281a8a1ce8a6$export$102bdd581884418b)(cur.pos, (0, $e9a4281a8a1ce8a6$export$970133fdf67d86cb)(state), state.dom.bounds());\n            if (!keyAtDomPos) cur.snapToValidMove = false;\n            const mouseSq = cur.snapToValidMove ? (0, $e9a4281a8a1ce8a6$export$6ee499125a88eb43)(cur.orig, cur.pos, (0, $e9a4281a8a1ce8a6$export$970133fdf67d86cb)(state), state.dom.bounds()) : keyAtDomPos;\n            if (mouseSq !== cur.mouseSq) {\n                cur.mouseSq = mouseSq;\n                cur.dest = mouseSq !== cur.orig ? mouseSq : undefined;\n                state.dom.redrawNow();\n            }\n            $ca7a5155221e62eb$export$816e7b21815d9cf9(state);\n        }\n    });\n}\nfunction $ca7a5155221e62eb$export$d947e5f4f4c48d48(state, e) {\n    if (state.drawable.current) state.drawable.current.pos = (0, $12cc5d8f1c8e91f5$export$33052595192f7117)(e);\n}\nfunction $ca7a5155221e62eb$export$bd5df0f255a350f8(state) {\n    const cur = state.drawable.current;\n    if (cur) {\n        if (cur.mouseSq) $ca7a5155221e62eb$var$addShape(state.drawable, cur);\n        $ca7a5155221e62eb$export$70b61ad426ddbe54(state);\n    }\n}\nfunction $ca7a5155221e62eb$export$70b61ad426ddbe54(state) {\n    if (state.drawable.current) {\n        state.drawable.current = undefined;\n        state.dom.redraw();\n    }\n}\nfunction $ca7a5155221e62eb$export$42ffd38884aecdac(state) {\n    if (state.drawable.shapes.length) {\n        state.drawable.shapes = [];\n        state.dom.redraw();\n        $ca7a5155221e62eb$var$onChange(state.drawable);\n    }\n}\nfunction $ca7a5155221e62eb$var$eventBrush(e) {\n    var _a;\n    const modA = (e.shiftKey || e.ctrlKey) && (0, $12cc5d8f1c8e91f5$export$947a472b5b3020ba)(e);\n    const modB = e.altKey || e.metaKey || ((_a = e.getModifierState) === null || _a === void 0 ? void 0 : _a.call(e, 'AltGraph'));\n    return $ca7a5155221e62eb$var$brushes[(modA ? 1 : 0) + (modB ? 2 : 0)];\n}\nfunction $ca7a5155221e62eb$var$addShape(drawable, cur) {\n    const sameShape = (s)=>s.orig === cur.orig && s.dest === cur.dest;\n    const similar = drawable.shapes.find(sameShape);\n    if (similar) drawable.shapes = drawable.shapes.filter((s)=>!sameShape(s));\n    if (!similar || similar.brush !== cur.brush) drawable.shapes.push({\n        orig: cur.orig,\n        dest: cur.dest,\n        brush: cur.brush\n    });\n    $ca7a5155221e62eb$var$onChange(drawable);\n}\nfunction $ca7a5155221e62eb$var$onChange(drawable) {\n    if (drawable.onChange) drawable.onChange(drawable.shapes);\n}\n\n\n\nfunction $d6c60d68c89e4d3b$export$b3571188c770cc5a(s, e) {\n    if (!(s.trustAllEvents || e.isTrusted)) return; // only trust when trustAllEvents is enabled\n    if (e.buttons !== undefined && e.buttons > 1) return; // only touch or left click\n    if (e.touches && e.touches.length > 1) return; // support one finger touch only\n    const bounds = s.dom.bounds(), position = $12cc5d8f1c8e91f5$export$33052595192f7117(e), orig = $e9a4281a8a1ce8a6$export$102bdd581884418b(position, $e9a4281a8a1ce8a6$export$970133fdf67d86cb(s), bounds);\n    if (!orig) return;\n    const piece = s.pieces.get(orig);\n    const previouslySelected = s.selected;\n    if (!previouslySelected && s.drawable.enabled && (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor)) (0, $ca7a5155221e62eb$export$42ffd38884aecdac)(s);\n    // Prevent touch scroll and create no corresponding mouse event, if there\n    // is an intent to interact with the board.\n    if (e.cancelable !== false && (!e.touches || s.blockTouchScroll || piece || previouslySelected || $d6c60d68c89e4d3b$var$pieceCloseTo(s, position))) e.preventDefault();\n    else if (e.touches) return; // Handle only corresponding mouse event https://github.com/lichess-org/chessground/pull/268\n    const hadPremove = !!s.premovable.current;\n    const hadPredrop = !!s.predroppable.current;\n    s.stats.ctrlKey = e.ctrlKey;\n    if (s.selected && $e9a4281a8a1ce8a6$export$a4ef2b0c3fa55ad2(s, s.selected, orig)) (0, $eef2d951b1990073$export$bd46b8ab3689edc4)((state)=>$e9a4281a8a1ce8a6$export$6073914ea697a63e(state, orig), s);\n    else $e9a4281a8a1ce8a6$export$6073914ea697a63e(s, orig);\n    const stillSelected = s.selected === orig;\n    const element = $d6c60d68c89e4d3b$var$pieceElementByKey(s, orig);\n    if (piece && element && stillSelected && $e9a4281a8a1ce8a6$export$fe8f97248bbe2d04(s, orig)) {\n        s.draggable.current = {\n            orig: orig,\n            piece: piece,\n            origPos: position,\n            pos: position,\n            started: s.draggable.autoDistance && s.stats.dragged,\n            element: element,\n            previouslySelected: previouslySelected,\n            originTarget: e.target,\n            keyHasChanged: false\n        };\n        element.cgDragging = true;\n        element.classList.add('dragging');\n        // place ghost\n        const ghost = s.dom.elements.ghost;\n        if (ghost) {\n            ghost.className = `ghost ${piece.color} ${piece.role}`;\n            $12cc5d8f1c8e91f5$export$d73ee8ef04f5226a(ghost, $12cc5d8f1c8e91f5$export$2135ad75550a2ff4(bounds)($12cc5d8f1c8e91f5$export$e2878eba51f22d11(orig), $e9a4281a8a1ce8a6$export$970133fdf67d86cb(s)));\n            $12cc5d8f1c8e91f5$export$8cb512849e51eaf5(ghost, true);\n        }\n        $d6c60d68c89e4d3b$var$processDrag(s);\n    } else {\n        if (hadPremove) $e9a4281a8a1ce8a6$export$f92a111f74a3f7c7(s);\n        if (hadPredrop) $e9a4281a8a1ce8a6$export$9e6f418e5ea6b92c(s);\n    }\n    s.dom.redraw();\n}\nfunction $d6c60d68c89e4d3b$var$pieceCloseTo(s, pos) {\n    const asWhite = $e9a4281a8a1ce8a6$export$970133fdf67d86cb(s), bounds = s.dom.bounds(), radiusSq = Math.pow(bounds.width / 8, 2);\n    for (const key of s.pieces.keys()){\n        const center = $12cc5d8f1c8e91f5$export$1c17f680299a31f7(key, asWhite, bounds);\n        if ($12cc5d8f1c8e91f5$export$e4884e1734dcd545(center, pos) <= radiusSq) return true;\n    }\n    return false;\n}\nfunction $d6c60d68c89e4d3b$export$65771a6862d302e4(s, piece, e, force) {\n    const key = 'a0';\n    s.pieces.set(key, piece);\n    s.dom.redraw();\n    const position = $12cc5d8f1c8e91f5$export$33052595192f7117(e);\n    s.draggable.current = {\n        orig: key,\n        piece: piece,\n        origPos: position,\n        pos: position,\n        started: true,\n        element: ()=>$d6c60d68c89e4d3b$var$pieceElementByKey(s, key),\n        originTarget: e.target,\n        newPiece: true,\n        force: !!force,\n        keyHasChanged: false\n    };\n    $d6c60d68c89e4d3b$var$processDrag(s);\n}\nfunction $d6c60d68c89e4d3b$var$processDrag(s) {\n    requestAnimationFrame(()=>{\n        var _a;\n        const cur = s.draggable.current;\n        if (!cur) return;\n        // cancel animations while dragging\n        if ((_a = s.animation.current) === null || _a === void 0 ? void 0 : _a.plan.anims.has(cur.orig)) s.animation.current = undefined;\n        // if moving piece is gone, cancel\n        const origPiece = s.pieces.get(cur.orig);\n        if (!origPiece || !$12cc5d8f1c8e91f5$export$e329b1a538c004fa(origPiece, cur.piece)) $d6c60d68c89e4d3b$export$70b61ad426ddbe54(s);\n        else {\n            if (!cur.started && $12cc5d8f1c8e91f5$export$e4884e1734dcd545(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2)) cur.started = true;\n            if (cur.started) {\n                // support lazy elements\n                if (typeof cur.element === 'function') {\n                    const found = cur.element();\n                    if (!found) return;\n                    found.cgDragging = true;\n                    found.classList.add('dragging');\n                    cur.element = found;\n                }\n                const bounds = s.dom.bounds();\n                $12cc5d8f1c8e91f5$export$d73ee8ef04f5226a(cur.element, [\n                    cur.pos[0] - bounds.left - bounds.width / 16,\n                    cur.pos[1] - bounds.top - bounds.height / 16\n                ]);\n                cur.keyHasChanged || (cur.keyHasChanged = cur.orig !== $e9a4281a8a1ce8a6$export$102bdd581884418b(cur.pos, $e9a4281a8a1ce8a6$export$970133fdf67d86cb(s), bounds));\n            }\n        }\n        $d6c60d68c89e4d3b$var$processDrag(s);\n    });\n}\nfunction $d6c60d68c89e4d3b$export$d947e5f4f4c48d48(s, e) {\n    // support one finger touch only\n    if (s.draggable.current && (!e.touches || e.touches.length < 2)) s.draggable.current.pos = $12cc5d8f1c8e91f5$export$33052595192f7117(e);\n}\nfunction $d6c60d68c89e4d3b$export$bd5df0f255a350f8(s, e) {\n    const cur = s.draggable.current;\n    if (!cur) return;\n    // create no corresponding mouse event\n    if (e.type === 'touchend' && e.cancelable !== false) e.preventDefault();\n    // comparing with the origin target is an easy way to test that the end event\n    // has the same touch origin\n    if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {\n        s.draggable.current = undefined;\n        return;\n    }\n    $e9a4281a8a1ce8a6$export$f92a111f74a3f7c7(s);\n    $e9a4281a8a1ce8a6$export$9e6f418e5ea6b92c(s);\n    // touchend has no position; so use the last touchmove position instead\n    const eventPos = $12cc5d8f1c8e91f5$export$33052595192f7117(e) || cur.pos;\n    const dest = $e9a4281a8a1ce8a6$export$102bdd581884418b(eventPos, $e9a4281a8a1ce8a6$export$970133fdf67d86cb(s), s.dom.bounds());\n    if (dest && cur.started && cur.orig !== dest) {\n        if (cur.newPiece) $e9a4281a8a1ce8a6$export$b2b9f46b948033b0(s, cur.orig, dest, cur.force);\n        else {\n            s.stats.ctrlKey = e.ctrlKey;\n            if ($e9a4281a8a1ce8a6$export$843c446e2e718822(s, cur.orig, dest)) s.stats.dragged = true;\n        }\n    } else if (cur.newPiece) s.pieces.delete(cur.orig);\n    else if (s.draggable.deleteOnDropOff && !dest) {\n        s.pieces.delete(cur.orig);\n        $e9a4281a8a1ce8a6$export$6511920ae9f0cd34(s.events.change);\n    }\n    if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest)) $e9a4281a8a1ce8a6$export$fe412c270a34f415(s);\n    else if (!s.selectable.enabled) $e9a4281a8a1ce8a6$export$fe412c270a34f415(s);\n    $d6c60d68c89e4d3b$var$removeDragElements(s);\n    s.draggable.current = undefined;\n    s.dom.redraw();\n}\nfunction $d6c60d68c89e4d3b$export$70b61ad426ddbe54(s) {\n    const cur = s.draggable.current;\n    if (cur) {\n        if (cur.newPiece) s.pieces.delete(cur.orig);\n        s.draggable.current = undefined;\n        $e9a4281a8a1ce8a6$export$fe412c270a34f415(s);\n        $d6c60d68c89e4d3b$var$removeDragElements(s);\n        s.dom.redraw();\n    }\n}\nfunction $d6c60d68c89e4d3b$var$removeDragElements(s) {\n    const e = s.dom.elements;\n    if (e.ghost) $12cc5d8f1c8e91f5$export$8cb512849e51eaf5(e.ghost, false);\n}\nfunction $d6c60d68c89e4d3b$var$pieceElementByKey(s, key) {\n    let el = s.dom.elements.board.firstChild;\n    while(el){\n        if (el.cgKey === key && el.tagName === 'PIECE') return el;\n        el = el.nextSibling;\n    }\n    return;\n}\n\n\nfunction $9838d65c005eac88$export$4971bcc2704b21ab(state, keys) {\n    state.exploding = {\n        stage: 1,\n        keys: keys\n    };\n    state.dom.redraw();\n    setTimeout(()=>{\n        $9838d65c005eac88$var$setStage(state, 2);\n        setTimeout(()=>$9838d65c005eac88$var$setStage(state, undefined), 120);\n    }, 120);\n}\nfunction $9838d65c005eac88$var$setStage(state, stage) {\n    if (state.exploding) {\n        if (stage) state.exploding.stage = stage;\n        else state.exploding = undefined;\n        state.dom.redraw();\n    }\n}\n\n\nfunction $d1846fb327d0a4d8$export$b3571188c770cc5a(state, redrawAll) {\n    function toggleOrientation() {\n        $e9a4281a8a1ce8a6$export$e798007c48b456cd(state);\n        redrawAll();\n    }\n    return {\n        set (config) {\n            if (config.orientation && config.orientation !== state.orientation) toggleOrientation();\n            (0, $f210fdc398bed13f$export$d771543c4ed87064)(state, config);\n            (config.fen ? (0, $eef2d951b1990073$export$bd46b8ab3689edc4) : (0, $eef2d951b1990073$export$b3890eb0ae9dca99))((state)=>(0, $f210fdc398bed13f$export$8d21e34596265fa2)(state, config), state);\n        },\n        state: state,\n        getFen: ()=>(0, $f02efaa0c4f5e00a$export$68d8715fc104d294)(state.pieces),\n        toggleOrientation: toggleOrientation,\n        setPieces (pieces) {\n            (0, $eef2d951b1990073$export$bd46b8ab3689edc4)((state)=>$e9a4281a8a1ce8a6$export$20a063d1402ff7ff(state, pieces), state);\n        },\n        selectSquare (key, force) {\n            if (key) (0, $eef2d951b1990073$export$bd46b8ab3689edc4)((state)=>$e9a4281a8a1ce8a6$export$6073914ea697a63e(state, key, force), state);\n            else if (state.selected) {\n                $e9a4281a8a1ce8a6$export$fe412c270a34f415(state);\n                state.dom.redraw();\n            }\n        },\n        move (orig, dest) {\n            (0, $eef2d951b1990073$export$bd46b8ab3689edc4)((state)=>$e9a4281a8a1ce8a6$export$13f6ca6271343510(state, orig, dest), state);\n        },\n        newPiece (piece, key) {\n            (0, $eef2d951b1990073$export$bd46b8ab3689edc4)((state)=>$e9a4281a8a1ce8a6$export$13886f9573facc29(state, piece, key), state);\n        },\n        playPremove () {\n            if (state.premovable.current) {\n                if ((0, $eef2d951b1990073$export$bd46b8ab3689edc4)($e9a4281a8a1ce8a6$export$d04320a93cdae73d, state)) return true;\n                // if the premove couldn't be played, redraw to clear it up\n                state.dom.redraw();\n            }\n            return false;\n        },\n        playPredrop (validate) {\n            if (state.predroppable.current) {\n                const result = $e9a4281a8a1ce8a6$export$8efa9460c0cedd9e(state, validate);\n                state.dom.redraw();\n                return result;\n            }\n            return false;\n        },\n        cancelPremove () {\n            (0, $eef2d951b1990073$export$b3890eb0ae9dca99)($e9a4281a8a1ce8a6$export$f92a111f74a3f7c7, state);\n        },\n        cancelPredrop () {\n            (0, $eef2d951b1990073$export$b3890eb0ae9dca99)($e9a4281a8a1ce8a6$export$9e6f418e5ea6b92c, state);\n        },\n        cancelMove () {\n            (0, $eef2d951b1990073$export$b3890eb0ae9dca99)((state)=>{\n                $e9a4281a8a1ce8a6$export$e47a3d6268102bb5(state);\n                (0, $d6c60d68c89e4d3b$export$70b61ad426ddbe54)(state);\n            }, state);\n        },\n        stop () {\n            (0, $eef2d951b1990073$export$b3890eb0ae9dca99)((state)=>{\n                $e9a4281a8a1ce8a6$export$fa6813432f753b0d(state);\n                (0, $d6c60d68c89e4d3b$export$70b61ad426ddbe54)(state);\n            }, state);\n        },\n        explode (keys) {\n            (0, $9838d65c005eac88$export$4971bcc2704b21ab)(state, keys);\n        },\n        setAutoShapes (shapes) {\n            (0, $eef2d951b1990073$export$b3890eb0ae9dca99)((state)=>state.drawable.autoShapes = shapes, state);\n        },\n        setShapes (shapes) {\n            (0, $eef2d951b1990073$export$b3890eb0ae9dca99)((state)=>state.drawable.shapes = shapes, state);\n        },\n        getKeyAtDomPos (pos) {\n            return $e9a4281a8a1ce8a6$export$102bdd581884418b(pos, $e9a4281a8a1ce8a6$export$970133fdf67d86cb(state), state.dom.bounds());\n        },\n        redrawAll: redrawAll,\n        dragNewPiece (piece, event, force) {\n            (0, $d6c60d68c89e4d3b$export$65771a6862d302e4)(state, piece, event, force);\n        },\n        destroy () {\n            $e9a4281a8a1ce8a6$export$fa6813432f753b0d(state);\n            state.dom.unbind && state.dom.unbind();\n            state.dom.destroyed = true;\n        }\n    };\n}\n\n\n\n\n\nfunction $d4a94fd97ea0b308$export$ebe90cb607ad99e() {\n    return {\n        pieces: $f02efaa0c4f5e00a$export$aafa59e2e03f2942($f02efaa0c4f5e00a$export$59ff82fc918bd7e3),\n        orientation: 'white',\n        turnColor: 'white',\n        coordinates: true,\n        coordinatesOnSquares: false,\n        ranksPosition: 'right',\n        autoCastle: true,\n        viewOnly: false,\n        disableContextMenu: false,\n        addPieceZIndex: false,\n        blockTouchScroll: false,\n        pieceKey: false,\n        trustAllEvents: false,\n        highlight: {\n            lastMove: true,\n            check: true\n        },\n        animation: {\n            enabled: true,\n            duration: 200\n        },\n        movable: {\n            free: true,\n            color: 'both',\n            showDests: true,\n            events: {},\n            rookCastle: true\n        },\n        premovable: {\n            enabled: true,\n            showDests: true,\n            castle: true,\n            events: {}\n        },\n        predroppable: {\n            enabled: false,\n            events: {}\n        },\n        draggable: {\n            enabled: true,\n            distance: 3,\n            autoDistance: true,\n            showGhost: true,\n            deleteOnDropOff: false\n        },\n        dropmode: {\n            active: false\n        },\n        selectable: {\n            enabled: true\n        },\n        stats: {\n            // on touchscreen, default to \"tap-tap\" moves\n            // instead of drag\n            dragged: !('ontouchstart' in window)\n        },\n        events: {},\n        drawable: {\n            enabled: true,\n            visible: true,\n            defaultSnapToValidMove: true,\n            eraseOnClick: true,\n            shapes: [],\n            autoShapes: [],\n            brushes: {\n                green: {\n                    key: 'g',\n                    color: '#15781B',\n                    opacity: 1,\n                    lineWidth: 10\n                },\n                red: {\n                    key: 'r',\n                    color: '#882020',\n                    opacity: 1,\n                    lineWidth: 10\n                },\n                blue: {\n                    key: 'b',\n                    color: '#003088',\n                    opacity: 1,\n                    lineWidth: 10\n                },\n                yellow: {\n                    key: 'y',\n                    color: '#e68f00',\n                    opacity: 1,\n                    lineWidth: 10\n                },\n                paleBlue: {\n                    key: 'pb',\n                    color: '#003088',\n                    opacity: 0.4,\n                    lineWidth: 15\n                },\n                paleGreen: {\n                    key: 'pg',\n                    color: '#15781B',\n                    opacity: 0.4,\n                    lineWidth: 15\n                },\n                paleRed: {\n                    key: 'pr',\n                    color: '#882020',\n                    opacity: 0.4,\n                    lineWidth: 15\n                },\n                paleGrey: {\n                    key: 'pgr',\n                    color: '#4a4a4a',\n                    opacity: 0.35,\n                    lineWidth: 15\n                },\n                purple: {\n                    key: 'purple',\n                    color: '#68217a',\n                    opacity: 0.65,\n                    lineWidth: 10\n                },\n                pink: {\n                    key: 'pink',\n                    color: '#ee2080',\n                    opacity: 0.5,\n                    lineWidth: 10\n                },\n                white: {\n                    key: 'white',\n                    color: 'white',\n                    opacity: 1,\n                    lineWidth: 10\n                }\n            },\n            prevSvgHash: ''\n        },\n        hold: (0, $12cc5d8f1c8e91f5$export$9dc4ecf953986f04)()\n    };\n}\n\n\n\n\n\nconst $c530a7760a946b4a$var$hilites = {\n    hilitePrimary: {\n        key: 'hilitePrimary',\n        color: '#3291ff',\n        opacity: 1,\n        lineWidth: 1\n    },\n    hiliteWhite: {\n        key: 'hiliteWhite',\n        color: '#ffffff',\n        opacity: 1,\n        lineWidth: 1\n    }\n};\nfunction $c530a7760a946b4a$export$a529cedf94de8dc() {\n    const defs = $c530a7760a946b4a$export$c8a8987d4410bf2d('defs');\n    const filter = $c530a7760a946b4a$export$74da2cba014bdc09($c530a7760a946b4a$export$c8a8987d4410bf2d('filter'), {\n        id: 'cg-filter-blur'\n    });\n    filter.appendChild($c530a7760a946b4a$export$74da2cba014bdc09($c530a7760a946b4a$export$c8a8987d4410bf2d('feGaussianBlur'), {\n        stdDeviation: '0.019'\n    }));\n    defs.appendChild(filter);\n    return defs;\n}\nfunction $c530a7760a946b4a$export$fb80b1b7d7777ee5(state, shapesEl, customsEl) {\n    var _a;\n    const d = state.drawable, curD = d.current, cur = curD && curD.mouseSq ? curD : undefined, dests = new Map(), bounds = state.dom.bounds(), nonPieceAutoShapes = d.autoShapes.filter((autoShape)=>!autoShape.piece);\n    for (const s of d.shapes.concat(nonPieceAutoShapes).concat(cur ? [\n        cur\n    ] : [])){\n        if (!s.dest) continue;\n        const sources = (_a = dests.get(s.dest)) !== null && _a !== void 0 ? _a : new Set(), from = $c530a7760a946b4a$var$pos2user($c530a7760a946b4a$var$orient((0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(s.orig), state.orientation), bounds), to = $c530a7760a946b4a$var$pos2user($c530a7760a946b4a$var$orient((0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(s.dest), state.orientation), bounds);\n        sources.add($c530a7760a946b4a$var$moveAngle(from, to));\n        dests.set(s.dest, sources);\n    }\n    const shapes = d.shapes.concat(nonPieceAutoShapes).map((s)=>{\n        return {\n            shape: s,\n            current: false,\n            hash: $c530a7760a946b4a$var$shapeHash(s, $c530a7760a946b4a$var$isShort(s.dest, dests), false, bounds)\n        };\n    });\n    if (cur) shapes.push({\n        shape: cur,\n        current: true,\n        hash: $c530a7760a946b4a$var$shapeHash(cur, $c530a7760a946b4a$var$isShort(cur.dest, dests), true, bounds)\n    });\n    const fullHash = shapes.map((sc)=>sc.hash).join(';');\n    if (fullHash === state.drawable.prevSvgHash) return;\n    state.drawable.prevSvgHash = fullHash;\n    /*\n      -- DOM hierarchy --\n      <svg class=\"cg-shapes\">      (<= svg)\n        <defs>\n          ...(for brushes)...\n        </defs>\n        <g>\n          ...(for arrows and circles)...\n        </g>\n      </svg>\n      <svg class=\"cg-custom-svgs\"> (<= customSvg)\n        <g>\n          ...(for custom svgs)...\n        </g>\n      </svg>\n    */ const defsEl = shapesEl.querySelector('defs');\n    $c530a7760a946b4a$var$syncDefs(d, shapes, defsEl);\n    $c530a7760a946b4a$var$syncShapes(shapes, shapesEl.querySelector('g'), customsEl.querySelector('g'), (s)=>$c530a7760a946b4a$var$renderShape(state, s, d.brushes, dests, bounds));\n}\n// append only. Don't try to update/remove.\nfunction $c530a7760a946b4a$var$syncDefs(d, shapes, defsEl) {\n    var _a;\n    const brushes = new Map();\n    let brush;\n    for (const s of shapes.filter((s)=>s.shape.dest && s.shape.brush)){\n        brush = $c530a7760a946b4a$var$makeCustomBrush(d.brushes[s.shape.brush], s.shape.modifiers);\n        if ((_a = s.shape.modifiers) === null || _a === void 0 ? void 0 : _a.hilite) brushes.set($c530a7760a946b4a$var$hilite(brush).key, $c530a7760a946b4a$var$hilite(brush));\n        brushes.set(brush.key, brush);\n    }\n    const keysInDom = new Set();\n    let el = defsEl.firstElementChild;\n    while(el){\n        keysInDom.add(el.getAttribute('cgKey'));\n        el = el.nextElementSibling;\n    }\n    for (const [key, brush] of brushes.entries())if (!keysInDom.has(key)) defsEl.appendChild($c530a7760a946b4a$var$renderMarker(brush));\n}\nfunction $c530a7760a946b4a$var$syncShapes(syncables, shapes, customs, renderShape) {\n    const hashesInDom = new Map();\n    for (const sc of syncables)hashesInDom.set(sc.hash, false);\n    for (const root of [\n        shapes,\n        customs\n    ]){\n        const toRemove = [];\n        let el = root.firstElementChild, elHash;\n        while(el){\n            elHash = el.getAttribute('cgHash');\n            if (hashesInDom.has(elHash)) hashesInDom.set(elHash, true);\n            else toRemove.push(el);\n            el = el.nextElementSibling;\n        }\n        for (const el of toRemove)root.removeChild(el);\n    }\n    // insert shapes that are not yet in dom\n    for (const sc of syncables.filter((s)=>!hashesInDom.get(s.hash))){\n        for (const svg of renderShape(sc))if (svg.isCustom) customs.appendChild(svg.el);\n        else shapes.appendChild(svg.el);\n    }\n}\nfunction $c530a7760a946b4a$var$shapeHash({ orig: orig, dest: dest, brush: brush, piece: piece, modifiers: modifiers, customSvg: customSvg, label: label }, shorten, current, bounds) {\n    var _a, _b;\n    // a shape and an overlay svg share a lifetime and have the same cgHash attribute\n    return [\n        bounds.width,\n        bounds.height,\n        current,\n        orig,\n        dest,\n        brush,\n        shorten && '-',\n        piece && $c530a7760a946b4a$var$pieceHash(piece),\n        modifiers && $c530a7760a946b4a$var$modifiersHash(modifiers),\n        customSvg && `custom-${$c530a7760a946b4a$var$textHash(customSvg.html)},${(_b = (_a = customSvg.center) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'o'}`,\n        label && `label-${$c530a7760a946b4a$var$textHash(label.text)}`\n    ].filter((x)=>x).join(',');\n}\nfunction $c530a7760a946b4a$var$pieceHash(piece) {\n    return [\n        piece.color,\n        piece.role,\n        piece.scale\n    ].filter((x)=>x).join(',');\n}\nfunction $c530a7760a946b4a$var$modifiersHash(m) {\n    return [\n        m.lineWidth,\n        m.hilite && '*'\n    ].filter((x)=>x).join(',');\n}\nfunction $c530a7760a946b4a$var$textHash(s) {\n    // Rolling hash with base 31 (cf. https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript)\n    let h = 0;\n    for(let i = 0; i < s.length; i++)h = (h << 5) - h + s.charCodeAt(i) >>> 0;\n    return h.toString();\n}\nfunction $c530a7760a946b4a$var$renderShape(state, { shape: shape, current: current, hash: hash }, brushes, dests, bounds) {\n    var _a, _b;\n    const from = $c530a7760a946b4a$var$pos2user($c530a7760a946b4a$var$orient((0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(shape.orig), state.orientation), bounds), to = shape.dest ? $c530a7760a946b4a$var$pos2user($c530a7760a946b4a$var$orient((0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(shape.dest), state.orientation), bounds) : from, brush = shape.brush && $c530a7760a946b4a$var$makeCustomBrush(brushes[shape.brush], shape.modifiers), slots = dests.get(shape.dest), svgs = [];\n    if (brush) {\n        const el = $c530a7760a946b4a$export$74da2cba014bdc09($c530a7760a946b4a$export$c8a8987d4410bf2d('g'), {\n            cgHash: hash\n        });\n        svgs.push({\n            el: el\n        });\n        if (from[0] !== to[0] || from[1] !== to[1]) el.appendChild($c530a7760a946b4a$var$renderArrow(shape, brush, from, to, current, $c530a7760a946b4a$var$isShort(shape.dest, dests)));\n        else el.appendChild($c530a7760a946b4a$var$renderCircle(brushes[shape.brush], from, current, bounds));\n    }\n    if (shape.label) {\n        const label = shape.label;\n        (_a = label.fill) !== null && _a !== void 0 ? _a : label.fill = shape.brush && brushes[shape.brush].color;\n        const corner = shape.brush ? undefined : 'tr';\n        svgs.push({\n            el: $c530a7760a946b4a$var$renderLabel(label, hash, from, to, slots, corner),\n            isCustom: true\n        });\n    }\n    if (shape.customSvg) {\n        const on = (_b = shape.customSvg.center) !== null && _b !== void 0 ? _b : 'orig';\n        const [x, y] = on === 'label' ? $c530a7760a946b4a$var$labelCoords(from, to, slots).map((c)=>c - 0.5) : on === 'dest' ? to : from;\n        const el = $c530a7760a946b4a$export$74da2cba014bdc09($c530a7760a946b4a$export$c8a8987d4410bf2d('g'), {\n            transform: `translate(${x},${y})`,\n            cgHash: hash\n        });\n        el.innerHTML = `<svg width=\"1\" height=\"1\" viewBox=\"0 0 100 100\">${shape.customSvg.html}</svg>`;\n        svgs.push({\n            el: el,\n            isCustom: true\n        });\n    }\n    return svgs;\n}\nfunction $c530a7760a946b4a$var$renderCircle(brush, at, current, bounds) {\n    const widths = $c530a7760a946b4a$var$circleWidth(), radius = (bounds.width + bounds.height) / (4 * Math.max(bounds.width, bounds.height));\n    return $c530a7760a946b4a$export$74da2cba014bdc09($c530a7760a946b4a$export$c8a8987d4410bf2d('circle'), {\n        stroke: brush.color,\n        'stroke-width': widths[current ? 0 : 1],\n        fill: 'none',\n        opacity: $c530a7760a946b4a$var$opacity(brush, current),\n        cx: at[0],\n        cy: at[1],\n        r: radius - widths[1] / 2\n    });\n}\nfunction $c530a7760a946b4a$var$hilite(brush) {\n    return [\n        '#ffffff',\n        '#fff',\n        'white'\n    ].includes(brush.color) ? $c530a7760a946b4a$var$hilites['hilitePrimary'] : $c530a7760a946b4a$var$hilites['hiliteWhite'];\n}\nfunction $c530a7760a946b4a$var$renderArrow(s, brush, from, to, current, shorten) {\n    var _a;\n    function renderLine(isHilite) {\n        var _a;\n        const m = $c530a7760a946b4a$var$arrowMargin(shorten && !current), dx = to[0] - from[0], dy = to[1] - from[1], angle = Math.atan2(dy, dx), xo = Math.cos(angle) * m, yo = Math.sin(angle) * m;\n        return $c530a7760a946b4a$export$74da2cba014bdc09($c530a7760a946b4a$export$c8a8987d4410bf2d('line'), {\n            stroke: isHilite ? $c530a7760a946b4a$var$hilite(brush).color : brush.color,\n            'stroke-width': $c530a7760a946b4a$var$lineWidth(brush, current) + (isHilite ? 0.04 : 0),\n            'stroke-linecap': 'round',\n            'marker-end': `url(#arrowhead-${isHilite ? $c530a7760a946b4a$var$hilite(brush).key : brush.key})`,\n            opacity: ((_a = s.modifiers) === null || _a === void 0 ? void 0 : _a.hilite) ? 1 : $c530a7760a946b4a$var$opacity(brush, current),\n            x1: from[0],\n            y1: from[1],\n            x2: to[0] - xo,\n            y2: to[1] - yo\n        });\n    }\n    if (!((_a = s.modifiers) === null || _a === void 0 ? void 0 : _a.hilite)) return renderLine(false);\n    const g = $c530a7760a946b4a$export$c8a8987d4410bf2d('g');\n    const blurred = $c530a7760a946b4a$export$74da2cba014bdc09($c530a7760a946b4a$export$c8a8987d4410bf2d('g'), {\n        filter: 'url(#cg-filter-blur)'\n    });\n    blurred.appendChild($c530a7760a946b4a$var$filterBox(from, to));\n    blurred.appendChild(renderLine(true));\n    g.appendChild(blurred);\n    g.appendChild(renderLine(false));\n    return g;\n}\nfunction $c530a7760a946b4a$var$renderMarker(brush) {\n    const marker = $c530a7760a946b4a$export$74da2cba014bdc09($c530a7760a946b4a$export$c8a8987d4410bf2d('marker'), {\n        id: 'arrowhead-' + brush.key,\n        orient: 'auto',\n        overflow: 'visible',\n        markerWidth: 4,\n        markerHeight: 4,\n        refX: brush.key.startsWith('hilite') ? 1.86 : 2.05,\n        refY: 2\n    });\n    marker.appendChild($c530a7760a946b4a$export$74da2cba014bdc09($c530a7760a946b4a$export$c8a8987d4410bf2d('path'), {\n        d: 'M0,0 V4 L3,2 Z',\n        fill: brush.color\n    }));\n    marker.setAttribute('cgKey', brush.key);\n    return marker;\n}\nfunction $c530a7760a946b4a$var$renderLabel(label, hash, from, to, slots, corner) {\n    var _a;\n    const labelSize = 0.4, fontSize = labelSize * 0.75 ** label.text.length, at = $c530a7760a946b4a$var$labelCoords(from, to, slots), cornerOff = corner === 'tr' ? 0.4 : 0, g = $c530a7760a946b4a$export$74da2cba014bdc09($c530a7760a946b4a$export$c8a8987d4410bf2d('g'), {\n        transform: `translate(${at[0] + cornerOff},${at[1] - cornerOff})`,\n        cgHash: hash\n    });\n    g.appendChild($c530a7760a946b4a$export$74da2cba014bdc09($c530a7760a946b4a$export$c8a8987d4410bf2d('circle'), {\n        r: labelSize / 2,\n        'fill-opacity': corner ? 1.0 : 0.8,\n        'stroke-opacity': corner ? 1.0 : 0.7,\n        'stroke-width': 0.03,\n        fill: (_a = label.fill) !== null && _a !== void 0 ? _a : '#666',\n        stroke: 'white'\n    }));\n    const labelEl = $c530a7760a946b4a$export$74da2cba014bdc09($c530a7760a946b4a$export$c8a8987d4410bf2d('text'), {\n        'font-size': fontSize,\n        'font-family': 'Noto Sans',\n        'text-anchor': 'middle',\n        fill: 'white',\n        y: 0.13 * 0.75 ** label.text.length\n    });\n    labelEl.innerHTML = label.text;\n    g.appendChild(labelEl);\n    return g;\n}\nfunction $c530a7760a946b4a$var$orient(pos, color) {\n    return color === 'white' ? pos : [\n        7 - pos[0],\n        7 - pos[1]\n    ];\n}\nfunction $c530a7760a946b4a$var$isShort(dest, dests) {\n    return true === (dest && dests.has(dest) && dests.get(dest).size > 1);\n}\nfunction $c530a7760a946b4a$export$c8a8987d4410bf2d(tagName) {\n    return document.createElementNS('http://www.w3.org/2000/svg', tagName);\n}\nfunction $c530a7760a946b4a$export$74da2cba014bdc09(el, attrs) {\n    for(const key in attrs)if (Object.prototype.hasOwnProperty.call(attrs, key)) el.setAttribute(key, attrs[key]);\n    return el;\n}\nfunction $c530a7760a946b4a$var$makeCustomBrush(base, modifiers) {\n    return !modifiers ? base : {\n        color: base.color,\n        opacity: Math.round(base.opacity * 10) / 10,\n        lineWidth: Math.round(modifiers.lineWidth || base.lineWidth),\n        key: [\n            base.key,\n            modifiers.lineWidth\n        ].filter((x)=>x).join('')\n    };\n}\nfunction $c530a7760a946b4a$var$circleWidth() {\n    return [\n        3 / 64,\n        4 / 64\n    ];\n}\nfunction $c530a7760a946b4a$var$lineWidth(brush, current) {\n    return (brush.lineWidth || 10) * (current ? 0.85 : 1) / 64;\n}\nfunction $c530a7760a946b4a$var$opacity(brush, current) {\n    return (brush.opacity || 1) * (current ? 0.9 : 1);\n}\nfunction $c530a7760a946b4a$var$arrowMargin(shorten) {\n    return (shorten ? 20 : 10) / 64;\n}\nfunction $c530a7760a946b4a$var$pos2user(pos, bounds) {\n    const xScale = Math.min(1, bounds.width / bounds.height);\n    const yScale = Math.min(1, bounds.height / bounds.width);\n    return [\n        (pos[0] - 3.5) * xScale,\n        (3.5 - pos[1]) * yScale\n    ];\n}\nfunction $c530a7760a946b4a$var$filterBox(from, to) {\n    // lines/arrows are considered to be one dimensional for the purposes of SVG filters,\n    // so we add a transparent bounding box to ensure they apply to the 2nd dimension\n    const box = {\n        from: [\n            Math.floor(Math.min(from[0], to[0])),\n            Math.floor(Math.min(from[1], to[1]))\n        ],\n        to: [\n            Math.ceil(Math.max(from[0], to[0])),\n            Math.ceil(Math.max(from[1], to[1]))\n        ]\n    };\n    return $c530a7760a946b4a$export$74da2cba014bdc09($c530a7760a946b4a$export$c8a8987d4410bf2d('rect'), {\n        x: box.from[0],\n        y: box.from[1],\n        width: box.to[0] - box.from[0],\n        height: box.to[1] - box.from[1],\n        fill: 'none',\n        stroke: 'none'\n    });\n}\nfunction $c530a7760a946b4a$var$moveAngle(from, to, asSlot = true) {\n    const angle = Math.atan2(to[1] - from[1], to[0] - from[0]) + Math.PI;\n    return asSlot ? (Math.round(angle * 8 / Math.PI) + 16) % 16 : angle;\n}\nfunction $c530a7760a946b4a$var$dist(from, to) {\n    return Math.sqrt([\n        from[0] - to[0],\n        from[1] - to[1]\n    ].reduce((acc, x)=>acc + x * x, 0));\n}\n/*\n try to place label at the junction of the destination shaft and arrowhead. if there's more than\n 1 arrow pointing to a square, the arrow shortens by 10 / 64 units so the label must move as well.\n \n if the angle between two incoming arrows is pi / 8, such as when an adjacent knight and bishop\n attack the same square, the knight's label is slid further down the shaft by an amount equal to\n our label size to avoid collision\n*/ function $c530a7760a946b4a$var$labelCoords(from, to, slots) {\n    let mag = $c530a7760a946b4a$var$dist(from, to);\n    //if (mag === 0) return [from[0], from[1]];\n    const angle = $c530a7760a946b4a$var$moveAngle(from, to, false);\n    if (slots) {\n        mag -= 33 / 64; // reduce by arrowhead length\n        if (slots.size > 1) {\n            mag -= 10 / 64; // reduce by shortening factor\n            const slot = $c530a7760a946b4a$var$moveAngle(from, to);\n            if (slots.has((slot + 1) % 16) || slots.has((slot + 15) % 16)) {\n                if (slot & 1) mag -= 0.4;\n            }\n        }\n    }\n    return [\n        from[0] - Math.cos(angle) * mag,\n        from[1] - Math.sin(angle) * mag\n    ].map((c)=>c + 0.5);\n}\n\n\nfunction $2dd2d8dceeead3a2$export$79188534738a92bf(element, s) {\n    // .cg-wrap (element passed to Chessground)\n    //   cg-container\n    //     cg-board\n    //     svg.cg-shapes\n    //       defs\n    //       g\n    //     svg.cg-custom-svgs\n    //       g\n    //     cg-auto-pieces\n    //     coords.ranks\n    //     coords.files\n    //     piece.ghost\n    element.innerHTML = '';\n    // ensure the cg-wrap class is set\n    // so bounds calculation can use the CSS width/height values\n    // add that class yourself to the element before calling chessground\n    // for a slight performance improvement! (avoids recomputing style)\n    element.classList.add('cg-wrap');\n    for (const c of (0, $89afb1487ee9ea89$export$8f45430ccf837300))element.classList.toggle('orientation-' + c, s.orientation === c);\n    element.classList.toggle('manipulable', !s.viewOnly);\n    const container = (0, $12cc5d8f1c8e91f5$export$3d7cd8ed57263b30)('cg-container');\n    element.appendChild(container);\n    const board = (0, $12cc5d8f1c8e91f5$export$3d7cd8ed57263b30)('cg-board');\n    container.appendChild(board);\n    let svg;\n    let customSvg;\n    let autoPieces;\n    if (s.drawable.visible) {\n        svg = (0, $c530a7760a946b4a$export$74da2cba014bdc09)((0, $c530a7760a946b4a$export$c8a8987d4410bf2d)('svg'), {\n            class: 'cg-shapes',\n            viewBox: '-4 -4 8 8',\n            preserveAspectRatio: 'xMidYMid slice'\n        });\n        svg.appendChild((0, $c530a7760a946b4a$export$a529cedf94de8dc)());\n        svg.appendChild((0, $c530a7760a946b4a$export$c8a8987d4410bf2d)('g'));\n        customSvg = (0, $c530a7760a946b4a$export$74da2cba014bdc09)((0, $c530a7760a946b4a$export$c8a8987d4410bf2d)('svg'), {\n            class: 'cg-custom-svgs',\n            viewBox: '-3.5 -3.5 8 8',\n            preserveAspectRatio: 'xMidYMid slice'\n        });\n        customSvg.appendChild((0, $c530a7760a946b4a$export$c8a8987d4410bf2d)('g'));\n        autoPieces = (0, $12cc5d8f1c8e91f5$export$3d7cd8ed57263b30)('cg-auto-pieces');\n        container.appendChild(svg);\n        container.appendChild(customSvg);\n        container.appendChild(autoPieces);\n    }\n    if (s.coordinates) {\n        const orientClass = s.orientation === 'black' ? ' black' : '';\n        const ranksPositionClass = s.ranksPosition === 'left' ? ' left' : '';\n        if (s.coordinatesOnSquares) {\n            const rankN = s.orientation === 'white' ? (i)=>i + 1 : (i)=>8 - i;\n            (0, $89afb1487ee9ea89$export$3a444357c5f65f65).forEach((f, i)=>container.appendChild($2dd2d8dceeead3a2$var$renderCoords((0, $89afb1487ee9ea89$export$d8e4e3952f325c95).map((r)=>f + r), 'squares rank' + rankN(i) + orientClass + ranksPositionClass)));\n        } else {\n            container.appendChild($2dd2d8dceeead3a2$var$renderCoords((0, $89afb1487ee9ea89$export$d8e4e3952f325c95), 'ranks' + orientClass + ranksPositionClass));\n            container.appendChild($2dd2d8dceeead3a2$var$renderCoords((0, $89afb1487ee9ea89$export$3a444357c5f65f65), 'files' + orientClass));\n        }\n    }\n    let ghost;\n    if (s.draggable.enabled && s.draggable.showGhost) {\n        ghost = (0, $12cc5d8f1c8e91f5$export$3d7cd8ed57263b30)('piece', 'ghost');\n        (0, $12cc5d8f1c8e91f5$export$8cb512849e51eaf5)(ghost, false);\n        container.appendChild(ghost);\n    }\n    return {\n        board: board,\n        container: container,\n        wrap: element,\n        ghost: ghost,\n        svg: svg,\n        customSvg: customSvg,\n        autoPieces: autoPieces\n    };\n}\nfunction $2dd2d8dceeead3a2$var$renderCoords(elems, className) {\n    const el = (0, $12cc5d8f1c8e91f5$export$3d7cd8ed57263b30)('coords', className);\n    let f;\n    for (const elem of elems){\n        f = (0, $12cc5d8f1c8e91f5$export$3d7cd8ed57263b30)('coord');\n        f.textContent = elem;\n        el.appendChild(f);\n    }\n    return el;\n}\n\n\n\n\n\n\n\nfunction $f3f26e160974bad8$export$af7814416196c9de(s, piece) {\n    s.dropmode = {\n        active: true,\n        piece: piece\n    };\n    (0, $d6c60d68c89e4d3b$export$70b61ad426ddbe54)(s);\n}\nfunction $f3f26e160974bad8$export$3bf31ae3228aa49e(s) {\n    s.dropmode = {\n        active: false\n    };\n}\nfunction $f3f26e160974bad8$export$663103110d94aac9(s, e) {\n    if (!s.dropmode.active) return;\n    $e9a4281a8a1ce8a6$export$f92a111f74a3f7c7(s);\n    $e9a4281a8a1ce8a6$export$9e6f418e5ea6b92c(s);\n    const piece = s.dropmode.piece;\n    if (piece) {\n        s.pieces.set('a0', piece);\n        const position = $12cc5d8f1c8e91f5$export$33052595192f7117(e);\n        const dest = position && $e9a4281a8a1ce8a6$export$102bdd581884418b(position, $e9a4281a8a1ce8a6$export$970133fdf67d86cb(s), s.dom.bounds());\n        if (dest) $e9a4281a8a1ce8a6$export$b2b9f46b948033b0(s, 'a0', dest);\n    }\n    s.dom.redraw();\n}\n\n\n\nfunction $bb9a2d6168a64a48$export$fc48d2ed06541843(s, onResize) {\n    const boardEl = s.dom.elements.board;\n    if ('ResizeObserver' in window) new ResizeObserver(onResize).observe(s.dom.elements.wrap);\n    if (s.disableContextMenu || s.drawable.enabled) boardEl.addEventListener('contextmenu', (e)=>e.preventDefault());\n    if (s.viewOnly) return;\n    // Cannot be passive, because we prevent touch scrolling and dragging of\n    // selected elements.\n    const onStart = $bb9a2d6168a64a48$var$startDragOrDraw(s);\n    boardEl.addEventListener('touchstart', onStart, {\n        passive: false\n    });\n    boardEl.addEventListener('mousedown', onStart, {\n        passive: false\n    });\n}\nfunction $bb9a2d6168a64a48$export$fdc77453278b0fa9(s, onResize) {\n    const unbinds = [];\n    // Old versions of Edge and Safari do not support ResizeObserver. Send\n    // chessground.resize if a user action has changed the bounds of the board.\n    if (!('ResizeObserver' in window)) unbinds.push($bb9a2d6168a64a48$var$unbindable(document.body, 'chessground.resize', onResize));\n    if (!s.viewOnly) {\n        const onmove = $bb9a2d6168a64a48$var$dragOrDraw(s, $d6c60d68c89e4d3b$export$d947e5f4f4c48d48, $ca7a5155221e62eb$export$d947e5f4f4c48d48);\n        const onend = $bb9a2d6168a64a48$var$dragOrDraw(s, $d6c60d68c89e4d3b$export$bd5df0f255a350f8, $ca7a5155221e62eb$export$bd5df0f255a350f8);\n        for (const ev of [\n            'touchmove',\n            'mousemove'\n        ])unbinds.push($bb9a2d6168a64a48$var$unbindable(document, ev, onmove));\n        for (const ev of [\n            'touchend',\n            'mouseup'\n        ])unbinds.push($bb9a2d6168a64a48$var$unbindable(document, ev, onend));\n        const onScroll = ()=>s.dom.bounds.clear();\n        unbinds.push($bb9a2d6168a64a48$var$unbindable(document, 'scroll', onScroll, {\n            capture: true,\n            passive: true\n        }));\n        unbinds.push($bb9a2d6168a64a48$var$unbindable(window, 'resize', onScroll, {\n            passive: true\n        }));\n    }\n    return ()=>unbinds.forEach((f)=>f());\n}\nfunction $bb9a2d6168a64a48$var$unbindable(el, eventName, callback, options) {\n    el.addEventListener(eventName, callback, options);\n    return ()=>el.removeEventListener(eventName, callback, options);\n}\nconst $bb9a2d6168a64a48$var$startDragOrDraw = (s)=>(e)=>{\n        if (s.draggable.current) $d6c60d68c89e4d3b$export$70b61ad426ddbe54(s);\n        else if (s.drawable.current) $ca7a5155221e62eb$export$70b61ad426ddbe54(s);\n        else if (e.shiftKey || (0, $12cc5d8f1c8e91f5$export$947a472b5b3020ba)(e)) {\n            if (s.drawable.enabled) $ca7a5155221e62eb$export$b3571188c770cc5a(s, e);\n        } else if (!s.viewOnly) {\n            if (s.dropmode.active) (0, $f3f26e160974bad8$export$663103110d94aac9)(s, e);\n            else $d6c60d68c89e4d3b$export$b3571188c770cc5a(s, e);\n        }\n    };\nconst $bb9a2d6168a64a48$var$dragOrDraw = (s, withDrag, withDraw)=>(e)=>{\n        if (s.drawable.current) {\n            if (s.drawable.enabled) withDraw(s, e);\n        } else if (!s.viewOnly) withDrag(s, e);\n    };\n\n\n\n\nfunction $4bb5156c5d36bd23$export$b3890eb0ae9dca99(s) {\n    const asWhite = (0, $e9a4281a8a1ce8a6$export$970133fdf67d86cb)(s), posToTranslate = (0, $12cc5d8f1c8e91f5$export$2135ad75550a2ff4)(s.dom.bounds()), boardEl = s.dom.elements.board, pieces = s.pieces, curAnim = s.animation.current, anims = curAnim ? curAnim.plan.anims : new Map(), fadings = curAnim ? curAnim.plan.fadings : new Map(), curDrag = s.draggable.current, squares = $4bb5156c5d36bd23$var$computeSquareClasses(s), samePieces = new Set(), sameSquares = new Set(), movedPieces = new Map(), movedSquares = new Map(); // by class name\n    let k, el, pieceAtKey, elPieceName, anim, fading, pMvdset, pMvd, sMvdset, sMvd;\n    // walk over all board dom elements, apply animations and flag moved pieces\n    el = boardEl.firstChild;\n    while(el){\n        k = el.cgKey;\n        if ($4bb5156c5d36bd23$var$isPieceNode(el)) {\n            pieceAtKey = pieces.get(k);\n            anim = anims.get(k);\n            fading = fadings.get(k);\n            elPieceName = el.cgPiece;\n            // if piece not being dragged anymore, remove dragging style\n            if (el.cgDragging && (!curDrag || curDrag.orig !== k)) {\n                el.classList.remove('dragging');\n                (0, $12cc5d8f1c8e91f5$export$d73ee8ef04f5226a)(el, posToTranslate((0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(k), asWhite));\n                el.cgDragging = false;\n            }\n            // remove fading class if it still remains\n            if (!fading && el.cgFading) {\n                el.cgFading = false;\n                el.classList.remove('fading');\n            }\n            // there is now a piece at this dom key\n            if (pieceAtKey) {\n                // continue animation if already animating and same piece\n                // (otherwise it could animate a captured piece)\n                if (anim && el.cgAnimating && elPieceName === $4bb5156c5d36bd23$var$pieceNameOf(pieceAtKey)) {\n                    const pos = (0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(k);\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                    el.classList.add('anim');\n                    (0, $12cc5d8f1c8e91f5$export$d73ee8ef04f5226a)(el, posToTranslate(pos, asWhite));\n                } else if (el.cgAnimating) {\n                    el.cgAnimating = false;\n                    el.classList.remove('anim');\n                    (0, $12cc5d8f1c8e91f5$export$d73ee8ef04f5226a)(el, posToTranslate((0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(k), asWhite));\n                    if (s.addPieceZIndex) el.style.zIndex = $4bb5156c5d36bd23$var$posZIndex((0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(k), asWhite);\n                }\n                // same piece: flag as same\n                if (elPieceName === $4bb5156c5d36bd23$var$pieceNameOf(pieceAtKey) && (!fading || !el.cgFading)) samePieces.add(k);\n                else if (fading && elPieceName === $4bb5156c5d36bd23$var$pieceNameOf(fading)) {\n                    el.classList.add('fading');\n                    el.cgFading = true;\n                } else $4bb5156c5d36bd23$var$appendValue(movedPieces, elPieceName, el);\n            } else $4bb5156c5d36bd23$var$appendValue(movedPieces, elPieceName, el);\n        } else if ($4bb5156c5d36bd23$var$isSquareNode(el)) {\n            const cn = el.className;\n            if (squares.get(k) === cn) sameSquares.add(k);\n            else $4bb5156c5d36bd23$var$appendValue(movedSquares, cn, el);\n        }\n        el = el.nextSibling;\n    }\n    // walk over all squares in current set, apply dom changes to moved squares\n    // or append new squares\n    for (const [sk, className] of squares)if (!sameSquares.has(sk)) {\n        sMvdset = movedSquares.get(className);\n        sMvd = sMvdset && sMvdset.pop();\n        const translation = posToTranslate((0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(sk), asWhite);\n        if (sMvd) {\n            sMvd.cgKey = sk;\n            (0, $12cc5d8f1c8e91f5$export$d73ee8ef04f5226a)(sMvd, translation);\n        } else {\n            const squareNode = (0, $12cc5d8f1c8e91f5$export$3d7cd8ed57263b30)('square', className);\n            squareNode.cgKey = sk;\n            (0, $12cc5d8f1c8e91f5$export$d73ee8ef04f5226a)(squareNode, translation);\n            boardEl.insertBefore(squareNode, boardEl.firstChild);\n        }\n    }\n    // walk over all pieces in current set, apply dom changes to moved pieces\n    // or append new pieces\n    for (const [k, p] of pieces){\n        anim = anims.get(k);\n        if (!samePieces.has(k)) {\n            pMvdset = movedPieces.get($4bb5156c5d36bd23$var$pieceNameOf(p));\n            pMvd = pMvdset && pMvdset.pop();\n            // a same piece was moved\n            if (pMvd) {\n                // apply dom changes\n                pMvd.cgKey = k;\n                if (pMvd.cgFading) {\n                    pMvd.classList.remove('fading');\n                    pMvd.cgFading = false;\n                }\n                const pos = (0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(k);\n                if (s.addPieceZIndex) pMvd.style.zIndex = $4bb5156c5d36bd23$var$posZIndex(pos, asWhite);\n                if (anim) {\n                    pMvd.cgAnimating = true;\n                    pMvd.classList.add('anim');\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                }\n                (0, $12cc5d8f1c8e91f5$export$d73ee8ef04f5226a)(pMvd, posToTranslate(pos, asWhite));\n            } else {\n                const pieceName = $4bb5156c5d36bd23$var$pieceNameOf(p), pieceNode = (0, $12cc5d8f1c8e91f5$export$3d7cd8ed57263b30)('piece', pieceName), pos = (0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(k);\n                pieceNode.cgPiece = pieceName;\n                pieceNode.cgKey = k;\n                if (anim) {\n                    pieceNode.cgAnimating = true;\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                }\n                (0, $12cc5d8f1c8e91f5$export$d73ee8ef04f5226a)(pieceNode, posToTranslate(pos, asWhite));\n                if (s.addPieceZIndex) pieceNode.style.zIndex = $4bb5156c5d36bd23$var$posZIndex(pos, asWhite);\n                boardEl.appendChild(pieceNode);\n            }\n        }\n    }\n    // remove any element that remains in the moved sets\n    for (const nodes of movedPieces.values())$4bb5156c5d36bd23$var$removeNodes(s, nodes);\n    for (const nodes of movedSquares.values())$4bb5156c5d36bd23$var$removeNodes(s, nodes);\n}\nfunction $4bb5156c5d36bd23$export$d62f185fd39aa98c(s) {\n    const asWhite = (0, $e9a4281a8a1ce8a6$export$970133fdf67d86cb)(s), posToTranslate = (0, $12cc5d8f1c8e91f5$export$2135ad75550a2ff4)(s.dom.bounds());\n    let el = s.dom.elements.board.firstChild;\n    while(el){\n        if ($4bb5156c5d36bd23$var$isPieceNode(el) && !el.cgAnimating || $4bb5156c5d36bd23$var$isSquareNode(el)) (0, $12cc5d8f1c8e91f5$export$d73ee8ef04f5226a)(el, posToTranslate((0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(el.cgKey), asWhite));\n        el = el.nextSibling;\n    }\n}\nfunction $4bb5156c5d36bd23$export$f4467a4f41373bc7(s) {\n    var _a, _b;\n    const bounds = s.dom.elements.wrap.getBoundingClientRect();\n    const container = s.dom.elements.container;\n    const ratio = bounds.height / bounds.width;\n    const width = Math.floor(bounds.width * window.devicePixelRatio / 8) * 8 / window.devicePixelRatio;\n    const height = width * ratio;\n    container.style.width = width + 'px';\n    container.style.height = height + 'px';\n    s.dom.bounds.clear();\n    (_a = s.addDimensionsCssVarsTo) === null || _a === void 0 || _a.style.setProperty('---cg-width', width + 'px');\n    (_b = s.addDimensionsCssVarsTo) === null || _b === void 0 || _b.style.setProperty('---cg-height', height + 'px');\n}\nconst $4bb5156c5d36bd23$var$isPieceNode = (el)=>el.tagName === 'PIECE';\nconst $4bb5156c5d36bd23$var$isSquareNode = (el)=>el.tagName === 'SQUARE';\nfunction $4bb5156c5d36bd23$var$removeNodes(s, nodes) {\n    for (const node of nodes)s.dom.elements.board.removeChild(node);\n}\nfunction $4bb5156c5d36bd23$var$posZIndex(pos, asWhite) {\n    const minZ = 3;\n    const rank = pos[1];\n    const z = asWhite ? minZ + 7 - rank : minZ + rank;\n    return `${z}`;\n}\nconst $4bb5156c5d36bd23$var$pieceNameOf = (piece)=>`${piece.color} ${piece.role}`;\nfunction $4bb5156c5d36bd23$var$computeSquareClasses(s) {\n    var _a, _b, _c;\n    const squares = new Map();\n    if (s.lastMove && s.highlight.lastMove) for (const k of s.lastMove)$4bb5156c5d36bd23$var$addSquare(squares, k, 'last-move');\n    if (s.check && s.highlight.check) $4bb5156c5d36bd23$var$addSquare(squares, s.check, 'check');\n    if (s.selected) {\n        $4bb5156c5d36bd23$var$addSquare(squares, s.selected, 'selected');\n        if (s.movable.showDests) {\n            const dests = (_a = s.movable.dests) === null || _a === void 0 ? void 0 : _a.get(s.selected);\n            if (dests) for (const k of dests)$4bb5156c5d36bd23$var$addSquare(squares, k, 'move-dest' + (s.pieces.has(k) ? ' oc' : ''));\n            const pDests = (_c = (_b = s.premovable.customDests) === null || _b === void 0 ? void 0 : _b.get(s.selected)) !== null && _c !== void 0 ? _c : s.premovable.dests;\n            if (pDests) for (const k of pDests)$4bb5156c5d36bd23$var$addSquare(squares, k, 'premove-dest' + (s.pieces.has(k) ? ' oc' : ''));\n        }\n    }\n    const premove = s.premovable.current;\n    if (premove) for (const k of premove)$4bb5156c5d36bd23$var$addSquare(squares, k, 'current-premove');\n    else if (s.predroppable.current) $4bb5156c5d36bd23$var$addSquare(squares, s.predroppable.current.key, 'current-premove');\n    const o = s.exploding;\n    if (o) for (const k of o.keys)$4bb5156c5d36bd23$var$addSquare(squares, k, 'exploding' + o.stage);\n    if (s.highlight.custom) s.highlight.custom.forEach((v, k)=>{\n        $4bb5156c5d36bd23$var$addSquare(squares, k, v);\n    });\n    return squares;\n}\nfunction $4bb5156c5d36bd23$var$addSquare(squares, key, klass) {\n    const classes = squares.get(key);\n    if (classes) squares.set(key, `${classes} ${klass}`);\n    else squares.set(key, klass);\n}\nfunction $4bb5156c5d36bd23$var$appendValue(map, key, value) {\n    const arr = map.get(key);\n    if (arr) arr.push(value);\n    else map.set(key, [\n        value\n    ]);\n}\n\n\n\n\n// append and remove only. No updates.\nfunction $c18d677238327433$export$eb48cb918245ce33(shapes, root, renderShape) {\n    const hashesInDom = new Map(), toRemove = [];\n    for (const sc of shapes)hashesInDom.set(sc.hash, false);\n    let el = root.firstElementChild, elHash;\n    while(el){\n        elHash = el.getAttribute('cgHash');\n        // found a shape element that's here to stay\n        if (hashesInDom.has(elHash)) hashesInDom.set(elHash, true);\n        else toRemove.push(el);\n        el = el.nextElementSibling;\n    }\n    // remove old shapes\n    for (const el of toRemove)root.removeChild(el);\n    // insert shapes that are not yet in dom\n    for (const sc of shapes)if (!hashesInDom.get(sc.hash)) root.appendChild(renderShape(sc));\n}\n\n\nfunction $54757388b7ad83d3$export$b3890eb0ae9dca99(state, autoPieceEl) {\n    const autoPieces = state.drawable.autoShapes.filter((autoShape)=>autoShape.piece);\n    const autoPieceShapes = autoPieces.map((s)=>{\n        return {\n            shape: s,\n            hash: $54757388b7ad83d3$var$hash(s),\n            current: false\n        };\n    });\n    (0, $c18d677238327433$export$eb48cb918245ce33)(autoPieceShapes, autoPieceEl, (shape)=>$54757388b7ad83d3$var$renderShape(state, shape, state.dom.bounds()));\n}\nfunction $54757388b7ad83d3$export$d62f185fd39aa98c(state) {\n    var _a;\n    const asWhite = (0, $e9a4281a8a1ce8a6$export$970133fdf67d86cb)(state), posToTranslate = (0, $12cc5d8f1c8e91f5$export$2135ad75550a2ff4)(state.dom.bounds());\n    let el = (_a = state.dom.elements.autoPieces) === null || _a === void 0 ? void 0 : _a.firstChild;\n    while(el){\n        (0, $12cc5d8f1c8e91f5$export$f8afaca97e230dc6)(el, posToTranslate((0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(el.cgKey), asWhite), el.cgScale);\n        el = el.nextSibling;\n    }\n}\nfunction $54757388b7ad83d3$var$renderShape(state, { shape: shape, hash: hash }, bounds) {\n    var _a, _b, _c;\n    const orig = shape.orig;\n    const role = (_a = shape.piece) === null || _a === void 0 ? void 0 : _a.role;\n    const color = (_b = shape.piece) === null || _b === void 0 ? void 0 : _b.color;\n    const scale = (_c = shape.piece) === null || _c === void 0 ? void 0 : _c.scale;\n    const pieceEl = (0, $12cc5d8f1c8e91f5$export$3d7cd8ed57263b30)('piece', `${role} ${color}`);\n    pieceEl.setAttribute('cgHash', hash);\n    pieceEl.cgKey = orig;\n    pieceEl.cgScale = scale;\n    (0, $12cc5d8f1c8e91f5$export$f8afaca97e230dc6)(pieceEl, (0, $12cc5d8f1c8e91f5$export$2135ad75550a2ff4)(bounds)((0, $12cc5d8f1c8e91f5$export$e2878eba51f22d11)(orig), (0, $e9a4281a8a1ce8a6$export$970133fdf67d86cb)(state)), scale);\n    return pieceEl;\n}\nconst $54757388b7ad83d3$var$hash = (autoPiece)=>{\n    var _a, _b, _c;\n    return [\n        autoPiece.orig,\n        (_a = autoPiece.piece) === null || _a === void 0 ? void 0 : _a.role,\n        (_b = autoPiece.piece) === null || _b === void 0 ? void 0 : _b.color,\n        (_c = autoPiece.piece) === null || _c === void 0 ? void 0 : _c.scale\n    ].join(',');\n};\n\n\n\n\nfunction $2aa9598c5189a81d$export$7e59435764664c61({ el: el, config: config }) {\n    return $2aa9598c5189a81d$export$6aaf0e4db08ad996(el, config);\n}\nfunction $2aa9598c5189a81d$export$6aaf0e4db08ad996(element, config) {\n    const maybeState = (0, $d4a94fd97ea0b308$export$ebe90cb607ad99e)();\n    (0, $f210fdc398bed13f$export$8d21e34596265fa2)(maybeState, config || {});\n    function redrawAll() {\n        const prevUnbind = 'dom' in maybeState ? maybeState.dom.unbind : undefined;\n        // compute bounds from existing board element if possible\n        // this allows non-square boards from CSS to be handled (for 3D)\n        const elements = (0, $2dd2d8dceeead3a2$export$79188534738a92bf)(element, maybeState), bounds = $12cc5d8f1c8e91f5$export$7c73462e0d25e514(()=>elements.board.getBoundingClientRect()), redrawNow = (skipSvg)=>{\n            (0, $4bb5156c5d36bd23$export$b3890eb0ae9dca99)(state);\n            if (elements.autoPieces) $54757388b7ad83d3$export$b3890eb0ae9dca99(state, elements.autoPieces);\n            if (!skipSvg && elements.svg) $c530a7760a946b4a$export$fb80b1b7d7777ee5(state, elements.svg, elements.customSvg);\n        }, onResize = ()=>{\n            (0, $4bb5156c5d36bd23$export$f4467a4f41373bc7)(state);\n            (0, $4bb5156c5d36bd23$export$d62f185fd39aa98c)(state);\n            if (elements.autoPieces) $54757388b7ad83d3$export$d62f185fd39aa98c(state);\n        };\n        const state = maybeState;\n        state.dom = {\n            elements: elements,\n            bounds: bounds,\n            redraw: $2aa9598c5189a81d$var$debounceRedraw(redrawNow),\n            redrawNow: redrawNow,\n            unbind: prevUnbind\n        };\n        state.drawable.prevSvgHash = '';\n        (0, $4bb5156c5d36bd23$export$f4467a4f41373bc7)(state);\n        redrawNow(false);\n        $bb9a2d6168a64a48$export$fc48d2ed06541843(state, onResize);\n        if (!prevUnbind) state.dom.unbind = $bb9a2d6168a64a48$export$fdc77453278b0fa9(state, onResize);\n        state.events.insert && state.events.insert(elements);\n        return state;\n    }\n    return (0, $d1846fb327d0a4d8$export$b3571188c770cc5a)(redrawAll(), redrawAll);\n}\nfunction $2aa9598c5189a81d$var$debounceRedraw(redrawNow) {\n    let redrawing = false;\n    return ()=>{\n        if (redrawing) return;\n        redrawing = true;\n        requestAnimationFrame(()=>{\n            redrawNow();\n            redrawing = false;\n        });\n    };\n}\n\n\n\nconst $1625af68404aac73$var$heuristicEvaluation = (chess)=>{\n    return {\n        value: [\n            ...chess.board[\"white\"]\n        ].flatMap((from)=>[\n                ...chess.dests(from, chess.ctx())\n            ].map((to)=>({\n                    from: from,\n                    to: to\n                }))).length - [\n            ...chess.board[\"black\"]\n        ].flatMap((from)=>[\n                ...chess.dests(from, chess.ctx())\n            ].map((to)=>({\n                    from: from,\n                    to: to\n                }))).length,\n        certain: false\n    };\n};\n// Maximises result on our turn, but minimises it on opponent's turn\nconst $1625af68404aac73$var$minMaxValueComparator = (a, b, shouldMaximise = true // should this sorter try to maximise or minimise the result\n)=>{\n    // Invert result if we want the minimizer\n    return (b.value - a.value) * (shouldMaximise ? 1 : -1);\n};\nconst $1625af68404aac73$var$evaluateState = (chess, recursiveLimit)=>{\n    if (chess.isStalemate()) // A tie is worth nothing!\n    return {\n        value: 0,\n        certain: true\n    };\n    if (chess.isCheckmate()) // TODO not clear if this condition is the right way around\n    return {\n        value: chess.turn === \"white\" ? -1 : 1,\n        certain: true\n    };\n    if (recursiveLimit === 0) return $1625af68404aac73$var$heuristicEvaluation(chess);\n    const allMoves = [\n        ...chess.board[chess.turn]\n    ].flatMap((from)=>[\n            ...chess.dests(from, chess.ctx())\n        ].map((to)=>({\n                from: from,\n                to: to\n            })));\n    const rankedFutureStates = allMoves.map((move)=>{\n        const clone = chess.clone();\n        clone.play(move);\n        return $1625af68404aac73$var$memoEvaluateStateForPlayer(clone, recursiveLimit - 1);\n    }).sort((a, b)=>$1625af68404aac73$var$minMaxValueComparator(a, b, chess.turn === \"white\"));\n    const bestFutureState = rankedFutureStates[0];\n    return {\n        value: bestFutureState.value,\n        certain: bestFutureState.certain\n    };\n};\nconst $1625af68404aac73$var$memoedEvaluations = {};\nconst $1625af68404aac73$var$memoEvaluateStateForPlayer = (state, recursiveLimit = 2)=>{\n    const memoKey = (0, $9d83a5ecbd86440e$exports).makeBoardFen(state.board);\n    if ($1625af68404aac73$var$memoedEvaluations[memoKey]) return $1625af68404aac73$var$memoedEvaluations[memoKey];\n    const realEvaluation = $1625af68404aac73$var$evaluateState(state, recursiveLimit);\n    if (realEvaluation.certain) $1625af68404aac73$var$memoedEvaluations[memoKey] = realEvaluation;\n    return realEvaluation;\n};\nconst $1625af68404aac73$export$295d986d08d83031 = (chess)=>{\n    // Get the set of all legal moves\n    const allMoves = [\n        ...chess.board[chess.turn]\n    ].flatMap((from)=>[\n            ...chess.dests(from, chess.ctx())\n        ].map((to)=>({\n                from: from,\n                to: to\n            })));\n    // Evaluate the state each move would yield\n    const rankedMoves = allMoves.map((move)=>{\n        const clone = chess.clone();\n        clone.play(move);\n        return {\n            move: move,\n            evaluation: $1625af68404aac73$var$memoEvaluateStateForPlayer(clone)\n        };\n    }).sort((a, b)=>$1625af68404aac73$var$minMaxValueComparator(a.evaluation, b.evaluation, chess.turn === \"white\"));\n    // pick randomly from equal best\n    const bestMove = rankedMoves[0];\n    const equalBestMoves = rankedMoves.filter(({ evaluation: evaluation })=>evaluation.value === bestMove.evaluation.value).map(({ move: move })=>move);\n    const randomBestMove = equalBestMoves[Math.floor(Math.random() * equalBestMoves.length)];\n    return randomBestMove;\n};\n\n\nconst $253ce2a319769a4a$var$toPlayDisplay = document.querySelector(\"#to-play\");\nconst $253ce2a319769a4a$var$fenForm = document.querySelector(\"#fen-form\");\nconst $253ce2a319769a4a$var$fenInput = document.querySelector(\"#fen\");\nconst $253ce2a319769a4a$var$bestMoveDisplay = document.querySelector(\"#best-move\");\n// Stateful chess\nlet $253ce2a319769a4a$var$chess = (0, $9c49db522b46d242$export$a4d6ea685c300d39).default();\n// Chess UI\nconst $253ce2a319769a4a$var$board = (0, $2aa9598c5189a81d$export$6aaf0e4db08ad996)(document.querySelector(\"#board\"), {\n    highlight: {\n        lastMove: false\n    },\n    movable: {\n        events: {\n            after: (from, to)=>{\n                const move = {\n                    from: (0, $ced645034f45bdd3$export$c6ba26669b4144a1)(from),\n                    to: (0, $ced645034f45bdd3$export$c6ba26669b4144a1)(to)\n                };\n                if ($253ce2a319769a4a$var$chess.isLegal(move)) $253ce2a319769a4a$var$chess.play(move);\n                else if ($253ce2a319769a4a$var$chess.isLegal({\n                    ...move,\n                    promotion: \"queen\"\n                })) $253ce2a319769a4a$var$chess.play({\n                    ...move,\n                    promotion: \"queen\"\n                });\n                $253ce2a319769a4a$var$board.set({\n                    fen: (0, $9d83a5ecbd86440e$exports).makeBoardFen($253ce2a319769a4a$var$chess.board)\n                });\n                $253ce2a319769a4a$var$toPlayDisplay.textContent = `${$253ce2a319769a4a$var$chess.turn} to play`;\n                $253ce2a319769a4a$var$bestMoveDisplay.textContent = `Best move: ${(0, $ced645034f45bdd3$export$7557b324d9d37023)((0, $1625af68404aac73$export$295d986d08d83031)($253ce2a319769a4a$var$chess.clone()))}`;\n            }\n        }\n    }\n});\n$253ce2a319769a4a$var$fenForm.addEventListener(\"submit\", (event)=>{\n    event.preventDefault();\n    const pgnInputValue = $253ce2a319769a4a$var$fenInput.value;\n    if (!pgnInputValue) return;\n    try {\n        const setup = (0, $9d83a5ecbd86440e$exports).parseFen($253ce2a319769a4a$var$fenInput.value).unwrap();\n        const pos = (0, $9c49db522b46d242$export$a4d6ea685c300d39).fromSetup(setup).unwrap();\n        $253ce2a319769a4a$var$chess = pos;\n        $253ce2a319769a4a$var$board.set({\n            fen: (0, $9d83a5ecbd86440e$exports).makeBoardFen($253ce2a319769a4a$var$chess.board)\n        });\n        $253ce2a319769a4a$var$toPlayDisplay.textContent = `${$253ce2a319769a4a$var$chess.turn} to play`;\n        $253ce2a319769a4a$var$bestMoveDisplay.textContent = `Best move: ${(0, $ced645034f45bdd3$export$7557b324d9d37023)((0, $1625af68404aac73$export$295d986d08d83031)($253ce2a319769a4a$var$chess))}`;\n    } catch (error) {\n        console.error(error);\n    }\n    // Clear the input after submission\n    $253ce2a319769a4a$var$fenInput.value = \"\";\n});\n\n})();\n//# sourceMappingURL=index.082a427f.js.map\n","import { Chess, parseSquare, type Move, fen, makeUci } from \"chessops\";\nimport { Chessground } from \"chessground\";\n\nimport { pickBestMove } from \"./movePicker\";\n\nconst toPlayDisplay = document.querySelector<HTMLSpanElement>(\"#to-play\")!;\n\nconst fenForm = document.querySelector<HTMLFormElement>(\"#fen-form\")!;\nconst fenInput = document.querySelector<HTMLInputElement>(\"#fen\")!;\n\nconst bestMoveDisplay = document.querySelector<HTMLSpanElement>(\"#best-move\")!;\n\n// Stateful chess\nlet chess = Chess.default();\n\n// Chess UI\nconst board = Chessground(document.querySelector<HTMLDivElement>(\"#board\")!, {\n  highlight: {\n    lastMove: false,\n  },\n  movable: {\n    events: {\n      after: (from, to) => {\n        const move: Move = {\n          from: parseSquare(from)!,\n          to: parseSquare(to)!,\n        };\n\n        if (chess.isLegal(move)) chess.play(move);\n        // This is a hack to force queen promotion\n        // We can't add it in the previous 'if', because then it would be treated as an illegal move\n        else if (chess.isLegal({ ...move, promotion: \"queen\" }))\n          chess.play({ ...move, promotion: \"queen\" });\n        board.set({ fen: fen.makeBoardFen(chess.board) });\n        toPlayDisplay.textContent = `${chess.turn} to play`;\n        bestMoveDisplay.textContent = `Best move: ${makeUci(\n          pickBestMove(chess.clone())\n        )}`;\n      },\n    },\n  },\n});\n\nfenForm.addEventListener(\"submit\", (event) => {\n  event.preventDefault();\n  const pgnInputValue = fenInput.value;\n  if (!pgnInputValue) return;\n\n  try {\n    const setup = fen.parseFen(fenInput.value).unwrap();\n    const pos = Chess.fromSetup(setup).unwrap();\n    chess = pos;\n\n    board.set({ fen: fen.makeBoardFen(chess.board) });\n    toPlayDisplay.textContent = `${chess.turn} to play`;\n    bestMoveDisplay.textContent = `Best move: ${makeUci(pickBestMove(chess))}`;\n  } catch (error) {\n    console.error(error);\n  }\n\n  // Clear the input after submission\n  fenInput.value = \"\";\n});\n","import { Result } from '@badrap/result';\nimport { attacks, between, bishopAttacks, kingAttacks, knightAttacks, pawnAttacks, queenAttacks, ray, rookAttacks, } from './attacks.js';\nimport { Board, boardEquals } from './board.js';\nimport { SquareSet } from './squareSet.js';\nimport { CASTLING_SIDES, COLORS, isDrop, } from './types.js';\nimport { defined, kingCastlesTo, opposite, rookCastlesTo, squareRank } from './util.js';\nexport var IllegalSetup;\n(function (IllegalSetup) {\n    IllegalSetup[\"Empty\"] = \"ERR_EMPTY\";\n    IllegalSetup[\"OppositeCheck\"] = \"ERR_OPPOSITE_CHECK\";\n    IllegalSetup[\"PawnsOnBackrank\"] = \"ERR_PAWNS_ON_BACKRANK\";\n    IllegalSetup[\"Kings\"] = \"ERR_KINGS\";\n    IllegalSetup[\"Variant\"] = \"ERR_VARIANT\";\n})(IllegalSetup || (IllegalSetup = {}));\nexport class PositionError extends Error {\n}\nconst attacksTo = (square, attacker, board, occupied) => board[attacker].intersect(rookAttacks(square, occupied)\n    .intersect(board.rooksAndQueens())\n    .union(bishopAttacks(square, occupied).intersect(board.bishopsAndQueens()))\n    .union(knightAttacks(square).intersect(board.knight))\n    .union(kingAttacks(square).intersect(board.king))\n    .union(pawnAttacks(opposite(attacker), square).intersect(board.pawn)));\nexport class Castles {\n    constructor() { }\n    static default() {\n        const castles = new Castles();\n        castles.castlingRights = SquareSet.corners();\n        castles.rook = {\n            white: { a: 0, h: 7 },\n            black: { a: 56, h: 63 },\n        };\n        castles.path = {\n            white: { a: new SquareSet(0xe, 0), h: new SquareSet(0x60, 0) },\n            black: { a: new SquareSet(0, 0x0e000000), h: new SquareSet(0, 0x60000000) },\n        };\n        return castles;\n    }\n    static empty() {\n        const castles = new Castles();\n        castles.castlingRights = SquareSet.empty();\n        castles.rook = {\n            white: { a: undefined, h: undefined },\n            black: { a: undefined, h: undefined },\n        };\n        castles.path = {\n            white: { a: SquareSet.empty(), h: SquareSet.empty() },\n            black: { a: SquareSet.empty(), h: SquareSet.empty() },\n        };\n        return castles;\n    }\n    clone() {\n        const castles = new Castles();\n        castles.castlingRights = this.castlingRights;\n        castles.rook = {\n            white: { a: this.rook.white.a, h: this.rook.white.h },\n            black: { a: this.rook.black.a, h: this.rook.black.h },\n        };\n        castles.path = {\n            white: { a: this.path.white.a, h: this.path.white.h },\n            black: { a: this.path.black.a, h: this.path.black.h },\n        };\n        return castles;\n    }\n    add(color, side, king, rook) {\n        const kingTo = kingCastlesTo(color, side);\n        const rookTo = rookCastlesTo(color, side);\n        this.castlingRights = this.castlingRights.with(rook);\n        this.rook[color][side] = rook;\n        this.path[color][side] = between(rook, rookTo)\n            .with(rookTo)\n            .union(between(king, kingTo).with(kingTo))\n            .without(king)\n            .without(rook);\n    }\n    static fromSetup(setup) {\n        const castles = Castles.empty();\n        const rooks = setup.castlingRights.intersect(setup.board.rook);\n        for (const color of COLORS) {\n            const backrank = SquareSet.backrank(color);\n            const king = setup.board.kingOf(color);\n            if (!defined(king) || !backrank.has(king))\n                continue;\n            const side = rooks.intersect(setup.board[color]).intersect(backrank);\n            const aSide = side.first();\n            if (defined(aSide) && aSide < king)\n                castles.add(color, 'a', king, aSide);\n            const hSide = side.last();\n            if (defined(hSide) && king < hSide)\n                castles.add(color, 'h', king, hSide);\n        }\n        return castles;\n    }\n    discardRook(square) {\n        if (this.castlingRights.has(square)) {\n            this.castlingRights = this.castlingRights.without(square);\n            for (const color of COLORS) {\n                for (const side of CASTLING_SIDES) {\n                    if (this.rook[color][side] === square)\n                        this.rook[color][side] = undefined;\n                }\n            }\n        }\n    }\n    discardColor(color) {\n        this.castlingRights = this.castlingRights.diff(SquareSet.backrank(color));\n        this.rook[color].a = undefined;\n        this.rook[color].h = undefined;\n    }\n}\nexport class Position {\n    constructor(rules) {\n        this.rules = rules;\n    }\n    reset() {\n        this.board = Board.default();\n        this.pockets = undefined;\n        this.turn = 'white';\n        this.castles = Castles.default();\n        this.epSquare = undefined;\n        this.remainingChecks = undefined;\n        this.halfmoves = 0;\n        this.fullmoves = 1;\n    }\n    setupUnchecked(setup) {\n        this.board = setup.board.clone();\n        this.board.promoted = SquareSet.empty();\n        this.pockets = undefined;\n        this.turn = setup.turn;\n        this.castles = Castles.fromSetup(setup);\n        this.epSquare = validEpSquare(this, setup.epSquare);\n        this.remainingChecks = undefined;\n        this.halfmoves = setup.halfmoves;\n        this.fullmoves = setup.fullmoves;\n    }\n    // When subclassing overwrite at least:\n    //\n    // - static default()\n    // - static fromSetup()\n    // - static clone()\n    //\n    // - dests()\n    // - isVariantEnd()\n    // - variantOutcome()\n    // - hasInsufficientMaterial()\n    // - isStandardMaterial()\n    kingAttackers(square, attacker, occupied) {\n        return attacksTo(square, attacker, this.board, occupied);\n    }\n    playCaptureAt(square, captured) {\n        this.halfmoves = 0;\n        if (captured.role === 'rook')\n            this.castles.discardRook(square);\n        if (this.pockets)\n            this.pockets[opposite(captured.color)][captured.promoted ? 'pawn' : captured.role]++;\n    }\n    ctx() {\n        const variantEnd = this.isVariantEnd();\n        const king = this.board.kingOf(this.turn);\n        if (!defined(king)) {\n            return { king, blockers: SquareSet.empty(), checkers: SquareSet.empty(), variantEnd, mustCapture: false };\n        }\n        const snipers = rookAttacks(king, SquareSet.empty())\n            .intersect(this.board.rooksAndQueens())\n            .union(bishopAttacks(king, SquareSet.empty()).intersect(this.board.bishopsAndQueens()))\n            .intersect(this.board[opposite(this.turn)]);\n        let blockers = SquareSet.empty();\n        for (const sniper of snipers) {\n            const b = between(king, sniper).intersect(this.board.occupied);\n            if (!b.moreThanOne())\n                blockers = blockers.union(b);\n        }\n        const checkers = this.kingAttackers(king, opposite(this.turn), this.board.occupied);\n        return {\n            king,\n            blockers,\n            checkers,\n            variantEnd,\n            mustCapture: false,\n        };\n    }\n    clone() {\n        var _a, _b;\n        const pos = new this.constructor();\n        pos.board = this.board.clone();\n        pos.pockets = (_a = this.pockets) === null || _a === void 0 ? void 0 : _a.clone();\n        pos.turn = this.turn;\n        pos.castles = this.castles.clone();\n        pos.epSquare = this.epSquare;\n        pos.remainingChecks = (_b = this.remainingChecks) === null || _b === void 0 ? void 0 : _b.clone();\n        pos.halfmoves = this.halfmoves;\n        pos.fullmoves = this.fullmoves;\n        return pos;\n    }\n    validate() {\n        if (this.board.occupied.isEmpty())\n            return Result.err(new PositionError(IllegalSetup.Empty));\n        if (this.board.king.size() !== 2)\n            return Result.err(new PositionError(IllegalSetup.Kings));\n        if (!defined(this.board.kingOf(this.turn)))\n            return Result.err(new PositionError(IllegalSetup.Kings));\n        const otherKing = this.board.kingOf(opposite(this.turn));\n        if (!defined(otherKing))\n            return Result.err(new PositionError(IllegalSetup.Kings));\n        if (this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty()) {\n            return Result.err(new PositionError(IllegalSetup.OppositeCheck));\n        }\n        if (SquareSet.backranks().intersects(this.board.pawn)) {\n            return Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));\n        }\n        return Result.ok(undefined);\n    }\n    dropDests(_ctx) {\n        return SquareSet.empty();\n    }\n    dests(square, ctx) {\n        ctx = ctx || this.ctx();\n        if (ctx.variantEnd)\n            return SquareSet.empty();\n        const piece = this.board.get(square);\n        if (!piece || piece.color !== this.turn)\n            return SquareSet.empty();\n        let pseudo, legal;\n        if (piece.role === 'pawn') {\n            pseudo = pawnAttacks(this.turn, square).intersect(this.board[opposite(this.turn)]);\n            const delta = this.turn === 'white' ? 8 : -8;\n            const step = square + delta;\n            if (0 <= step && step < 64 && !this.board.occupied.has(step)) {\n                pseudo = pseudo.with(step);\n                const canDoubleStep = this.turn === 'white' ? square < 16 : square >= 64 - 16;\n                const doubleStep = step + delta;\n                if (canDoubleStep && !this.board.occupied.has(doubleStep)) {\n                    pseudo = pseudo.with(doubleStep);\n                }\n            }\n            if (defined(this.epSquare) && canCaptureEp(this, square, ctx)) {\n                legal = SquareSet.fromSquare(this.epSquare);\n            }\n        }\n        else if (piece.role === 'bishop')\n            pseudo = bishopAttacks(square, this.board.occupied);\n        else if (piece.role === 'knight')\n            pseudo = knightAttacks(square);\n        else if (piece.role === 'rook')\n            pseudo = rookAttacks(square, this.board.occupied);\n        else if (piece.role === 'queen')\n            pseudo = queenAttacks(square, this.board.occupied);\n        else\n            pseudo = kingAttacks(square);\n        pseudo = pseudo.diff(this.board[this.turn]);\n        if (defined(ctx.king)) {\n            if (piece.role === 'king') {\n                const occ = this.board.occupied.without(square);\n                for (const to of pseudo) {\n                    if (this.kingAttackers(to, opposite(this.turn), occ).nonEmpty())\n                        pseudo = pseudo.without(to);\n                }\n                return pseudo.union(castlingDest(this, 'a', ctx)).union(castlingDest(this, 'h', ctx));\n            }\n            if (ctx.checkers.nonEmpty()) {\n                const checker = ctx.checkers.singleSquare();\n                if (!defined(checker))\n                    return SquareSet.empty();\n                pseudo = pseudo.intersect(between(checker, ctx.king).with(checker));\n            }\n            if (ctx.blockers.has(square))\n                pseudo = pseudo.intersect(ray(square, ctx.king));\n        }\n        if (legal)\n            pseudo = pseudo.union(legal);\n        return pseudo;\n    }\n    isVariantEnd() {\n        return false;\n    }\n    variantOutcome(_ctx) {\n        return;\n    }\n    hasInsufficientMaterial(color) {\n        if (this.board[color].intersect(this.board.pawn.union(this.board.rooksAndQueens())).nonEmpty())\n            return false;\n        if (this.board[color].intersects(this.board.knight)) {\n            return (this.board[color].size() <= 2\n                && this.board[opposite(color)].diff(this.board.king).diff(this.board.queen).isEmpty());\n        }\n        if (this.board[color].intersects(this.board.bishop)) {\n            const sameColor = !this.board.bishop.intersects(SquareSet.darkSquares())\n                || !this.board.bishop.intersects(SquareSet.lightSquares());\n            return sameColor && this.board.pawn.isEmpty() && this.board.knight.isEmpty();\n        }\n        return true;\n    }\n    // The following should be identical in all subclasses\n    toSetup() {\n        var _a, _b;\n        return {\n            board: this.board.clone(),\n            pockets: (_a = this.pockets) === null || _a === void 0 ? void 0 : _a.clone(),\n            turn: this.turn,\n            castlingRights: this.castles.castlingRights,\n            epSquare: legalEpSquare(this),\n            remainingChecks: (_b = this.remainingChecks) === null || _b === void 0 ? void 0 : _b.clone(),\n            halfmoves: Math.min(this.halfmoves, 150),\n            fullmoves: Math.min(Math.max(this.fullmoves, 1), 9999),\n        };\n    }\n    isInsufficientMaterial() {\n        return COLORS.every(color => this.hasInsufficientMaterial(color));\n    }\n    hasDests(ctx) {\n        ctx = ctx || this.ctx();\n        for (const square of this.board[this.turn]) {\n            if (this.dests(square, ctx).nonEmpty())\n                return true;\n        }\n        return this.dropDests(ctx).nonEmpty();\n    }\n    isLegal(move, ctx) {\n        if (isDrop(move)) {\n            if (!this.pockets || this.pockets[this.turn][move.role] <= 0)\n                return false;\n            if (move.role === 'pawn' && SquareSet.backranks().has(move.to))\n                return false;\n            return this.dropDests(ctx).has(move.to);\n        }\n        else {\n            if (move.promotion === 'pawn')\n                return false;\n            if (move.promotion === 'king' && this.rules !== 'antichess')\n                return false;\n            if (!!move.promotion !== (this.board.pawn.has(move.from) && SquareSet.backranks().has(move.to)))\n                return false;\n            const dests = this.dests(move.from, ctx);\n            return dests.has(move.to) || dests.has(normalizeMove(this, move).to);\n        }\n    }\n    isCheck() {\n        const king = this.board.kingOf(this.turn);\n        return defined(king) && this.kingAttackers(king, opposite(this.turn), this.board.occupied).nonEmpty();\n    }\n    isEnd(ctx) {\n        if (ctx ? ctx.variantEnd : this.isVariantEnd())\n            return true;\n        return this.isInsufficientMaterial() || !this.hasDests(ctx);\n    }\n    isCheckmate(ctx) {\n        ctx = ctx || this.ctx();\n        return !ctx.variantEnd && ctx.checkers.nonEmpty() && !this.hasDests(ctx);\n    }\n    isStalemate(ctx) {\n        ctx = ctx || this.ctx();\n        return !ctx.variantEnd && ctx.checkers.isEmpty() && !this.hasDests(ctx);\n    }\n    outcome(ctx) {\n        const variantOutcome = this.variantOutcome(ctx);\n        if (variantOutcome)\n            return variantOutcome;\n        ctx = ctx || this.ctx();\n        if (this.isCheckmate(ctx))\n            return { winner: opposite(this.turn) };\n        else if (this.isInsufficientMaterial() || this.isStalemate(ctx))\n            return { winner: undefined };\n        else\n            return;\n    }\n    allDests(ctx) {\n        ctx = ctx || this.ctx();\n        const d = new Map();\n        if (ctx.variantEnd)\n            return d;\n        for (const square of this.board[this.turn]) {\n            d.set(square, this.dests(square, ctx));\n        }\n        return d;\n    }\n    play(move) {\n        const turn = this.turn;\n        const epSquare = this.epSquare;\n        const castling = castlingSide(this, move);\n        this.epSquare = undefined;\n        this.halfmoves += 1;\n        if (turn === 'black')\n            this.fullmoves += 1;\n        this.turn = opposite(turn);\n        if (isDrop(move)) {\n            this.board.set(move.to, { role: move.role, color: turn });\n            if (this.pockets)\n                this.pockets[turn][move.role]--;\n            if (move.role === 'pawn')\n                this.halfmoves = 0;\n        }\n        else {\n            const piece = this.board.take(move.from);\n            if (!piece)\n                return;\n            let epCapture;\n            if (piece.role === 'pawn') {\n                this.halfmoves = 0;\n                if (move.to === epSquare) {\n                    epCapture = this.board.take(move.to + (turn === 'white' ? -8 : 8));\n                }\n                const delta = move.from - move.to;\n                if (Math.abs(delta) === 16 && 8 <= move.from && move.from <= 55) {\n                    this.epSquare = (move.from + move.to) >> 1;\n                }\n                if (move.promotion) {\n                    piece.role = move.promotion;\n                    piece.promoted = !!this.pockets;\n                }\n            }\n            else if (piece.role === 'rook') {\n                this.castles.discardRook(move.from);\n            }\n            else if (piece.role === 'king') {\n                if (castling) {\n                    const rookFrom = this.castles.rook[turn][castling];\n                    if (defined(rookFrom)) {\n                        const rook = this.board.take(rookFrom);\n                        this.board.set(kingCastlesTo(turn, castling), piece);\n                        if (rook)\n                            this.board.set(rookCastlesTo(turn, castling), rook);\n                    }\n                }\n                this.castles.discardColor(turn);\n            }\n            if (!castling) {\n                const capture = this.board.set(move.to, piece) || epCapture;\n                if (capture)\n                    this.playCaptureAt(move.to, capture);\n            }\n        }\n        if (this.remainingChecks) {\n            if (this.isCheck())\n                this.remainingChecks[turn] = Math.max(this.remainingChecks[turn] - 1, 0);\n        }\n    }\n}\nexport class Chess extends Position {\n    constructor() {\n        super('chess');\n    }\n    static default() {\n        const pos = new this();\n        pos.reset();\n        return pos;\n    }\n    static fromSetup(setup) {\n        const pos = new this();\n        pos.setupUnchecked(setup);\n        return pos.validate().map(_ => pos);\n    }\n    clone() {\n        return super.clone();\n    }\n}\nconst validEpSquare = (pos, square) => {\n    if (!defined(square))\n        return;\n    const epRank = pos.turn === 'white' ? 5 : 2;\n    const forward = pos.turn === 'white' ? 8 : -8;\n    if (squareRank(square) !== epRank)\n        return;\n    if (pos.board.occupied.has(square + forward))\n        return;\n    const pawn = square - forward;\n    if (!pos.board.pawn.has(pawn) || !pos.board[opposite(pos.turn)].has(pawn))\n        return;\n    return square;\n};\nconst legalEpSquare = (pos) => {\n    if (!defined(pos.epSquare))\n        return;\n    const ctx = pos.ctx();\n    const ourPawns = pos.board.pieces(pos.turn, 'pawn');\n    const candidates = ourPawns.intersect(pawnAttacks(opposite(pos.turn), pos.epSquare));\n    for (const candidate of candidates) {\n        if (pos.dests(candidate, ctx).has(pos.epSquare))\n            return pos.epSquare;\n    }\n    return;\n};\nconst canCaptureEp = (pos, pawnFrom, ctx) => {\n    if (!defined(pos.epSquare))\n        return false;\n    if (!pawnAttacks(pos.turn, pawnFrom).has(pos.epSquare))\n        return false;\n    if (!defined(ctx.king))\n        return true;\n    const delta = pos.turn === 'white' ? 8 : -8;\n    const captured = pos.epSquare - delta;\n    return pos\n        .kingAttackers(ctx.king, opposite(pos.turn), pos.board.occupied.toggle(pawnFrom).toggle(captured).with(pos.epSquare))\n        .without(captured)\n        .isEmpty();\n};\nconst castlingDest = (pos, side, ctx) => {\n    if (!defined(ctx.king) || ctx.checkers.nonEmpty())\n        return SquareSet.empty();\n    const rook = pos.castles.rook[pos.turn][side];\n    if (!defined(rook))\n        return SquareSet.empty();\n    if (pos.castles.path[pos.turn][side].intersects(pos.board.occupied))\n        return SquareSet.empty();\n    const kingTo = kingCastlesTo(pos.turn, side);\n    const kingPath = between(ctx.king, kingTo);\n    const occ = pos.board.occupied.without(ctx.king);\n    for (const sq of kingPath) {\n        if (pos.kingAttackers(sq, opposite(pos.turn), occ).nonEmpty())\n            return SquareSet.empty();\n    }\n    const rookTo = rookCastlesTo(pos.turn, side);\n    const after = pos.board.occupied.toggle(ctx.king).toggle(rook).toggle(rookTo);\n    if (pos.kingAttackers(kingTo, opposite(pos.turn), after).nonEmpty())\n        return SquareSet.empty();\n    return SquareSet.fromSquare(rook);\n};\nexport const pseudoDests = (pos, square, ctx) => {\n    if (ctx.variantEnd)\n        return SquareSet.empty();\n    const piece = pos.board.get(square);\n    if (!piece || piece.color !== pos.turn)\n        return SquareSet.empty();\n    let pseudo = attacks(piece, square, pos.board.occupied);\n    if (piece.role === 'pawn') {\n        let captureTargets = pos.board[opposite(pos.turn)];\n        if (defined(pos.epSquare))\n            captureTargets = captureTargets.with(pos.epSquare);\n        pseudo = pseudo.intersect(captureTargets);\n        const delta = pos.turn === 'white' ? 8 : -8;\n        const step = square + delta;\n        if (0 <= step && step < 64 && !pos.board.occupied.has(step)) {\n            pseudo = pseudo.with(step);\n            const canDoubleStep = pos.turn === 'white' ? square < 16 : square >= 64 - 16;\n            const doubleStep = step + delta;\n            if (canDoubleStep && !pos.board.occupied.has(doubleStep)) {\n                pseudo = pseudo.with(doubleStep);\n            }\n        }\n        return pseudo;\n    }\n    else {\n        pseudo = pseudo.diff(pos.board[pos.turn]);\n    }\n    if (square === ctx.king)\n        return pseudo.union(castlingDest(pos, 'a', ctx)).union(castlingDest(pos, 'h', ctx));\n    else\n        return pseudo;\n};\nexport const equalsIgnoreMoves = (left, right) => {\n    var _a, _b;\n    return left.rules === right.rules\n        && boardEquals(left.board, right.board)\n        && ((right.pockets && ((_a = left.pockets) === null || _a === void 0 ? void 0 : _a.equals(right.pockets))) || (!left.pockets && !right.pockets))\n        && left.turn === right.turn\n        && left.castles.castlingRights.equals(right.castles.castlingRights)\n        && legalEpSquare(left) === legalEpSquare(right)\n        && ((right.remainingChecks && ((_b = left.remainingChecks) === null || _b === void 0 ? void 0 : _b.equals(right.remainingChecks)))\n            || (!left.remainingChecks && !right.remainingChecks));\n};\nexport const castlingSide = (pos, move) => {\n    if (isDrop(move))\n        return;\n    const delta = move.to - move.from;\n    if (Math.abs(delta) !== 2 && !pos.board[pos.turn].has(move.to))\n        return;\n    if (!pos.board.king.has(move.from))\n        return;\n    return delta > 0 ? 'h' : 'a';\n};\nexport const normalizeMove = (pos, move) => {\n    const side = castlingSide(pos, move);\n    if (!side)\n        return move;\n    const rookFrom = pos.castles.rook[pos.turn][side];\n    return {\n        from: move.from,\n        to: defined(rookFrom) ? rookFrom : move.to,\n    };\n};\nexport const isStandardMaterialSide = (board, color) => {\n    const promoted = Math.max(board.pieces(color, 'queen').size() - 1, 0)\n        + Math.max(board.pieces(color, 'rook').size() - 2, 0)\n        + Math.max(board.pieces(color, 'knight').size() - 2, 0)\n        + Math.max(board.pieces(color, 'bishop').intersect(SquareSet.lightSquares()).size() - 1, 0)\n        + Math.max(board.pieces(color, 'bishop').intersect(SquareSet.darkSquares()).size() - 1, 0);\n    return board.pieces(color, 'pawn').size() + promoted <= 8;\n};\nexport const isStandardMaterial = (pos) => COLORS.every(color => isStandardMaterialSide(pos.board, color));\nexport const isImpossibleCheck = (pos) => {\n    const ourKing = pos.board.kingOf(pos.turn);\n    if (!defined(ourKing))\n        return false;\n    const checkers = pos.kingAttackers(ourKing, opposite(pos.turn), pos.board.occupied);\n    if (checkers.isEmpty())\n        return false;\n    if (defined(pos.epSquare)) {\n        // The pushed pawn must be the only checker, or it has uncovered\n        // check by a single sliding piece.\n        const pushedTo = pos.epSquare ^ 8;\n        const pushedFrom = pos.epSquare ^ 24;\n        return (checkers.moreThanOne()\n            || (checkers.first() !== pushedTo\n                && pos\n                    .kingAttackers(ourKing, opposite(pos.turn), pos.board.occupied.without(pushedTo).with(pushedFrom))\n                    .nonEmpty()));\n    }\n    else if (pos.rules === 'atomic') {\n        // Other king moving away can cause many checks to be given at the same\n        // time. Not checking details, or even that the king is close enough.\n        return false;\n    }\n    else {\n        // Sliding checkers aligned with king.\n        return checkers.size() > 2 || (checkers.size() === 2 && ray(checkers.first(), checkers.last()).has(ourKing));\n    }\n};\n//# sourceMappingURL=chess.js.map","import { Result } from '@badrap/result';\nimport {\n  attacks,\n  between,\n  bishopAttacks,\n  kingAttacks,\n  knightAttacks,\n  pawnAttacks,\n  queenAttacks,\n  ray,\n  rookAttacks,\n} from './attacks.js';\nimport { Board, boardEquals } from './board.js';\nimport { Material, RemainingChecks, Setup } from './setup.js';\nimport { SquareSet } from './squareSet.js';\nimport {\n  ByCastlingSide,\n  ByColor,\n  CASTLING_SIDES,\n  CastlingSide,\n  Color,\n  COLORS,\n  isDrop,\n  Move,\n  NormalMove,\n  Outcome,\n  Piece,\n  Rules,\n  Square,\n} from './types.js';\nimport { defined, kingCastlesTo, opposite, rookCastlesTo, squareRank } from './util.js';\n\nexport enum IllegalSetup {\n  Empty = 'ERR_EMPTY',\n  OppositeCheck = 'ERR_OPPOSITE_CHECK',\n  PawnsOnBackrank = 'ERR_PAWNS_ON_BACKRANK',\n  Kings = 'ERR_KINGS',\n  Variant = 'ERR_VARIANT',\n}\n\nexport class PositionError extends Error {}\n\nconst attacksTo = (square: Square, attacker: Color, board: Board, occupied: SquareSet): SquareSet =>\n  board[attacker].intersect(\n    rookAttacks(square, occupied)\n      .intersect(board.rooksAndQueens())\n      .union(bishopAttacks(square, occupied).intersect(board.bishopsAndQueens()))\n      .union(knightAttacks(square).intersect(board.knight))\n      .union(kingAttacks(square).intersect(board.king))\n      .union(pawnAttacks(opposite(attacker), square).intersect(board.pawn)),\n  );\n\nexport class Castles {\n  castlingRights: SquareSet;\n  rook: ByColor<ByCastlingSide<Square | undefined>>;\n  path: ByColor<ByCastlingSide<SquareSet>>;\n\n  private constructor() {}\n\n  static default(): Castles {\n    const castles = new Castles();\n    castles.castlingRights = SquareSet.corners();\n    castles.rook = {\n      white: { a: 0, h: 7 },\n      black: { a: 56, h: 63 },\n    };\n    castles.path = {\n      white: { a: new SquareSet(0xe, 0), h: new SquareSet(0x60, 0) },\n      black: { a: new SquareSet(0, 0x0e000000), h: new SquareSet(0, 0x60000000) },\n    };\n    return castles;\n  }\n\n  static empty(): Castles {\n    const castles = new Castles();\n    castles.castlingRights = SquareSet.empty();\n    castles.rook = {\n      white: { a: undefined, h: undefined },\n      black: { a: undefined, h: undefined },\n    };\n    castles.path = {\n      white: { a: SquareSet.empty(), h: SquareSet.empty() },\n      black: { a: SquareSet.empty(), h: SquareSet.empty() },\n    };\n    return castles;\n  }\n\n  clone(): Castles {\n    const castles = new Castles();\n    castles.castlingRights = this.castlingRights;\n    castles.rook = {\n      white: { a: this.rook.white.a, h: this.rook.white.h },\n      black: { a: this.rook.black.a, h: this.rook.black.h },\n    };\n    castles.path = {\n      white: { a: this.path.white.a, h: this.path.white.h },\n      black: { a: this.path.black.a, h: this.path.black.h },\n    };\n    return castles;\n  }\n\n  private add(color: Color, side: CastlingSide, king: Square, rook: Square): void {\n    const kingTo = kingCastlesTo(color, side);\n    const rookTo = rookCastlesTo(color, side);\n    this.castlingRights = this.castlingRights.with(rook);\n    this.rook[color][side] = rook;\n    this.path[color][side] = between(rook, rookTo)\n      .with(rookTo)\n      .union(between(king, kingTo).with(kingTo))\n      .without(king)\n      .without(rook);\n  }\n\n  static fromSetup(setup: Setup): Castles {\n    const castles = Castles.empty();\n    const rooks = setup.castlingRights.intersect(setup.board.rook);\n    for (const color of COLORS) {\n      const backrank = SquareSet.backrank(color);\n      const king = setup.board.kingOf(color);\n      if (!defined(king) || !backrank.has(king)) continue;\n      const side = rooks.intersect(setup.board[color]).intersect(backrank);\n      const aSide = side.first();\n      if (defined(aSide) && aSide < king) castles.add(color, 'a', king, aSide);\n      const hSide = side.last();\n      if (defined(hSide) && king < hSide) castles.add(color, 'h', king, hSide);\n    }\n    return castles;\n  }\n\n  discardRook(square: Square): void {\n    if (this.castlingRights.has(square)) {\n      this.castlingRights = this.castlingRights.without(square);\n      for (const color of COLORS) {\n        for (const side of CASTLING_SIDES) {\n          if (this.rook[color][side] === square) this.rook[color][side] = undefined;\n        }\n      }\n    }\n  }\n\n  discardColor(color: Color): void {\n    this.castlingRights = this.castlingRights.diff(SquareSet.backrank(color));\n    this.rook[color].a = undefined;\n    this.rook[color].h = undefined;\n  }\n}\n\nexport interface Context {\n  king: Square | undefined;\n  blockers: SquareSet;\n  checkers: SquareSet;\n  variantEnd: boolean;\n  mustCapture: boolean;\n}\n\nexport abstract class Position {\n  board: Board;\n  pockets: Material | undefined;\n  turn: Color;\n  castles: Castles;\n  epSquare: Square | undefined;\n  remainingChecks: RemainingChecks | undefined;\n  halfmoves: number;\n  fullmoves: number;\n\n  protected constructor(readonly rules: Rules) {}\n\n  reset() {\n    this.board = Board.default();\n    this.pockets = undefined;\n    this.turn = 'white';\n    this.castles = Castles.default();\n    this.epSquare = undefined;\n    this.remainingChecks = undefined;\n    this.halfmoves = 0;\n    this.fullmoves = 1;\n  }\n\n  protected setupUnchecked(setup: Setup) {\n    this.board = setup.board.clone();\n    this.board.promoted = SquareSet.empty();\n    this.pockets = undefined;\n    this.turn = setup.turn;\n    this.castles = Castles.fromSetup(setup);\n    this.epSquare = validEpSquare(this, setup.epSquare);\n    this.remainingChecks = undefined;\n    this.halfmoves = setup.halfmoves;\n    this.fullmoves = setup.fullmoves;\n  }\n\n  // When subclassing overwrite at least:\n  //\n  // - static default()\n  // - static fromSetup()\n  // - static clone()\n  //\n  // - dests()\n  // - isVariantEnd()\n  // - variantOutcome()\n  // - hasInsufficientMaterial()\n  // - isStandardMaterial()\n\n  kingAttackers(square: Square, attacker: Color, occupied: SquareSet): SquareSet {\n    return attacksTo(square, attacker, this.board, occupied);\n  }\n\n  protected playCaptureAt(square: Square, captured: Piece): void {\n    this.halfmoves = 0;\n    if (captured.role === 'rook') this.castles.discardRook(square);\n    if (this.pockets) this.pockets[opposite(captured.color)][captured.promoted ? 'pawn' : captured.role]++;\n  }\n\n  ctx(): Context {\n    const variantEnd = this.isVariantEnd();\n    const king = this.board.kingOf(this.turn);\n    if (!defined(king)) {\n      return { king, blockers: SquareSet.empty(), checkers: SquareSet.empty(), variantEnd, mustCapture: false };\n    }\n    const snipers = rookAttacks(king, SquareSet.empty())\n      .intersect(this.board.rooksAndQueens())\n      .union(bishopAttacks(king, SquareSet.empty()).intersect(this.board.bishopsAndQueens()))\n      .intersect(this.board[opposite(this.turn)]);\n    let blockers = SquareSet.empty();\n    for (const sniper of snipers) {\n      const b = between(king, sniper).intersect(this.board.occupied);\n      if (!b.moreThanOne()) blockers = blockers.union(b);\n    }\n    const checkers = this.kingAttackers(king, opposite(this.turn), this.board.occupied);\n    return {\n      king,\n      blockers,\n      checkers,\n      variantEnd,\n      mustCapture: false,\n    };\n  }\n\n  clone(): Position {\n    const pos = new (this as any).constructor();\n    pos.board = this.board.clone();\n    pos.pockets = this.pockets?.clone();\n    pos.turn = this.turn;\n    pos.castles = this.castles.clone();\n    pos.epSquare = this.epSquare;\n    pos.remainingChecks = this.remainingChecks?.clone();\n    pos.halfmoves = this.halfmoves;\n    pos.fullmoves = this.fullmoves;\n    return pos;\n  }\n\n  protected validate(): Result<undefined, PositionError> {\n    if (this.board.occupied.isEmpty()) return Result.err(new PositionError(IllegalSetup.Empty));\n    if (this.board.king.size() !== 2) return Result.err(new PositionError(IllegalSetup.Kings));\n\n    if (!defined(this.board.kingOf(this.turn))) return Result.err(new PositionError(IllegalSetup.Kings));\n\n    const otherKing = this.board.kingOf(opposite(this.turn));\n    if (!defined(otherKing)) return Result.err(new PositionError(IllegalSetup.Kings));\n    if (this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty()) {\n      return Result.err(new PositionError(IllegalSetup.OppositeCheck));\n    }\n\n    if (SquareSet.backranks().intersects(this.board.pawn)) {\n      return Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));\n    }\n\n    return Result.ok(undefined);\n  }\n\n  dropDests(_ctx?: Context): SquareSet {\n    return SquareSet.empty();\n  }\n\n  dests(square: Square, ctx?: Context): SquareSet {\n    ctx = ctx || this.ctx();\n    if (ctx.variantEnd) return SquareSet.empty();\n    const piece = this.board.get(square);\n    if (!piece || piece.color !== this.turn) return SquareSet.empty();\n\n    let pseudo, legal;\n    if (piece.role === 'pawn') {\n      pseudo = pawnAttacks(this.turn, square).intersect(this.board[opposite(this.turn)]);\n      const delta = this.turn === 'white' ? 8 : -8;\n      const step = square + delta;\n      if (0 <= step && step < 64 && !this.board.occupied.has(step)) {\n        pseudo = pseudo.with(step);\n        const canDoubleStep = this.turn === 'white' ? square < 16 : square >= 64 - 16;\n        const doubleStep = step + delta;\n        if (canDoubleStep && !this.board.occupied.has(doubleStep)) {\n          pseudo = pseudo.with(doubleStep);\n        }\n      }\n      if (defined(this.epSquare) && canCaptureEp(this, square, ctx)) {\n        legal = SquareSet.fromSquare(this.epSquare);\n      }\n    } else if (piece.role === 'bishop') pseudo = bishopAttacks(square, this.board.occupied);\n    else if (piece.role === 'knight') pseudo = knightAttacks(square);\n    else if (piece.role === 'rook') pseudo = rookAttacks(square, this.board.occupied);\n    else if (piece.role === 'queen') pseudo = queenAttacks(square, this.board.occupied);\n    else pseudo = kingAttacks(square);\n\n    pseudo = pseudo.diff(this.board[this.turn]);\n\n    if (defined(ctx.king)) {\n      if (piece.role === 'king') {\n        const occ = this.board.occupied.without(square);\n        for (const to of pseudo) {\n          if (this.kingAttackers(to, opposite(this.turn), occ).nonEmpty()) pseudo = pseudo.without(to);\n        }\n        return pseudo.union(castlingDest(this, 'a', ctx)).union(castlingDest(this, 'h', ctx));\n      }\n\n      if (ctx.checkers.nonEmpty()) {\n        const checker = ctx.checkers.singleSquare();\n        if (!defined(checker)) return SquareSet.empty();\n        pseudo = pseudo.intersect(between(checker, ctx.king).with(checker));\n      }\n\n      if (ctx.blockers.has(square)) pseudo = pseudo.intersect(ray(square, ctx.king));\n    }\n\n    if (legal) pseudo = pseudo.union(legal);\n    return pseudo;\n  }\n\n  isVariantEnd(): boolean {\n    return false;\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    return;\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    if (this.board[color].intersect(this.board.pawn.union(this.board.rooksAndQueens())).nonEmpty()) return false;\n    if (this.board[color].intersects(this.board.knight)) {\n      return (\n        this.board[color].size() <= 2\n        && this.board[opposite(color)].diff(this.board.king).diff(this.board.queen).isEmpty()\n      );\n    }\n    if (this.board[color].intersects(this.board.bishop)) {\n      const sameColor = !this.board.bishop.intersects(SquareSet.darkSquares())\n        || !this.board.bishop.intersects(SquareSet.lightSquares());\n      return sameColor && this.board.pawn.isEmpty() && this.board.knight.isEmpty();\n    }\n    return true;\n  }\n\n  // The following should be identical in all subclasses\n\n  toSetup(): Setup {\n    return {\n      board: this.board.clone(),\n      pockets: this.pockets?.clone(),\n      turn: this.turn,\n      castlingRights: this.castles.castlingRights,\n      epSquare: legalEpSquare(this),\n      remainingChecks: this.remainingChecks?.clone(),\n      halfmoves: Math.min(this.halfmoves, 150),\n      fullmoves: Math.min(Math.max(this.fullmoves, 1), 9999),\n    };\n  }\n\n  isInsufficientMaterial(): boolean {\n    return COLORS.every(color => this.hasInsufficientMaterial(color));\n  }\n\n  hasDests(ctx?: Context): boolean {\n    ctx = ctx || this.ctx();\n    for (const square of this.board[this.turn]) {\n      if (this.dests(square, ctx).nonEmpty()) return true;\n    }\n    return this.dropDests(ctx).nonEmpty();\n  }\n\n  isLegal(move: Move, ctx?: Context): boolean {\n    if (isDrop(move)) {\n      if (!this.pockets || this.pockets[this.turn][move.role] <= 0) return false;\n      if (move.role === 'pawn' && SquareSet.backranks().has(move.to)) return false;\n      return this.dropDests(ctx).has(move.to);\n    } else {\n      if (move.promotion === 'pawn') return false;\n      if (move.promotion === 'king' && this.rules !== 'antichess') return false;\n      if (!!move.promotion !== (this.board.pawn.has(move.from) && SquareSet.backranks().has(move.to))) return false;\n      const dests = this.dests(move.from, ctx);\n      return dests.has(move.to) || dests.has(normalizeMove(this, move).to);\n    }\n  }\n\n  isCheck(): boolean {\n    const king = this.board.kingOf(this.turn);\n    return defined(king) && this.kingAttackers(king, opposite(this.turn), this.board.occupied).nonEmpty();\n  }\n\n  isEnd(ctx?: Context): boolean {\n    if (ctx ? ctx.variantEnd : this.isVariantEnd()) return true;\n    return this.isInsufficientMaterial() || !this.hasDests(ctx);\n  }\n\n  isCheckmate(ctx?: Context): boolean {\n    ctx = ctx || this.ctx();\n    return !ctx.variantEnd && ctx.checkers.nonEmpty() && !this.hasDests(ctx);\n  }\n\n  isStalemate(ctx?: Context): boolean {\n    ctx = ctx || this.ctx();\n    return !ctx.variantEnd && ctx.checkers.isEmpty() && !this.hasDests(ctx);\n  }\n\n  outcome(ctx?: Context): Outcome | undefined {\n    const variantOutcome = this.variantOutcome(ctx);\n    if (variantOutcome) return variantOutcome;\n    ctx = ctx || this.ctx();\n    if (this.isCheckmate(ctx)) return { winner: opposite(this.turn) };\n    else if (this.isInsufficientMaterial() || this.isStalemate(ctx)) return { winner: undefined };\n    else return;\n  }\n\n  allDests(ctx?: Context): Map<Square, SquareSet> {\n    ctx = ctx || this.ctx();\n    const d = new Map();\n    if (ctx.variantEnd) return d;\n    for (const square of this.board[this.turn]) {\n      d.set(square, this.dests(square, ctx));\n    }\n    return d;\n  }\n\n  play(move: Move): void {\n    const turn = this.turn;\n    const epSquare = this.epSquare;\n    const castling = castlingSide(this, move);\n\n    this.epSquare = undefined;\n    this.halfmoves += 1;\n    if (turn === 'black') this.fullmoves += 1;\n    this.turn = opposite(turn);\n\n    if (isDrop(move)) {\n      this.board.set(move.to, { role: move.role, color: turn });\n      if (this.pockets) this.pockets[turn][move.role]--;\n      if (move.role === 'pawn') this.halfmoves = 0;\n    } else {\n      const piece = this.board.take(move.from);\n      if (!piece) return;\n\n      let epCapture: Piece | undefined;\n      if (piece.role === 'pawn') {\n        this.halfmoves = 0;\n        if (move.to === epSquare) {\n          epCapture = this.board.take(move.to + (turn === 'white' ? -8 : 8));\n        }\n        const delta = move.from - move.to;\n        if (Math.abs(delta) === 16 && 8 <= move.from && move.from <= 55) {\n          this.epSquare = (move.from + move.to) >> 1;\n        }\n        if (move.promotion) {\n          piece.role = move.promotion;\n          piece.promoted = !!this.pockets;\n        }\n      } else if (piece.role === 'rook') {\n        this.castles.discardRook(move.from);\n      } else if (piece.role === 'king') {\n        if (castling) {\n          const rookFrom = this.castles.rook[turn][castling];\n          if (defined(rookFrom)) {\n            const rook = this.board.take(rookFrom);\n            this.board.set(kingCastlesTo(turn, castling), piece);\n            if (rook) this.board.set(rookCastlesTo(turn, castling), rook);\n          }\n        }\n        this.castles.discardColor(turn);\n      }\n\n      if (!castling) {\n        const capture = this.board.set(move.to, piece) || epCapture;\n        if (capture) this.playCaptureAt(move.to, capture);\n      }\n    }\n\n    if (this.remainingChecks) {\n      if (this.isCheck()) this.remainingChecks[turn] = Math.max(this.remainingChecks[turn] - 1, 0);\n    }\n  }\n}\n\nexport class Chess extends Position {\n  private constructor() {\n    super('chess');\n  }\n\n  static default(): Chess {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<Chess, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): Chess {\n    return super.clone() as Chess;\n  }\n}\n\nconst validEpSquare = (pos: Position, square: Square | undefined): Square | undefined => {\n  if (!defined(square)) return;\n  const epRank = pos.turn === 'white' ? 5 : 2;\n  const forward = pos.turn === 'white' ? 8 : -8;\n  if (squareRank(square) !== epRank) return;\n  if (pos.board.occupied.has(square + forward)) return;\n  const pawn = square - forward;\n  if (!pos.board.pawn.has(pawn) || !pos.board[opposite(pos.turn)].has(pawn)) return;\n  return square;\n};\n\nconst legalEpSquare = (pos: Position): Square | undefined => {\n  if (!defined(pos.epSquare)) return;\n  const ctx = pos.ctx();\n  const ourPawns = pos.board.pieces(pos.turn, 'pawn');\n  const candidates = ourPawns.intersect(pawnAttacks(opposite(pos.turn), pos.epSquare));\n  for (const candidate of candidates) {\n    if (pos.dests(candidate, ctx).has(pos.epSquare)) return pos.epSquare;\n  }\n  return;\n};\n\nconst canCaptureEp = (pos: Position, pawnFrom: Square, ctx: Context): boolean => {\n  if (!defined(pos.epSquare)) return false;\n  if (!pawnAttacks(pos.turn, pawnFrom).has(pos.epSquare)) return false;\n  if (!defined(ctx.king)) return true;\n  const delta = pos.turn === 'white' ? 8 : -8;\n  const captured = pos.epSquare - delta;\n  return pos\n    .kingAttackers(\n      ctx.king,\n      opposite(pos.turn),\n      pos.board.occupied.toggle(pawnFrom).toggle(captured).with(pos.epSquare),\n    )\n    .without(captured)\n    .isEmpty();\n};\n\nconst castlingDest = (pos: Position, side: CastlingSide, ctx: Context): SquareSet => {\n  if (!defined(ctx.king) || ctx.checkers.nonEmpty()) return SquareSet.empty();\n  const rook = pos.castles.rook[pos.turn][side];\n  if (!defined(rook)) return SquareSet.empty();\n  if (pos.castles.path[pos.turn][side].intersects(pos.board.occupied)) return SquareSet.empty();\n\n  const kingTo = kingCastlesTo(pos.turn, side);\n  const kingPath = between(ctx.king, kingTo);\n  const occ = pos.board.occupied.without(ctx.king);\n  for (const sq of kingPath) {\n    if (pos.kingAttackers(sq, opposite(pos.turn), occ).nonEmpty()) return SquareSet.empty();\n  }\n\n  const rookTo = rookCastlesTo(pos.turn, side);\n  const after = pos.board.occupied.toggle(ctx.king).toggle(rook).toggle(rookTo);\n  if (pos.kingAttackers(kingTo, opposite(pos.turn), after).nonEmpty()) return SquareSet.empty();\n\n  return SquareSet.fromSquare(rook);\n};\n\nexport const pseudoDests = (pos: Position, square: Square, ctx: Context): SquareSet => {\n  if (ctx.variantEnd) return SquareSet.empty();\n  const piece = pos.board.get(square);\n  if (!piece || piece.color !== pos.turn) return SquareSet.empty();\n\n  let pseudo = attacks(piece, square, pos.board.occupied);\n  if (piece.role === 'pawn') {\n    let captureTargets = pos.board[opposite(pos.turn)];\n    if (defined(pos.epSquare)) captureTargets = captureTargets.with(pos.epSquare);\n    pseudo = pseudo.intersect(captureTargets);\n    const delta = pos.turn === 'white' ? 8 : -8;\n    const step = square + delta;\n    if (0 <= step && step < 64 && !pos.board.occupied.has(step)) {\n      pseudo = pseudo.with(step);\n      const canDoubleStep = pos.turn === 'white' ? square < 16 : square >= 64 - 16;\n      const doubleStep = step + delta;\n      if (canDoubleStep && !pos.board.occupied.has(doubleStep)) {\n        pseudo = pseudo.with(doubleStep);\n      }\n    }\n    return pseudo;\n  } else {\n    pseudo = pseudo.diff(pos.board[pos.turn]);\n  }\n  if (square === ctx.king) return pseudo.union(castlingDest(pos, 'a', ctx)).union(castlingDest(pos, 'h', ctx));\n  else return pseudo;\n};\n\nexport const equalsIgnoreMoves = (left: Position, right: Position): boolean =>\n  left.rules === right.rules\n  && boardEquals(left.board, right.board)\n  && ((right.pockets && left.pockets?.equals(right.pockets)) || (!left.pockets && !right.pockets))\n  && left.turn === right.turn\n  && left.castles.castlingRights.equals(right.castles.castlingRights)\n  && legalEpSquare(left) === legalEpSquare(right)\n  && ((right.remainingChecks && left.remainingChecks?.equals(right.remainingChecks))\n    || (!left.remainingChecks && !right.remainingChecks));\n\nexport const castlingSide = (pos: Position, move: Move): CastlingSide | undefined => {\n  if (isDrop(move)) return;\n  const delta = move.to - move.from;\n  if (Math.abs(delta) !== 2 && !pos.board[pos.turn].has(move.to)) return;\n  if (!pos.board.king.has(move.from)) return;\n  return delta > 0 ? 'h' : 'a';\n};\n\nexport const normalizeMove = (pos: Position, move: Move): Move => {\n  const side = castlingSide(pos, move);\n  if (!side) return move;\n  const rookFrom = pos.castles.rook[pos.turn][side];\n  return {\n    from: (move as NormalMove).from,\n    to: defined(rookFrom) ? rookFrom : move.to,\n  };\n};\n\nexport const isStandardMaterialSide = (board: Board, color: Color): boolean => {\n  const promoted = Math.max(board.pieces(color, 'queen').size() - 1, 0)\n    + Math.max(board.pieces(color, 'rook').size() - 2, 0)\n    + Math.max(board.pieces(color, 'knight').size() - 2, 0)\n    + Math.max(board.pieces(color, 'bishop').intersect(SquareSet.lightSquares()).size() - 1, 0)\n    + Math.max(board.pieces(color, 'bishop').intersect(SquareSet.darkSquares()).size() - 1, 0);\n  return board.pieces(color, 'pawn').size() + promoted <= 8;\n};\n\nexport const isStandardMaterial = (pos: Chess): boolean =>\n  COLORS.every(color => isStandardMaterialSide(pos.board, color));\n\nexport const isImpossibleCheck = (pos: Position): boolean => {\n  const ourKing = pos.board.kingOf(pos.turn);\n  if (!defined(ourKing)) return false;\n  const checkers = pos.kingAttackers(ourKing, opposite(pos.turn), pos.board.occupied);\n  if (checkers.isEmpty()) return false;\n  if (defined(pos.epSquare)) {\n    // The pushed pawn must be the only checker, or it has uncovered\n    // check by a single sliding piece.\n    const pushedTo = pos.epSquare ^ 8;\n    const pushedFrom = pos.epSquare ^ 24;\n    return (\n      checkers.moreThanOne()\n      || (checkers.first()! !== pushedTo\n        && pos\n          .kingAttackers(ourKing, opposite(pos.turn), pos.board.occupied.without(pushedTo).with(pushedFrom))\n          .nonEmpty())\n    );\n  } else if (pos.rules === 'atomic') {\n    // Other king moving away can cause many checks to be given at the same\n    // time. Not checking details, or even that the king is close enough.\n    return false;\n  } else {\n    // Sliding checkers aligned with king.\n    return checkers.size() > 2 || (checkers.size() === 2 && ray(checkers.first()!, checkers.last()!).has(ourKing));\n  }\n};\n","function r(r,n){r.prototype=Object.create(n.prototype),r.prototype.constructor=r,t(r,n)}function t(r,n){return t=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(r,t){return r.__proto__=t,r},t(r,n)}var n,e=/*#__PURE__*/function(){function r(){}var t=r.prototype;return t.unwrap=function(r,t){var e=this._chain(function(t){return n.ok(r?r(t):t)},function(r){return t?n.ok(t(r)):n.err(r)});if(e.isErr)throw e.error;return e.value},t.map=function(r,t){return this._chain(function(t){return n.ok(r(t))},function(r){return n.err(t?t(r):r)})},t.chain=function(r,t){return this._chain(r,t||function(r){return n.err(r)})},r}(),o=/*#__PURE__*/function(t){function n(r){var n;return(n=t.call(this)||this).value=void 0,n.isOk=!0,n.isErr=!1,n.value=r,n}return r(n,t),n.prototype._chain=function(r,t){return r(this.value)},n}(e),u=/*#__PURE__*/function(t){function n(r){var n;return(n=t.call(this)||this).error=void 0,n.isOk=!1,n.isErr=!0,n.error=r,n}return r(n,t),n.prototype._chain=function(r,t){return t(this.error)},n}(e);!function(r){r.ok=function(r){return new o(r)},r.err=function(r){return new u(r||new Error)},r.all=function(t){if(Array.isArray(t)){for(var n=[],e=0;e<t.length;e++){var o=t[e];if(o.isErr)return o;n.push(o.value)}return r.ok(n)}for(var u={},i=Object.keys(t),c=0;c<i.length;c++){var f=t[i[c]];if(f.isErr)return f;u[i[c]]=f.value}return r.ok(u)}}(n||(n={}));export{n as Result};\n//# sourceMappingURL=index.module.mjs.map\n","abstract class _Result<T, E extends Error> {\n  protected abstract _chain<X, U extends Error>(\n    ok: (value: T) => Result<X, U>,\n    err: (error: E) => Result<X, U>\n  ): Result<X, U>;\n\n  unwrap(): T;\n  unwrap<U>(ok: (value: T) => U): U;\n  unwrap<U, V>(ok: (value: T) => U, err: (error: E) => V): U | V;\n  unwrap<U>(ok: (value: T) => U, err: (error: E) => U): U;\n  unwrap(ok?: (value: T) => unknown, err?: (error: E) => unknown): unknown {\n    const r = this._chain(\n      value => Result.ok(ok ? ok(value) : value),\n      error => (err ? Result.ok(err(error)) : Result.err(error))\n    );\n    if (r.isErr) {\n      throw r.error;\n    }\n    return r.value;\n  }\n\n  map<U>(ok: (value: T) => U): Result<U, E>;\n  map<U, F extends Error>(\n    ok: (value: T) => U,\n    err: (error: E) => F\n  ): Result<U, F>;\n  map(ok: (value: T) => unknown, err?: (error: E) => Error): Result<unknown> {\n    return this._chain(\n      value => Result.ok(ok(value)),\n      error => Result.err(err ? err(error) : error)\n    );\n  }\n\n  chain<X>(ok: (value: T) => Result<X, E>): Result<X, E>;\n  chain<X>(\n    ok: (value: T) => Result<X, E>,\n    err: (error: E) => Result<X, E>\n  ): Result<X, E>;\n  chain<X, U extends Error>(\n    ok: (value: T) => Result<X, U>,\n    err: (error: E) => Result<X, U>\n  ): Result<X, U>;\n  chain(\n    ok: (value: T) => Result<unknown>,\n    err?: (error: E) => Result<unknown>\n  ): Result<unknown> {\n    return this._chain(ok, err || (error => Result.err(error)));\n  }\n}\n\nclass _Ok<T, E extends Error> extends _Result<T, E> {\n  readonly isOk = true;\n  readonly isErr = false;\n  constructor(readonly value: T) {\n    super();\n  }\n\n  protected _chain<X, U extends Error>(\n    ok: (value: T) => Result<X, U>,\n    _err: (error: E) => Result<X, U>\n  ): Result<X, U> {\n    return ok(this.value);\n  }\n}\n\nclass _Err<T, E extends Error> extends _Result<T, E> {\n  readonly isOk = false;\n  readonly isErr = true;\n  constructor(readonly error: E) {\n    super();\n  }\n\n  protected _chain<X, U extends Error>(\n    _ok: (value: T) => Result<X, U>,\n    err: (error: E) => Result<X, U>\n  ): Result<X, U> {\n    return err(this.error);\n  }\n}\n\nexport namespace Result {\n  export interface Ok<T, E extends Error> extends _Ok<T, E> {}\n  export interface Err<T, E extends Error> extends _Err<T, E> {}\n\n  export function ok<T, E extends Error>(value: T): Result<T, E> {\n    return new _Ok(value);\n  }\n  export function err<E extends Error, T = never>(error?: E): Result<T, E>\n  export function err<E extends Error, T = never>(error: E): Result<T, E> {\n    return new _Err(error || new Error());\n  }\n\n  type U = Result<unknown>;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n    R11 extends U,\n    R12 extends U,\n    R13 extends U,\n    R14 extends U,\n    R15 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n      OkType<R11>,\n      OkType<R12>,\n      OkType<R13>,\n      OkType<R14>,\n      OkType<R15>\n    ],\n    ErrType<\n      | R0\n      | R1\n      | R2\n      | R3\n      | R4\n      | R5\n      | R6\n      | R7\n      | R8\n      | R9\n      | R10\n      | R11\n      | R12\n      | R13\n      | R14\n      | R15\n    >\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n    R11 extends U,\n    R12 extends U,\n    R13 extends U,\n    R14 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n      OkType<R11>,\n      OkType<R12>,\n      OkType<R13>,\n      OkType<R14>\n    ],\n    ErrType<\n      | R0\n      | R1\n      | R2\n      | R3\n      | R4\n      | R5\n      | R6\n      | R7\n      | R8\n      | R9\n      | R10\n      | R11\n      | R12\n      | R13\n      | R14\n    >\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n    R11 extends U,\n    R12 extends U,\n    R13 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n      OkType<R11>,\n      OkType<R12>,\n      OkType<R13>\n    ],\n    ErrType<\n      R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | R11 | R12 | R13\n    >\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n    R11 extends U,\n    R12 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n      OkType<R11>\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | R11>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n    R11 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n      OkType<R11>\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | R11>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5]\n  ): Result<\n    [OkType<R0>, OkType<R1>, OkType<R2>, OkType<R3>, OkType<R4>, OkType<R5>],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4]\n  ): Result<\n    [OkType<R0>, OkType<R1>, OkType<R2>, OkType<R3>, OkType<R4>],\n    ErrType<R0 | R1 | R2 | R3 | R4>\n  >;\n  export function all<R0 extends U, R1 extends U, R2 extends U, R3 extends U>(\n    obj: [R0, R1, R2, R3]\n  ): Result<\n    [OkType<R0>, OkType<R1>, OkType<R2>, OkType<R3>],\n    ErrType<R0 | R1 | R2 | R3>\n  >;\n  export function all<R0 extends U, R1 extends U, R2 extends U>(\n    obj: [R0, R1, R2]\n  ): Result<[OkType<R0>, OkType<R1>, OkType<R2>], ErrType<R0 | R1 | R2>>;\n  export function all<R0 extends U, R1 extends U>(\n    obj: [R0, R1]\n  ): Result<[OkType<R0>, OkType<R1>], ErrType<R0 | R1>>;\n  export function all<R0 extends U>(\n    obj: [R0]\n  ): Result<[OkType<R0>], ErrType<R0>>;\n  export function all(obj: []): Result<[]>;\n  export function all<T extends Array<U> | Record<string, U>>(\n    obj: T\n  ): Result<\n    { [K in keyof T]: T[K] extends Result<infer I> ? I : never },\n    {\n      [K in keyof T]: T[K] extends Result<unknown, infer E> ? E : never;\n    }[keyof T]\n  >;\n  export function all(obj: unknown): unknown {\n    if (Array.isArray(obj)) {\n      const res = [];\n      for (let i = 0; i < obj.length; i++) {\n        const item = obj[i];\n        if (item.isErr) {\n          return item;\n        }\n        res.push(item.value);\n      }\n      return Result.ok(res);\n    }\n\n    const res: Record<string, unknown> = {};\n    const keys = Object.keys(obj as Record<string, U>);\n    for (let i = 0; i < keys.length; i++) {\n      const item = (obj as Record<string, U>)[keys[i]];\n      if (item.isErr) {\n        return item;\n      }\n      res[keys[i]] = item.value;\n    }\n    return Result.ok(res);\n  }\n}\n\nexport type Result<T, E extends Error = Error> =\n  | Result.Ok<T, E>\n  | Result.Err<T, E>;\n\ntype OkType<R extends Result<unknown>> = R extends Result<infer O> ? O : never;\ntype ErrType<R extends Result<unknown>> = R extends Result<unknown, infer E>\n  ? E\n  : never;\n","/**\n * Compute attacks and rays.\n *\n * These are low-level functions that can be used to implement chess rules.\n *\n * Implementation notes: Sliding attacks are computed using\n * [Hyperbola Quintessence](https://www.chessprogramming.org/Hyperbola_Quintessence).\n * Magic Bitboards would deliver slightly faster lookups, but also require\n * initializing considerably larger attack tables. On the web, initialization\n * time is important, so the chosen method may strike a better balance.\n *\n * @packageDocumentation\n */\nimport { SquareSet } from './squareSet.js';\nimport { squareFile, squareRank } from './util.js';\nconst computeRange = (square, deltas) => {\n    let range = SquareSet.empty();\n    for (const delta of deltas) {\n        const sq = square + delta;\n        if (0 <= sq && sq < 64 && Math.abs(squareFile(square) - squareFile(sq)) <= 2) {\n            range = range.with(sq);\n        }\n    }\n    return range;\n};\nconst tabulate = (f) => {\n    const table = [];\n    for (let square = 0; square < 64; square++)\n        table[square] = f(square);\n    return table;\n};\nconst KING_ATTACKS = tabulate(sq => computeRange(sq, [-9, -8, -7, -1, 1, 7, 8, 9]));\nconst KNIGHT_ATTACKS = tabulate(sq => computeRange(sq, [-17, -15, -10, -6, 6, 10, 15, 17]));\nconst PAWN_ATTACKS = {\n    white: tabulate(sq => computeRange(sq, [7, 9])),\n    black: tabulate(sq => computeRange(sq, [-7, -9])),\n};\n/**\n * Gets squares attacked or defended by a king on `square`.\n */\nexport const kingAttacks = (square) => KING_ATTACKS[square];\n/**\n * Gets squares attacked or defended by a knight on `square`.\n */\nexport const knightAttacks = (square) => KNIGHT_ATTACKS[square];\n/**\n * Gets squares attacked or defended by a pawn of the given `color`\n * on `square`.\n */\nexport const pawnAttacks = (color, square) => PAWN_ATTACKS[color][square];\nconst FILE_RANGE = tabulate(sq => SquareSet.fromFile(squareFile(sq)).without(sq));\nconst RANK_RANGE = tabulate(sq => SquareSet.fromRank(squareRank(sq)).without(sq));\nconst DIAG_RANGE = tabulate(sq => {\n    const diag = new SquareSet(134480385, 2151686160);\n    const shift = 8 * (squareRank(sq) - squareFile(sq));\n    return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);\n});\nconst ANTI_DIAG_RANGE = tabulate(sq => {\n    const diag = new SquareSet(270549120, 16909320);\n    const shift = 8 * (squareRank(sq) + squareFile(sq) - 7);\n    return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);\n});\nconst hyperbola = (bit, range, occupied) => {\n    let forward = occupied.intersect(range);\n    let reverse = forward.bswap64(); // Assumes no more than 1 bit per rank\n    forward = forward.minus64(bit);\n    reverse = reverse.minus64(bit.bswap64());\n    return forward.xor(reverse.bswap64()).intersect(range);\n};\nconst fileAttacks = (square, occupied) => hyperbola(SquareSet.fromSquare(square), FILE_RANGE[square], occupied);\nconst rankAttacks = (square, occupied) => {\n    const range = RANK_RANGE[square];\n    let forward = occupied.intersect(range);\n    let reverse = forward.rbit64();\n    forward = forward.minus64(SquareSet.fromSquare(square));\n    reverse = reverse.minus64(SquareSet.fromSquare(63 - square));\n    return forward.xor(reverse.rbit64()).intersect(range);\n};\n/**\n * Gets squares attacked or defended by a bishop on `square`, given `occupied`\n * squares.\n */\nexport const bishopAttacks = (square, occupied) => {\n    const bit = SquareSet.fromSquare(square);\n    return hyperbola(bit, DIAG_RANGE[square], occupied).xor(hyperbola(bit, ANTI_DIAG_RANGE[square], occupied));\n};\n/**\n * Gets squares attacked or defended by a rook on `square`, given `occupied`\n * squares.\n */\nexport const rookAttacks = (square, occupied) => fileAttacks(square, occupied).xor(rankAttacks(square, occupied));\n/**\n * Gets squares attacked or defended by a queen on `square`, given `occupied`\n * squares.\n */\nexport const queenAttacks = (square, occupied) => bishopAttacks(square, occupied).xor(rookAttacks(square, occupied));\n/**\n * Gets squares attacked or defended by a `piece` on `square`, given\n * `occupied` squares.\n */\nexport const attacks = (piece, square, occupied) => {\n    switch (piece.role) {\n        case 'pawn':\n            return pawnAttacks(piece.color, square);\n        case 'knight':\n            return knightAttacks(square);\n        case 'bishop':\n            return bishopAttacks(square, occupied);\n        case 'rook':\n            return rookAttacks(square, occupied);\n        case 'queen':\n            return queenAttacks(square, occupied);\n        case 'king':\n            return kingAttacks(square);\n    }\n};\n/**\n * Gets all squares of the rank, file or diagonal with the two squares\n * `a` and `b`, or an empty set if they are not aligned.\n */\nexport const ray = (a, b) => {\n    const other = SquareSet.fromSquare(b);\n    if (RANK_RANGE[a].intersects(other))\n        return RANK_RANGE[a].with(a);\n    if (ANTI_DIAG_RANGE[a].intersects(other))\n        return ANTI_DIAG_RANGE[a].with(a);\n    if (DIAG_RANGE[a].intersects(other))\n        return DIAG_RANGE[a].with(a);\n    if (FILE_RANGE[a].intersects(other))\n        return FILE_RANGE[a].with(a);\n    return SquareSet.empty();\n};\n/**\n * Gets all squares between `a` and `b` (bounds not included), or an empty set\n * if they are not on the same rank, file or diagonal.\n */\nexport const between = (a, b) => ray(a, b)\n    .intersect(SquareSet.full().shl64(a).xor(SquareSet.full().shl64(b)))\n    .withoutFirst();\n//# sourceMappingURL=attacks.js.map","/**\n * Compute attacks and rays.\n *\n * These are low-level functions that can be used to implement chess rules.\n *\n * Implementation notes: Sliding attacks are computed using\n * [Hyperbola Quintessence](https://www.chessprogramming.org/Hyperbola_Quintessence).\n * Magic Bitboards would deliver slightly faster lookups, but also require\n * initializing considerably larger attack tables. On the web, initialization\n * time is important, so the chosen method may strike a better balance.\n *\n * @packageDocumentation\n */\n\nimport { SquareSet } from './squareSet.js';\nimport { BySquare, Color, Piece, Square } from './types.js';\nimport { squareFile, squareRank } from './util.js';\n\nconst computeRange = (square: Square, deltas: number[]): SquareSet => {\n  let range = SquareSet.empty();\n  for (const delta of deltas) {\n    const sq = square + delta;\n    if (0 <= sq && sq < 64 && Math.abs(squareFile(square) - squareFile(sq)) <= 2) {\n      range = range.with(sq);\n    }\n  }\n  return range;\n};\n\nconst tabulate = <T>(f: (square: Square) => T): BySquare<T> => {\n  const table = [];\n  for (let square = 0; square < 64; square++) table[square] = f(square);\n  return table;\n};\n\nconst KING_ATTACKS = tabulate(sq => computeRange(sq, [-9, -8, -7, -1, 1, 7, 8, 9]));\nconst KNIGHT_ATTACKS = tabulate(sq => computeRange(sq, [-17, -15, -10, -6, 6, 10, 15, 17]));\nconst PAWN_ATTACKS = {\n  white: tabulate(sq => computeRange(sq, [7, 9])),\n  black: tabulate(sq => computeRange(sq, [-7, -9])),\n};\n\n/**\n * Gets squares attacked or defended by a king on `square`.\n */\nexport const kingAttacks = (square: Square): SquareSet => KING_ATTACKS[square];\n\n/**\n * Gets squares attacked or defended by a knight on `square`.\n */\nexport const knightAttacks = (square: Square): SquareSet => KNIGHT_ATTACKS[square];\n\n/**\n * Gets squares attacked or defended by a pawn of the given `color`\n * on `square`.\n */\nexport const pawnAttacks = (color: Color, square: Square): SquareSet => PAWN_ATTACKS[color][square];\n\nconst FILE_RANGE = tabulate(sq => SquareSet.fromFile(squareFile(sq)).without(sq));\nconst RANK_RANGE = tabulate(sq => SquareSet.fromRank(squareRank(sq)).without(sq));\n\nconst DIAG_RANGE = tabulate(sq => {\n  const diag = new SquareSet(0x0804_0201, 0x8040_2010);\n  const shift = 8 * (squareRank(sq) - squareFile(sq));\n  return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);\n});\n\nconst ANTI_DIAG_RANGE = tabulate(sq => {\n  const diag = new SquareSet(0x1020_4080, 0x0102_0408);\n  const shift = 8 * (squareRank(sq) + squareFile(sq) - 7);\n  return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);\n});\n\nconst hyperbola = (bit: SquareSet, range: SquareSet, occupied: SquareSet): SquareSet => {\n  let forward = occupied.intersect(range);\n  let reverse = forward.bswap64(); // Assumes no more than 1 bit per rank\n  forward = forward.minus64(bit);\n  reverse = reverse.minus64(bit.bswap64());\n  return forward.xor(reverse.bswap64()).intersect(range);\n};\n\nconst fileAttacks = (square: Square, occupied: SquareSet): SquareSet =>\n  hyperbola(SquareSet.fromSquare(square), FILE_RANGE[square], occupied);\n\nconst rankAttacks = (square: Square, occupied: SquareSet): SquareSet => {\n  const range = RANK_RANGE[square];\n  let forward = occupied.intersect(range);\n  let reverse = forward.rbit64();\n  forward = forward.minus64(SquareSet.fromSquare(square));\n  reverse = reverse.minus64(SquareSet.fromSquare(63 - square));\n  return forward.xor(reverse.rbit64()).intersect(range);\n};\n\n/**\n * Gets squares attacked or defended by a bishop on `square`, given `occupied`\n * squares.\n */\nexport const bishopAttacks = (square: Square, occupied: SquareSet): SquareSet => {\n  const bit = SquareSet.fromSquare(square);\n  return hyperbola(bit, DIAG_RANGE[square], occupied).xor(hyperbola(bit, ANTI_DIAG_RANGE[square], occupied));\n};\n\n/**\n * Gets squares attacked or defended by a rook on `square`, given `occupied`\n * squares.\n */\nexport const rookAttacks = (square: Square, occupied: SquareSet): SquareSet =>\n  fileAttacks(square, occupied).xor(rankAttacks(square, occupied));\n\n/**\n * Gets squares attacked or defended by a queen on `square`, given `occupied`\n * squares.\n */\nexport const queenAttacks = (square: Square, occupied: SquareSet): SquareSet =>\n  bishopAttacks(square, occupied).xor(rookAttacks(square, occupied));\n\n/**\n * Gets squares attacked or defended by a `piece` on `square`, given\n * `occupied` squares.\n */\nexport const attacks = (piece: Piece, square: Square, occupied: SquareSet): SquareSet => {\n  switch (piece.role) {\n    case 'pawn':\n      return pawnAttacks(piece.color, square);\n    case 'knight':\n      return knightAttacks(square);\n    case 'bishop':\n      return bishopAttacks(square, occupied);\n    case 'rook':\n      return rookAttacks(square, occupied);\n    case 'queen':\n      return queenAttacks(square, occupied);\n    case 'king':\n      return kingAttacks(square);\n  }\n};\n\n/**\n * Gets all squares of the rank, file or diagonal with the two squares\n * `a` and `b`, or an empty set if they are not aligned.\n */\nexport const ray = (a: Square, b: Square): SquareSet => {\n  const other = SquareSet.fromSquare(b);\n  if (RANK_RANGE[a].intersects(other)) return RANK_RANGE[a].with(a);\n  if (ANTI_DIAG_RANGE[a].intersects(other)) return ANTI_DIAG_RANGE[a].with(a);\n  if (DIAG_RANGE[a].intersects(other)) return DIAG_RANGE[a].with(a);\n  if (FILE_RANGE[a].intersects(other)) return FILE_RANGE[a].with(a);\n  return SquareSet.empty();\n};\n\n/**\n * Gets all squares between `a` and `b` (bounds not included), or an empty set\n * if they are not on the same rank, file or diagonal.\n */\nexport const between = (a: Square, b: Square): SquareSet =>\n  ray(a, b)\n    .intersect(SquareSet.full().shl64(a).xor(SquareSet.full().shl64(b)))\n    .withoutFirst();\n","const popcnt32 = (n) => {\n    n = n - ((n >>> 1) & 1431655765);\n    n = (n & 858993459) + ((n >>> 2) & 858993459);\n    return Math.imul((n + (n >>> 4)) & 252645135, 16843009) >> 24;\n};\nconst bswap32 = (n) => {\n    n = ((n >>> 8) & 16711935) | ((n & 16711935) << 8);\n    return ((n >>> 16) & 0xffff) | ((n & 0xffff) << 16);\n};\nconst rbit32 = (n) => {\n    n = ((n >>> 1) & 1431655765) | ((n & 1431655765) << 1);\n    n = ((n >>> 2) & 858993459) | ((n & 858993459) << 2);\n    n = ((n >>> 4) & 252645135) | ((n & 252645135) << 4);\n    return bswap32(n);\n};\n/**\n * An immutable set of squares, implemented as a bitboard.\n */\nexport class SquareSet {\n    constructor(lo, hi) {\n        this.lo = lo | 0;\n        this.hi = hi | 0;\n    }\n    static fromSquare(square) {\n        return square >= 32 ? new SquareSet(0, 1 << (square - 32)) : new SquareSet(1 << square, 0);\n    }\n    static fromRank(rank) {\n        return new SquareSet(0xff, 0).shl64(8 * rank);\n    }\n    static fromFile(file) {\n        return new SquareSet(16843009 << file, 16843009 << file);\n    }\n    static empty() {\n        return new SquareSet(0, 0);\n    }\n    static full() {\n        return new SquareSet(4294967295, 4294967295);\n    }\n    static corners() {\n        return new SquareSet(0x81, 2164260864);\n    }\n    static center() {\n        return new SquareSet(402653184, 0x18);\n    }\n    static backranks() {\n        return new SquareSet(0xff, 4278190080);\n    }\n    static backrank(color) {\n        return color === 'white' ? new SquareSet(0xff, 0) : new SquareSet(0, 4278190080);\n    }\n    static lightSquares() {\n        return new SquareSet(1437226410, 1437226410);\n    }\n    static darkSquares() {\n        return new SquareSet(2857740885, 2857740885);\n    }\n    complement() {\n        return new SquareSet(~this.lo, ~this.hi);\n    }\n    xor(other) {\n        return new SquareSet(this.lo ^ other.lo, this.hi ^ other.hi);\n    }\n    union(other) {\n        return new SquareSet(this.lo | other.lo, this.hi | other.hi);\n    }\n    intersect(other) {\n        return new SquareSet(this.lo & other.lo, this.hi & other.hi);\n    }\n    diff(other) {\n        return new SquareSet(this.lo & ~other.lo, this.hi & ~other.hi);\n    }\n    intersects(other) {\n        return this.intersect(other).nonEmpty();\n    }\n    isDisjoint(other) {\n        return this.intersect(other).isEmpty();\n    }\n    supersetOf(other) {\n        return other.diff(this).isEmpty();\n    }\n    subsetOf(other) {\n        return this.diff(other).isEmpty();\n    }\n    shr64(shift) {\n        if (shift >= 64)\n            return SquareSet.empty();\n        if (shift >= 32)\n            return new SquareSet(this.hi >>> (shift - 32), 0);\n        if (shift > 0)\n            return new SquareSet((this.lo >>> shift) ^ (this.hi << (32 - shift)), this.hi >>> shift);\n        return this;\n    }\n    shl64(shift) {\n        if (shift >= 64)\n            return SquareSet.empty();\n        if (shift >= 32)\n            return new SquareSet(0, this.lo << (shift - 32));\n        if (shift > 0)\n            return new SquareSet(this.lo << shift, (this.hi << shift) ^ (this.lo >>> (32 - shift)));\n        return this;\n    }\n    bswap64() {\n        return new SquareSet(bswap32(this.hi), bswap32(this.lo));\n    }\n    rbit64() {\n        return new SquareSet(rbit32(this.hi), rbit32(this.lo));\n    }\n    minus64(other) {\n        const lo = this.lo - other.lo;\n        const c = ((lo & other.lo & 1) + (other.lo >>> 1) + (lo >>> 1)) >>> 31;\n        return new SquareSet(lo, this.hi - (other.hi + c));\n    }\n    equals(other) {\n        return this.lo === other.lo && this.hi === other.hi;\n    }\n    size() {\n        return popcnt32(this.lo) + popcnt32(this.hi);\n    }\n    isEmpty() {\n        return this.lo === 0 && this.hi === 0;\n    }\n    nonEmpty() {\n        return this.lo !== 0 || this.hi !== 0;\n    }\n    has(square) {\n        return (square >= 32 ? this.hi & (1 << (square - 32)) : this.lo & (1 << square)) !== 0;\n    }\n    set(square, on) {\n        return on ? this.with(square) : this.without(square);\n    }\n    with(square) {\n        return square >= 32\n            ? new SquareSet(this.lo, this.hi | (1 << (square - 32)))\n            : new SquareSet(this.lo | (1 << square), this.hi);\n    }\n    without(square) {\n        return square >= 32\n            ? new SquareSet(this.lo, this.hi & ~(1 << (square - 32)))\n            : new SquareSet(this.lo & ~(1 << square), this.hi);\n    }\n    toggle(square) {\n        return square >= 32\n            ? new SquareSet(this.lo, this.hi ^ (1 << (square - 32)))\n            : new SquareSet(this.lo ^ (1 << square), this.hi);\n    }\n    last() {\n        if (this.hi !== 0)\n            return 63 - Math.clz32(this.hi);\n        if (this.lo !== 0)\n            return 31 - Math.clz32(this.lo);\n        return;\n    }\n    first() {\n        if (this.lo !== 0)\n            return 31 - Math.clz32(this.lo & -this.lo);\n        if (this.hi !== 0)\n            return 63 - Math.clz32(this.hi & -this.hi);\n        return;\n    }\n    withoutFirst() {\n        if (this.lo !== 0)\n            return new SquareSet(this.lo & (this.lo - 1), this.hi);\n        return new SquareSet(0, this.hi & (this.hi - 1));\n    }\n    moreThanOne() {\n        return (this.hi !== 0 && this.lo !== 0) || (this.lo & (this.lo - 1)) !== 0 || (this.hi & (this.hi - 1)) !== 0;\n    }\n    singleSquare() {\n        return this.moreThanOne() ? undefined : this.last();\n    }\n    *[Symbol.iterator]() {\n        let lo = this.lo;\n        let hi = this.hi;\n        while (lo !== 0) {\n            const idx = 31 - Math.clz32(lo & -lo);\n            lo ^= 1 << idx;\n            yield idx;\n        }\n        while (hi !== 0) {\n            const idx = 31 - Math.clz32(hi & -hi);\n            hi ^= 1 << idx;\n            yield 32 + idx;\n        }\n    }\n    *reversed() {\n        let lo = this.lo;\n        let hi = this.hi;\n        while (hi !== 0) {\n            const idx = 31 - Math.clz32(hi);\n            hi ^= 1 << idx;\n            yield 32 + idx;\n        }\n        while (lo !== 0) {\n            const idx = 31 - Math.clz32(lo);\n            lo ^= 1 << idx;\n            yield idx;\n        }\n    }\n}\n//# sourceMappingURL=squareSet.js.map","import { Color, Square } from './types.js';\n\nconst popcnt32 = (n: number): number => {\n  n = n - ((n >>> 1) & 0x5555_5555);\n  n = (n & 0x3333_3333) + ((n >>> 2) & 0x3333_3333);\n  return Math.imul((n + (n >>> 4)) & 0x0f0f_0f0f, 0x0101_0101) >> 24;\n};\n\nconst bswap32 = (n: number): number => {\n  n = ((n >>> 8) & 0x00ff_00ff) | ((n & 0x00ff_00ff) << 8);\n  return ((n >>> 16) & 0xffff) | ((n & 0xffff) << 16);\n};\n\nconst rbit32 = (n: number): number => {\n  n = ((n >>> 1) & 0x5555_5555) | ((n & 0x5555_5555) << 1);\n  n = ((n >>> 2) & 0x3333_3333) | ((n & 0x3333_3333) << 2);\n  n = ((n >>> 4) & 0x0f0f_0f0f) | ((n & 0x0f0f_0f0f) << 4);\n  return bswap32(n);\n};\n\n/**\n * An immutable set of squares, implemented as a bitboard.\n */\nexport class SquareSet implements Iterable<Square> {\n  readonly lo: number;\n  readonly hi: number;\n\n  constructor(lo: number, hi: number) {\n    this.lo = lo | 0;\n    this.hi = hi | 0;\n  }\n\n  static fromSquare(square: Square): SquareSet {\n    return square >= 32 ? new SquareSet(0, 1 << (square - 32)) : new SquareSet(1 << square, 0);\n  }\n\n  static fromRank(rank: number): SquareSet {\n    return new SquareSet(0xff, 0).shl64(8 * rank);\n  }\n\n  static fromFile(file: number): SquareSet {\n    return new SquareSet(0x0101_0101 << file, 0x0101_0101 << file);\n  }\n\n  static empty(): SquareSet {\n    return new SquareSet(0, 0);\n  }\n\n  static full(): SquareSet {\n    return new SquareSet(0xffff_ffff, 0xffff_ffff);\n  }\n\n  static corners(): SquareSet {\n    return new SquareSet(0x81, 0x8100_0000);\n  }\n\n  static center(): SquareSet {\n    return new SquareSet(0x1800_0000, 0x18);\n  }\n\n  static backranks(): SquareSet {\n    return new SquareSet(0xff, 0xff00_0000);\n  }\n\n  static backrank(color: Color): SquareSet {\n    return color === 'white' ? new SquareSet(0xff, 0) : new SquareSet(0, 0xff00_0000);\n  }\n\n  static lightSquares(): SquareSet {\n    return new SquareSet(0x55aa_55aa, 0x55aa_55aa);\n  }\n\n  static darkSquares(): SquareSet {\n    return new SquareSet(0xaa55_aa55, 0xaa55_aa55);\n  }\n\n  complement(): SquareSet {\n    return new SquareSet(~this.lo, ~this.hi);\n  }\n\n  xor(other: SquareSet): SquareSet {\n    return new SquareSet(this.lo ^ other.lo, this.hi ^ other.hi);\n  }\n\n  union(other: SquareSet): SquareSet {\n    return new SquareSet(this.lo | other.lo, this.hi | other.hi);\n  }\n\n  intersect(other: SquareSet): SquareSet {\n    return new SquareSet(this.lo & other.lo, this.hi & other.hi);\n  }\n\n  diff(other: SquareSet): SquareSet {\n    return new SquareSet(this.lo & ~other.lo, this.hi & ~other.hi);\n  }\n\n  intersects(other: SquareSet): boolean {\n    return this.intersect(other).nonEmpty();\n  }\n\n  isDisjoint(other: SquareSet): boolean {\n    return this.intersect(other).isEmpty();\n  }\n\n  supersetOf(other: SquareSet): boolean {\n    return other.diff(this).isEmpty();\n  }\n\n  subsetOf(other: SquareSet): boolean {\n    return this.diff(other).isEmpty();\n  }\n\n  shr64(shift: number): SquareSet {\n    if (shift >= 64) return SquareSet.empty();\n    if (shift >= 32) return new SquareSet(this.hi >>> (shift - 32), 0);\n    if (shift > 0) return new SquareSet((this.lo >>> shift) ^ (this.hi << (32 - shift)), this.hi >>> shift);\n    return this;\n  }\n\n  shl64(shift: number): SquareSet {\n    if (shift >= 64) return SquareSet.empty();\n    if (shift >= 32) return new SquareSet(0, this.lo << (shift - 32));\n    if (shift > 0) return new SquareSet(this.lo << shift, (this.hi << shift) ^ (this.lo >>> (32 - shift)));\n    return this;\n  }\n\n  bswap64(): SquareSet {\n    return new SquareSet(bswap32(this.hi), bswap32(this.lo));\n  }\n\n  rbit64(): SquareSet {\n    return new SquareSet(rbit32(this.hi), rbit32(this.lo));\n  }\n\n  minus64(other: SquareSet): SquareSet {\n    const lo = this.lo - other.lo;\n    const c = ((lo & other.lo & 1) + (other.lo >>> 1) + (lo >>> 1)) >>> 31;\n    return new SquareSet(lo, this.hi - (other.hi + c));\n  }\n\n  equals(other: SquareSet): boolean {\n    return this.lo === other.lo && this.hi === other.hi;\n  }\n\n  size(): number {\n    return popcnt32(this.lo) + popcnt32(this.hi);\n  }\n\n  isEmpty(): boolean {\n    return this.lo === 0 && this.hi === 0;\n  }\n\n  nonEmpty(): boolean {\n    return this.lo !== 0 || this.hi !== 0;\n  }\n\n  has(square: Square): boolean {\n    return (square >= 32 ? this.hi & (1 << (square - 32)) : this.lo & (1 << square)) !== 0;\n  }\n\n  set(square: Square, on: boolean): SquareSet {\n    return on ? this.with(square) : this.without(square);\n  }\n\n  with(square: Square): SquareSet {\n    return square >= 32\n      ? new SquareSet(this.lo, this.hi | (1 << (square - 32)))\n      : new SquareSet(this.lo | (1 << square), this.hi);\n  }\n\n  without(square: Square): SquareSet {\n    return square >= 32\n      ? new SquareSet(this.lo, this.hi & ~(1 << (square - 32)))\n      : new SquareSet(this.lo & ~(1 << square), this.hi);\n  }\n\n  toggle(square: Square): SquareSet {\n    return square >= 32\n      ? new SquareSet(this.lo, this.hi ^ (1 << (square - 32)))\n      : new SquareSet(this.lo ^ (1 << square), this.hi);\n  }\n\n  last(): Square | undefined {\n    if (this.hi !== 0) return 63 - Math.clz32(this.hi);\n    if (this.lo !== 0) return 31 - Math.clz32(this.lo);\n    return;\n  }\n\n  first(): Square | undefined {\n    if (this.lo !== 0) return 31 - Math.clz32(this.lo & -this.lo);\n    if (this.hi !== 0) return 63 - Math.clz32(this.hi & -this.hi);\n    return;\n  }\n\n  withoutFirst(): SquareSet {\n    if (this.lo !== 0) return new SquareSet(this.lo & (this.lo - 1), this.hi);\n    return new SquareSet(0, this.hi & (this.hi - 1));\n  }\n\n  moreThanOne(): boolean {\n    return (this.hi !== 0 && this.lo !== 0) || (this.lo & (this.lo - 1)) !== 0 || (this.hi & (this.hi - 1)) !== 0;\n  }\n\n  singleSquare(): Square | undefined {\n    return this.moreThanOne() ? undefined : this.last();\n  }\n\n  *[Symbol.iterator](): Iterator<Square> {\n    let lo = this.lo;\n    let hi = this.hi;\n    while (lo !== 0) {\n      const idx = 31 - Math.clz32(lo & -lo);\n      lo ^= 1 << idx;\n      yield idx;\n    }\n    while (hi !== 0) {\n      const idx = 31 - Math.clz32(hi & -hi);\n      hi ^= 1 << idx;\n      yield 32 + idx;\n    }\n  }\n\n  *reversed(): Iterable<Square> {\n    let lo = this.lo;\n    let hi = this.hi;\n    while (hi !== 0) {\n      const idx = 31 - Math.clz32(hi);\n      hi ^= 1 << idx;\n      yield 32 + idx;\n    }\n    while (lo !== 0) {\n      const idx = 31 - Math.clz32(lo);\n      lo ^= 1 << idx;\n      yield idx;\n    }\n  }\n}\n","import { FILE_NAMES, isDrop, isNormal, RANK_NAMES, } from './types.js';\nexport const defined = (v) => v !== undefined;\nexport const opposite = (color) => (color === 'white' ? 'black' : 'white');\nexport const squareRank = (square) => square >> 3;\nexport const squareFile = (square) => square & 0x7;\nexport const squareFromCoords = (file, rank) => 0 <= file && file < 8 && 0 <= rank && rank < 8 ? file + 8 * rank : undefined;\nexport const roleToChar = (role) => {\n    switch (role) {\n        case 'pawn':\n            return 'p';\n        case 'knight':\n            return 'n';\n        case 'bishop':\n            return 'b';\n        case 'rook':\n            return 'r';\n        case 'queen':\n            return 'q';\n        case 'king':\n            return 'k';\n    }\n};\nexport function charToRole(ch) {\n    switch (ch.toLowerCase()) {\n        case 'p':\n            return 'pawn';\n        case 'n':\n            return 'knight';\n        case 'b':\n            return 'bishop';\n        case 'r':\n            return 'rook';\n        case 'q':\n            return 'queen';\n        case 'k':\n            return 'king';\n        default:\n            return;\n    }\n}\nexport function parseSquare(str) {\n    if (str.length !== 2)\n        return;\n    return squareFromCoords(str.charCodeAt(0) - 'a'.charCodeAt(0), str.charCodeAt(1) - '1'.charCodeAt(0));\n}\nexport const makeSquare = (square) => (FILE_NAMES[squareFile(square)] + RANK_NAMES[squareRank(square)]);\nexport const parseUci = (str) => {\n    if (str[1] === '@' && str.length === 4) {\n        const role = charToRole(str[0]);\n        const to = parseSquare(str.slice(2));\n        if (role && defined(to))\n            return { role, to };\n    }\n    else if (str.length === 4 || str.length === 5) {\n        const from = parseSquare(str.slice(0, 2));\n        const to = parseSquare(str.slice(2, 4));\n        let promotion;\n        if (str.length === 5) {\n            promotion = charToRole(str[4]);\n            if (!promotion)\n                return;\n        }\n        if (defined(from) && defined(to))\n            return { from, to, promotion };\n    }\n    return;\n};\nexport const moveEquals = (left, right) => {\n    if (left.to !== right.to)\n        return false;\n    if (isDrop(left))\n        return isDrop(right) && left.role === right.role;\n    else\n        return isNormal(right) && left.from === right.from && left.promotion === right.promotion;\n};\n/**\n * Converts a move to UCI notation, like `g1f3` for a normal move,\n * `a7a8q` for promotion to a queen, and `Q@f7` for a Crazyhouse drop.\n */\nexport const makeUci = (move) => isDrop(move)\n    ? `${roleToChar(move.role).toUpperCase()}@${makeSquare(move.to)}`\n    : makeSquare(move.from) + makeSquare(move.to) + (move.promotion ? roleToChar(move.promotion) : '');\nexport const kingCastlesTo = (color, side) => color === 'white' ? (side === 'a' ? 2 : 6) : side === 'a' ? 58 : 62;\nexport const rookCastlesTo = (color, side) => color === 'white' ? (side === 'a' ? 3 : 5) : side === 'a' ? 59 : 61;\n//# sourceMappingURL=util.js.map","import {\n  CastlingSide,\n  Color,\n  FILE_NAMES,\n  isDrop,\n  isNormal,\n  Move,\n  RANK_NAMES,\n  Role,\n  Square,\n  SquareName,\n} from './types.js';\n\nexport const defined = <A>(v: A | undefined): v is A => v !== undefined;\n\nexport const opposite = (color: Color): Color => (color === 'white' ? 'black' : 'white');\n\nexport const squareRank = (square: Square): number => square >> 3;\n\nexport const squareFile = (square: Square): number => square & 0x7;\n\nexport const squareFromCoords = (file: number, rank: number): Square | undefined =>\n  0 <= file && file < 8 && 0 <= rank && rank < 8 ? file + 8 * rank : undefined;\n\nexport const roleToChar = (role: Role): string => {\n  switch (role) {\n    case 'pawn':\n      return 'p';\n    case 'knight':\n      return 'n';\n    case 'bishop':\n      return 'b';\n    case 'rook':\n      return 'r';\n    case 'queen':\n      return 'q';\n    case 'king':\n      return 'k';\n  }\n};\n\nexport function charToRole(ch: 'p' | 'n' | 'b' | 'r' | 'q' | 'k' | 'P' | 'N' | 'B' | 'R' | 'Q' | 'K'): Role;\nexport function charToRole(ch: string): Role | undefined;\nexport function charToRole(ch: string): Role | undefined {\n  switch (ch.toLowerCase()) {\n    case 'p':\n      return 'pawn';\n    case 'n':\n      return 'knight';\n    case 'b':\n      return 'bishop';\n    case 'r':\n      return 'rook';\n    case 'q':\n      return 'queen';\n    case 'k':\n      return 'king';\n    default:\n      return;\n  }\n}\n\nexport function parseSquare(str: SquareName): Square;\nexport function parseSquare(str: string): Square | undefined;\nexport function parseSquare(str: string): Square | undefined {\n  if (str.length !== 2) return;\n  return squareFromCoords(str.charCodeAt(0) - 'a'.charCodeAt(0), str.charCodeAt(1) - '1'.charCodeAt(0));\n}\n\nexport const makeSquare = (square: Square): SquareName =>\n  (FILE_NAMES[squareFile(square)] + RANK_NAMES[squareRank(square)]) as SquareName;\n\nexport const parseUci = (str: string): Move | undefined => {\n  if (str[1] === '@' && str.length === 4) {\n    const role = charToRole(str[0]);\n    const to = parseSquare(str.slice(2));\n    if (role && defined(to)) return { role, to };\n  } else if (str.length === 4 || str.length === 5) {\n    const from = parseSquare(str.slice(0, 2));\n    const to = parseSquare(str.slice(2, 4));\n    let promotion: Role | undefined;\n    if (str.length === 5) {\n      promotion = charToRole(str[4]);\n      if (!promotion) return;\n    }\n    if (defined(from) && defined(to)) return { from, to, promotion };\n  }\n  return;\n};\n\nexport const moveEquals = (left: Move, right: Move): boolean => {\n  if (left.to !== right.to) return false;\n  if (isDrop(left)) return isDrop(right) && left.role === right.role;\n  else return isNormal(right) && left.from === right.from && left.promotion === right.promotion;\n};\n\n/**\n * Converts a move to UCI notation, like `g1f3` for a normal move,\n * `a7a8q` for promotion to a queen, and `Q@f7` for a Crazyhouse drop.\n */\nexport const makeUci = (move: Move): string =>\n  isDrop(move)\n    ? `${roleToChar(move.role).toUpperCase()}@${makeSquare(move.to)}`\n    : makeSquare(move.from) + makeSquare(move.to) + (move.promotion ? roleToChar(move.promotion) : '');\n\nexport const kingCastlesTo = (color: Color, side: CastlingSide): Square =>\n  color === 'white' ? (side === 'a' ? 2 : 6) : side === 'a' ? 58 : 62;\n\nexport const rookCastlesTo = (color: Color, side: CastlingSide): Square =>\n  color === 'white' ? (side === 'a' ? 3 : 5) : side === 'a' ? 59 : 61;\n","export const FILE_NAMES = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\nexport const RANK_NAMES = ['1', '2', '3', '4', '5', '6', '7', '8'];\nexport const COLORS = ['white', 'black'];\nexport const ROLES = ['pawn', 'knight', 'bishop', 'rook', 'queen', 'king'];\nexport const CASTLING_SIDES = ['a', 'h'];\nexport const isDrop = (v) => 'role' in v;\nexport const isNormal = (v) => 'from' in v;\nexport const RULES = [\n    'chess',\n    'antichess',\n    'kingofthehill',\n    '3check',\n    'atomic',\n    'horde',\n    'racingkings',\n    'crazyhouse',\n];\n//# sourceMappingURL=types.js.map","export const FILE_NAMES = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] as const;\n\nexport type FileName = (typeof FILE_NAMES)[number];\n\nexport const RANK_NAMES = ['1', '2', '3', '4', '5', '6', '7', '8'] as const;\n\nexport type RankName = (typeof RANK_NAMES)[number];\n\nexport type Square = number;\n\nexport type SquareName = `${FileName}${RankName}`;\n\n/**\n * Indexable by square indices.\n */\nexport type BySquare<T> = T[];\n\nexport const COLORS = ['white', 'black'] as const;\n\nexport type Color = (typeof COLORS)[number];\n\n/**\n * Indexable by `white` and `black`.\n */\nexport type ByColor<T> = {\n  [color in Color]: T;\n};\n\nexport const ROLES = ['pawn', 'knight', 'bishop', 'rook', 'queen', 'king'] as const;\n\nexport type Role = (typeof ROLES)[number];\n\n/**\n * Indexable by `pawn`, `knight`, `bishop`, `rook`, `queen`, and `king`.\n */\nexport type ByRole<T> = {\n  [role in Role]: T;\n};\n\nexport const CASTLING_SIDES = ['a', 'h'] as const;\n\nexport type CastlingSide = (typeof CASTLING_SIDES)[number];\n\n/**\n * Indexable by `a` and `h`.\n */\nexport type ByCastlingSide<T> = {\n  [side in CastlingSide]: T;\n};\n\nexport interface Piece {\n  role: Role;\n  color: Color;\n  promoted?: boolean;\n}\n\nexport interface NormalMove {\n  from: Square;\n  to: Square;\n  promotion?: Role;\n}\n\nexport interface DropMove {\n  role: Role;\n  to: Square;\n}\n\nexport type Move = NormalMove | DropMove;\n\nexport const isDrop = (v: Move): v is DropMove => 'role' in v;\n\nexport const isNormal = (v: Move): v is NormalMove => 'from' in v;\n\nexport const RULES = [\n  'chess',\n  'antichess',\n  'kingofthehill',\n  '3check',\n  'atomic',\n  'horde',\n  'racingkings',\n  'crazyhouse',\n] as const;\n\nexport type Rules = (typeof RULES)[number];\n\nexport interface Outcome {\n  winner: Color | undefined;\n}\n","import { SquareSet } from './squareSet.js';\nimport { COLORS, ROLES } from './types.js';\n/**\n * Piece positions on a board.\n *\n * Properties are sets of squares, like `board.occupied` for all occupied\n * squares, `board[color]` for all pieces of that color, and `board[role]`\n * for all pieces of that role. When modifying the properties directly, take\n * care to keep them consistent.\n */\nexport class Board {\n    constructor() { }\n    static default() {\n        const board = new Board();\n        board.reset();\n        return board;\n    }\n    /**\n     * Resets all pieces to the default starting position for standard chess.\n     */\n    reset() {\n        this.occupied = new SquareSet(0xffff, 4294901760);\n        this.promoted = SquareSet.empty();\n        this.white = new SquareSet(0xffff, 0);\n        this.black = new SquareSet(0, 4294901760);\n        this.pawn = new SquareSet(0xff00, 16711680);\n        this.knight = new SquareSet(0x42, 1107296256);\n        this.bishop = new SquareSet(0x24, 603979776);\n        this.rook = new SquareSet(0x81, 2164260864);\n        this.queen = new SquareSet(0x8, 134217728);\n        this.king = new SquareSet(0x10, 268435456);\n    }\n    static empty() {\n        const board = new Board();\n        board.clear();\n        return board;\n    }\n    clear() {\n        this.occupied = SquareSet.empty();\n        this.promoted = SquareSet.empty();\n        for (const color of COLORS)\n            this[color] = SquareSet.empty();\n        for (const role of ROLES)\n            this[role] = SquareSet.empty();\n    }\n    clone() {\n        const board = new Board();\n        board.occupied = this.occupied;\n        board.promoted = this.promoted;\n        for (const color of COLORS)\n            board[color] = this[color];\n        for (const role of ROLES)\n            board[role] = this[role];\n        return board;\n    }\n    getColor(square) {\n        if (this.white.has(square))\n            return 'white';\n        if (this.black.has(square))\n            return 'black';\n        return;\n    }\n    getRole(square) {\n        for (const role of ROLES) {\n            if (this[role].has(square))\n                return role;\n        }\n        return;\n    }\n    get(square) {\n        const color = this.getColor(square);\n        if (!color)\n            return;\n        const role = this.getRole(square);\n        const promoted = this.promoted.has(square);\n        return { color, role, promoted };\n    }\n    /**\n     * Removes and returns the piece from the given `square`, if any.\n     */\n    take(square) {\n        const piece = this.get(square);\n        if (piece) {\n            this.occupied = this.occupied.without(square);\n            this[piece.color] = this[piece.color].without(square);\n            this[piece.role] = this[piece.role].without(square);\n            if (piece.promoted)\n                this.promoted = this.promoted.without(square);\n        }\n        return piece;\n    }\n    /**\n     * Put `piece` onto `square`, potentially replacing an existing piece.\n     * Returns the existing piece, if any.\n     */\n    set(square, piece) {\n        const old = this.take(square);\n        this.occupied = this.occupied.with(square);\n        this[piece.color] = this[piece.color].with(square);\n        this[piece.role] = this[piece.role].with(square);\n        if (piece.promoted)\n            this.promoted = this.promoted.with(square);\n        return old;\n    }\n    has(square) {\n        return this.occupied.has(square);\n    }\n    *[Symbol.iterator]() {\n        for (const square of this.occupied) {\n            yield [square, this.get(square)];\n        }\n    }\n    pieces(color, role) {\n        return this[color].intersect(this[role]);\n    }\n    rooksAndQueens() {\n        return this.rook.union(this.queen);\n    }\n    bishopsAndQueens() {\n        return this.bishop.union(this.queen);\n    }\n    /**\n     * Finds the unique king of the given `color`, if any.\n     */\n    kingOf(color) {\n        return this.pieces(color, 'king').singleSquare();\n    }\n}\nexport const boardEquals = (left, right) => left.white.equals(right.white)\n    && left.promoted.equals(right.promoted)\n    && ROLES.every(role => left[role].equals(right[role]));\n//# sourceMappingURL=board.js.map","import { SquareSet } from './squareSet.js';\nimport { ByColor, ByRole, Color, COLORS, Piece, Role, ROLES, Square } from './types.js';\n\n/**\n * Piece positions on a board.\n *\n * Properties are sets of squares, like `board.occupied` for all occupied\n * squares, `board[color]` for all pieces of that color, and `board[role]`\n * for all pieces of that role. When modifying the properties directly, take\n * care to keep them consistent.\n */\nexport class Board implements Iterable<[Square, Piece]>, ByRole<SquareSet>, ByColor<SquareSet> {\n  /**\n   * All occupied squares.\n   */\n  occupied: SquareSet;\n  /**\n   * All squares occupied by pieces known to be promoted. This information is\n   * relevant in chess variants like Crazyhouse.\n   */\n  promoted: SquareSet;\n\n  white: SquareSet;\n  black: SquareSet;\n\n  pawn: SquareSet;\n  knight: SquareSet;\n  bishop: SquareSet;\n  rook: SquareSet;\n  queen: SquareSet;\n  king: SquareSet;\n\n  private constructor() {}\n\n  static default(): Board {\n    const board = new Board();\n    board.reset();\n    return board;\n  }\n\n  /**\n   * Resets all pieces to the default starting position for standard chess.\n   */\n  reset(): void {\n    this.occupied = new SquareSet(0xffff, 0xffff_0000);\n    this.promoted = SquareSet.empty();\n    this.white = new SquareSet(0xffff, 0);\n    this.black = new SquareSet(0, 0xffff_0000);\n    this.pawn = new SquareSet(0xff00, 0x00ff_0000);\n    this.knight = new SquareSet(0x42, 0x4200_0000);\n    this.bishop = new SquareSet(0x24, 0x2400_0000);\n    this.rook = new SquareSet(0x81, 0x8100_0000);\n    this.queen = new SquareSet(0x8, 0x0800_0000);\n    this.king = new SquareSet(0x10, 0x1000_0000);\n  }\n\n  static empty(): Board {\n    const board = new Board();\n    board.clear();\n    return board;\n  }\n\n  clear(): void {\n    this.occupied = SquareSet.empty();\n    this.promoted = SquareSet.empty();\n    for (const color of COLORS) this[color] = SquareSet.empty();\n    for (const role of ROLES) this[role] = SquareSet.empty();\n  }\n\n  clone(): Board {\n    const board = new Board();\n    board.occupied = this.occupied;\n    board.promoted = this.promoted;\n    for (const color of COLORS) board[color] = this[color];\n    for (const role of ROLES) board[role] = this[role];\n    return board;\n  }\n\n  getColor(square: Square): Color | undefined {\n    if (this.white.has(square)) return 'white';\n    if (this.black.has(square)) return 'black';\n    return;\n  }\n\n  getRole(square: Square): Role | undefined {\n    for (const role of ROLES) {\n      if (this[role].has(square)) return role;\n    }\n    return;\n  }\n\n  get(square: Square): Piece | undefined {\n    const color = this.getColor(square);\n    if (!color) return;\n    const role = this.getRole(square)!;\n    const promoted = this.promoted.has(square);\n    return { color, role, promoted };\n  }\n\n  /**\n   * Removes and returns the piece from the given `square`, if any.\n   */\n  take(square: Square): Piece | undefined {\n    const piece = this.get(square);\n    if (piece) {\n      this.occupied = this.occupied.without(square);\n      this[piece.color] = this[piece.color].without(square);\n      this[piece.role] = this[piece.role].without(square);\n      if (piece.promoted) this.promoted = this.promoted.without(square);\n    }\n    return piece;\n  }\n\n  /**\n   * Put `piece` onto `square`, potentially replacing an existing piece.\n   * Returns the existing piece, if any.\n   */\n  set(square: Square, piece: Piece): Piece | undefined {\n    const old = this.take(square);\n    this.occupied = this.occupied.with(square);\n    this[piece.color] = this[piece.color].with(square);\n    this[piece.role] = this[piece.role].with(square);\n    if (piece.promoted) this.promoted = this.promoted.with(square);\n    return old;\n  }\n\n  has(square: Square): boolean {\n    return this.occupied.has(square);\n  }\n\n  *[Symbol.iterator](): Iterator<[Square, Piece]> {\n    for (const square of this.occupied) {\n      yield [square, this.get(square)!];\n    }\n  }\n\n  pieces(color: Color, role: Role): SquareSet {\n    return this[color].intersect(this[role]);\n  }\n\n  rooksAndQueens(): SquareSet {\n    return this.rook.union(this.queen);\n  }\n\n  bishopsAndQueens(): SquareSet {\n    return this.bishop.union(this.queen);\n  }\n\n  /**\n   * Finds the unique king of the given `color`, if any.\n   */\n  kingOf(color: Color): Square | undefined {\n    return this.pieces(color, 'king').singleSquare();\n  }\n}\n\nexport const boardEquals = (left: Board, right: Board): boolean =>\n  left.white.equals(right.white)\n  && left.promoted.equals(right.promoted)\n  && ROLES.every(role => left[role].equals(right[role]));\n","import { Result } from '@badrap/result';\nimport { Board } from './board.js';\nimport { Material, RemainingChecks } from './setup.js';\nimport { SquareSet } from './squareSet.js';\nimport { COLORS, FILE_NAMES, ROLES } from './types.js';\nimport { charToRole, defined, makeSquare, parseSquare, roleToChar, squareFile, squareFromCoords } from './util.js';\nexport const INITIAL_BOARD_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\nexport const INITIAL_EPD = INITIAL_BOARD_FEN + ' w KQkq -';\nexport const INITIAL_FEN = INITIAL_EPD + ' 0 1';\nexport const EMPTY_BOARD_FEN = '8/8/8/8/8/8/8/8';\nexport const EMPTY_EPD = EMPTY_BOARD_FEN + ' w - -';\nexport const EMPTY_FEN = EMPTY_EPD + ' 0 1';\nexport var InvalidFen;\n(function (InvalidFen) {\n    InvalidFen[\"Fen\"] = \"ERR_FEN\";\n    InvalidFen[\"Board\"] = \"ERR_BOARD\";\n    InvalidFen[\"Pockets\"] = \"ERR_POCKETS\";\n    InvalidFen[\"Turn\"] = \"ERR_TURN\";\n    InvalidFen[\"Castling\"] = \"ERR_CASTLING\";\n    InvalidFen[\"EpSquare\"] = \"ERR_EP_SQUARE\";\n    InvalidFen[\"RemainingChecks\"] = \"ERR_REMAINING_CHECKS\";\n    InvalidFen[\"Halfmoves\"] = \"ERR_HALFMOVES\";\n    InvalidFen[\"Fullmoves\"] = \"ERR_FULLMOVES\";\n})(InvalidFen || (InvalidFen = {}));\nexport class FenError extends Error {\n}\nconst nthIndexOf = (haystack, needle, n) => {\n    let index = haystack.indexOf(needle);\n    while (n-- > 0) {\n        if (index === -1)\n            break;\n        index = haystack.indexOf(needle, index + needle.length);\n    }\n    return index;\n};\nconst parseSmallUint = (str) => (/^\\d{1,4}$/.test(str) ? parseInt(str, 10) : undefined);\nconst charToPiece = (ch) => {\n    const role = charToRole(ch);\n    return role && { role, color: ch.toLowerCase() === ch ? 'black' : 'white' };\n};\nexport const parseBoardFen = (boardPart) => {\n    const board = Board.empty();\n    let rank = 7;\n    let file = 0;\n    for (let i = 0; i < boardPart.length; i++) {\n        const c = boardPart[i];\n        if (c === '/' && file === 8) {\n            file = 0;\n            rank--;\n        }\n        else {\n            const step = parseInt(c, 10);\n            if (step > 0)\n                file += step;\n            else {\n                if (file >= 8 || rank < 0)\n                    return Result.err(new FenError(InvalidFen.Board));\n                const square = file + rank * 8;\n                const piece = charToPiece(c);\n                if (!piece)\n                    return Result.err(new FenError(InvalidFen.Board));\n                if (boardPart[i + 1] === '~') {\n                    piece.promoted = true;\n                    i++;\n                }\n                board.set(square, piece);\n                file++;\n            }\n        }\n    }\n    if (rank !== 0 || file !== 8)\n        return Result.err(new FenError(InvalidFen.Board));\n    return Result.ok(board);\n};\nexport const parsePockets = (pocketPart) => {\n    if (pocketPart.length > 64)\n        return Result.err(new FenError(InvalidFen.Pockets));\n    const pockets = Material.empty();\n    for (const c of pocketPart) {\n        const piece = charToPiece(c);\n        if (!piece)\n            return Result.err(new FenError(InvalidFen.Pockets));\n        pockets[piece.color][piece.role]++;\n    }\n    return Result.ok(pockets);\n};\nexport const parseCastlingFen = (board, castlingPart) => {\n    let castlingRights = SquareSet.empty();\n    if (castlingPart === '-')\n        return Result.ok(castlingRights);\n    for (const c of castlingPart) {\n        const lower = c.toLowerCase();\n        const color = c === lower ? 'black' : 'white';\n        const rank = color === 'white' ? 0 : 7;\n        if ('a' <= lower && lower <= 'h') {\n            castlingRights = castlingRights.with(squareFromCoords(lower.charCodeAt(0) - 'a'.charCodeAt(0), rank));\n        }\n        else if (lower === 'k' || lower === 'q') {\n            const rooksAndKings = board[color].intersect(SquareSet.backrank(color)).intersect(board.rook.union(board.king));\n            const candidate = lower === 'k' ? rooksAndKings.last() : rooksAndKings.first();\n            castlingRights = castlingRights.with(defined(candidate) && board.rook.has(candidate) ? candidate : squareFromCoords(lower === 'k' ? 7 : 0, rank));\n        }\n        else\n            return Result.err(new FenError(InvalidFen.Castling));\n    }\n    if (COLORS.some(color => SquareSet.backrank(color).intersect(castlingRights).size() > 2)) {\n        return Result.err(new FenError(InvalidFen.Castling));\n    }\n    return Result.ok(castlingRights);\n};\nexport const parseRemainingChecks = (part) => {\n    const parts = part.split('+');\n    if (parts.length === 3 && parts[0] === '') {\n        const white = parseSmallUint(parts[1]);\n        const black = parseSmallUint(parts[2]);\n        if (!defined(white) || white > 3 || !defined(black) || black > 3) {\n            return Result.err(new FenError(InvalidFen.RemainingChecks));\n        }\n        return Result.ok(new RemainingChecks(3 - white, 3 - black));\n    }\n    else if (parts.length === 2) {\n        const white = parseSmallUint(parts[0]);\n        const black = parseSmallUint(parts[1]);\n        if (!defined(white) || white > 3 || !defined(black) || black > 3) {\n            return Result.err(new FenError(InvalidFen.RemainingChecks));\n        }\n        return Result.ok(new RemainingChecks(white, black));\n    }\n    else\n        return Result.err(new FenError(InvalidFen.RemainingChecks));\n};\nexport const parseFen = (fen) => {\n    const parts = fen.split(/[\\s_]+/);\n    const boardPart = parts.shift();\n    // Board and pockets\n    let board;\n    let pockets = Result.ok(undefined);\n    if (boardPart.endsWith(']')) {\n        const pocketStart = boardPart.indexOf('[');\n        if (pocketStart === -1)\n            return Result.err(new FenError(InvalidFen.Fen));\n        board = parseBoardFen(boardPart.slice(0, pocketStart));\n        pockets = parsePockets(boardPart.slice(pocketStart + 1, -1));\n    }\n    else {\n        const pocketStart = nthIndexOf(boardPart, '/', 7);\n        if (pocketStart === -1)\n            board = parseBoardFen(boardPart);\n        else {\n            board = parseBoardFen(boardPart.slice(0, pocketStart));\n            pockets = parsePockets(boardPart.slice(pocketStart + 1));\n        }\n    }\n    // Turn\n    let turn;\n    const turnPart = parts.shift();\n    if (!defined(turnPart) || turnPart === 'w')\n        turn = 'white';\n    else if (turnPart === 'b')\n        turn = 'black';\n    else\n        return Result.err(new FenError(InvalidFen.Turn));\n    return board.chain(board => {\n        // Castling\n        const castlingPart = parts.shift();\n        const castlingRights = defined(castlingPart) ? parseCastlingFen(board, castlingPart) : Result.ok(SquareSet.empty());\n        // En passant square\n        const epPart = parts.shift();\n        let epSquare;\n        if (defined(epPart) && epPart !== '-') {\n            epSquare = parseSquare(epPart);\n            if (!defined(epSquare))\n                return Result.err(new FenError(InvalidFen.EpSquare));\n        }\n        // Halfmoves or remaining checks\n        let halfmovePart = parts.shift();\n        let earlyRemainingChecks;\n        if (defined(halfmovePart) && halfmovePart.includes('+')) {\n            earlyRemainingChecks = parseRemainingChecks(halfmovePart);\n            halfmovePart = parts.shift();\n        }\n        const halfmoves = defined(halfmovePart) ? parseSmallUint(halfmovePart) : 0;\n        if (!defined(halfmoves))\n            return Result.err(new FenError(InvalidFen.Halfmoves));\n        const fullmovesPart = parts.shift();\n        const fullmoves = defined(fullmovesPart) ? parseSmallUint(fullmovesPart) : 1;\n        if (!defined(fullmoves))\n            return Result.err(new FenError(InvalidFen.Fullmoves));\n        const remainingChecksPart = parts.shift();\n        let remainingChecks = Result.ok(undefined);\n        if (defined(remainingChecksPart)) {\n            if (defined(earlyRemainingChecks))\n                return Result.err(new FenError(InvalidFen.RemainingChecks));\n            remainingChecks = parseRemainingChecks(remainingChecksPart);\n        }\n        else if (defined(earlyRemainingChecks)) {\n            remainingChecks = earlyRemainingChecks;\n        }\n        if (parts.length > 0)\n            return Result.err(new FenError(InvalidFen.Fen));\n        return pockets.chain(pockets => castlingRights.chain(castlingRights => remainingChecks.map(remainingChecks => {\n            return {\n                board,\n                pockets,\n                turn,\n                castlingRights,\n                remainingChecks,\n                epSquare,\n                halfmoves,\n                fullmoves: Math.max(1, fullmoves),\n            };\n        })));\n    });\n};\nexport const parsePiece = (str) => {\n    if (!str)\n        return;\n    const piece = charToPiece(str[0]);\n    if (!piece)\n        return;\n    if (str.length === 2 && str[1] === '~')\n        piece.promoted = true;\n    else if (str.length > 1)\n        return;\n    return piece;\n};\nexport const makePiece = (piece) => {\n    let r = roleToChar(piece.role);\n    if (piece.color === 'white')\n        r = r.toUpperCase();\n    if (piece.promoted)\n        r += '~';\n    return r;\n};\nexport const makeBoardFen = (board) => {\n    let fen = '';\n    let empty = 0;\n    for (let rank = 7; rank >= 0; rank--) {\n        for (let file = 0; file < 8; file++) {\n            const square = file + rank * 8;\n            const piece = board.get(square);\n            if (!piece)\n                empty++;\n            else {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                fen += makePiece(piece);\n            }\n            if (file === 7) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                if (rank !== 0)\n                    fen += '/';\n            }\n        }\n    }\n    return fen;\n};\nexport const makePocket = (material) => ROLES.map(role => roleToChar(role).repeat(material[role])).join('');\nexport const makePockets = (pocket) => makePocket(pocket.white).toUpperCase() + makePocket(pocket.black);\nexport const makeCastlingFen = (board, castlingRights) => {\n    let fen = '';\n    for (const color of COLORS) {\n        const backrank = SquareSet.backrank(color);\n        let king = board.kingOf(color);\n        if (defined(king) && !backrank.has(king))\n            king = undefined;\n        const candidates = board.pieces(color, 'rook').intersect(backrank);\n        for (const rook of castlingRights.intersect(backrank).reversed()) {\n            if (rook === candidates.first() && defined(king) && rook < king) {\n                fen += color === 'white' ? 'Q' : 'q';\n            }\n            else if (rook === candidates.last() && defined(king) && king < rook) {\n                fen += color === 'white' ? 'K' : 'k';\n            }\n            else {\n                const file = FILE_NAMES[squareFile(rook)];\n                fen += color === 'white' ? file.toUpperCase() : file;\n            }\n        }\n    }\n    return fen || '-';\n};\nexport const makeRemainingChecks = (checks) => `${checks.white}+${checks.black}`;\nexport const makeFen = (setup, opts) => [\n    makeBoardFen(setup.board) + (setup.pockets ? `[${makePockets(setup.pockets)}]` : ''),\n    setup.turn[0],\n    makeCastlingFen(setup.board, setup.castlingRights),\n    defined(setup.epSquare) ? makeSquare(setup.epSquare) : '-',\n    ...(setup.remainingChecks ? [makeRemainingChecks(setup.remainingChecks)] : []),\n    ...((opts === null || opts === void 0 ? void 0 : opts.epd) ? [] : [Math.max(0, Math.min(setup.halfmoves, 9999)), Math.max(1, Math.min(setup.fullmoves, 9999))]),\n].join(' ');\n//# sourceMappingURL=fen.js.map","import { Result } from '@badrap/result';\nimport { Board } from './board.js';\nimport { Material, MaterialSide, RemainingChecks, Setup } from './setup.js';\nimport { SquareSet } from './squareSet.js';\nimport { Color, COLORS, FILE_NAMES, Piece, ROLES, Square } from './types.js';\nimport { charToRole, defined, makeSquare, parseSquare, roleToChar, squareFile, squareFromCoords } from './util.js';\n\nexport const INITIAL_BOARD_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\nexport const INITIAL_EPD = INITIAL_BOARD_FEN + ' w KQkq -';\nexport const INITIAL_FEN = INITIAL_EPD + ' 0 1';\nexport const EMPTY_BOARD_FEN = '8/8/8/8/8/8/8/8';\nexport const EMPTY_EPD = EMPTY_BOARD_FEN + ' w - -';\nexport const EMPTY_FEN = EMPTY_EPD + ' 0 1';\n\nexport enum InvalidFen {\n  Fen = 'ERR_FEN',\n  Board = 'ERR_BOARD',\n  Pockets = 'ERR_POCKETS',\n  Turn = 'ERR_TURN',\n  Castling = 'ERR_CASTLING',\n  EpSquare = 'ERR_EP_SQUARE',\n  RemainingChecks = 'ERR_REMAINING_CHECKS',\n  Halfmoves = 'ERR_HALFMOVES',\n  Fullmoves = 'ERR_FULLMOVES',\n}\n\nexport class FenError extends Error {}\n\nconst nthIndexOf = (haystack: string, needle: string, n: number): number => {\n  let index = haystack.indexOf(needle);\n  while (n-- > 0) {\n    if (index === -1) break;\n    index = haystack.indexOf(needle, index + needle.length);\n  }\n  return index;\n};\n\nconst parseSmallUint = (str: string): number | undefined => (/^\\d{1,4}$/.test(str) ? parseInt(str, 10) : undefined);\n\nconst charToPiece = (ch: string): Piece | undefined => {\n  const role = charToRole(ch);\n  return role && { role, color: ch.toLowerCase() === ch ? 'black' : 'white' };\n};\n\nexport const parseBoardFen = (boardPart: string): Result<Board, FenError> => {\n  const board = Board.empty();\n  let rank = 7;\n  let file = 0;\n  for (let i = 0; i < boardPart.length; i++) {\n    const c = boardPart[i];\n    if (c === '/' && file === 8) {\n      file = 0;\n      rank--;\n    } else {\n      const step = parseInt(c, 10);\n      if (step > 0) file += step;\n      else {\n        if (file >= 8 || rank < 0) return Result.err(new FenError(InvalidFen.Board));\n        const square = file + rank * 8;\n        const piece = charToPiece(c);\n        if (!piece) return Result.err(new FenError(InvalidFen.Board));\n        if (boardPart[i + 1] === '~') {\n          piece.promoted = true;\n          i++;\n        }\n        board.set(square, piece);\n        file++;\n      }\n    }\n  }\n  if (rank !== 0 || file !== 8) return Result.err(new FenError(InvalidFen.Board));\n  return Result.ok(board);\n};\n\nexport const parsePockets = (pocketPart: string): Result<Material, FenError> => {\n  if (pocketPart.length > 64) return Result.err(new FenError(InvalidFen.Pockets));\n  const pockets = Material.empty();\n  for (const c of pocketPart) {\n    const piece = charToPiece(c);\n    if (!piece) return Result.err(new FenError(InvalidFen.Pockets));\n    pockets[piece.color][piece.role]++;\n  }\n  return Result.ok(pockets);\n};\n\nexport const parseCastlingFen = (board: Board, castlingPart: string): Result<SquareSet, FenError> => {\n  let castlingRights = SquareSet.empty();\n  if (castlingPart === '-') return Result.ok(castlingRights);\n\n  for (const c of castlingPart) {\n    const lower = c.toLowerCase();\n    const color = c === lower ? 'black' : 'white';\n    const rank = color === 'white' ? 0 : 7;\n    if ('a' <= lower && lower <= 'h') {\n      castlingRights = castlingRights.with(squareFromCoords(lower.charCodeAt(0) - 'a'.charCodeAt(0), rank)!);\n    } else if (lower === 'k' || lower === 'q') {\n      const rooksAndKings = board[color].intersect(SquareSet.backrank(color)).intersect(board.rook.union(board.king));\n      const candidate = lower === 'k' ? rooksAndKings.last() : rooksAndKings.first();\n      castlingRights = castlingRights.with(\n        defined(candidate) && board.rook.has(candidate) ? candidate : squareFromCoords(lower === 'k' ? 7 : 0, rank)!,\n      );\n    } else return Result.err(new FenError(InvalidFen.Castling));\n  }\n\n  if (COLORS.some(color => SquareSet.backrank(color).intersect(castlingRights).size() > 2)) {\n    return Result.err(new FenError(InvalidFen.Castling));\n  }\n\n  return Result.ok(castlingRights);\n};\n\nexport const parseRemainingChecks = (part: string): Result<RemainingChecks, FenError> => {\n  const parts = part.split('+');\n  if (parts.length === 3 && parts[0] === '') {\n    const white = parseSmallUint(parts[1]);\n    const black = parseSmallUint(parts[2]);\n    if (!defined(white) || white > 3 || !defined(black) || black > 3) {\n      return Result.err(new FenError(InvalidFen.RemainingChecks));\n    }\n    return Result.ok(new RemainingChecks(3 - white, 3 - black));\n  } else if (parts.length === 2) {\n    const white = parseSmallUint(parts[0]);\n    const black = parseSmallUint(parts[1]);\n    if (!defined(white) || white > 3 || !defined(black) || black > 3) {\n      return Result.err(new FenError(InvalidFen.RemainingChecks));\n    }\n    return Result.ok(new RemainingChecks(white, black));\n  } else return Result.err(new FenError(InvalidFen.RemainingChecks));\n};\n\nexport const parseFen = (fen: string): Result<Setup, FenError> => {\n  const parts = fen.split(/[\\s_]+/);\n  const boardPart = parts.shift()!;\n\n  // Board and pockets\n  let board: Result<Board, FenError>;\n  let pockets = Result.ok<Material | undefined, FenError>(undefined);\n  if (boardPart.endsWith(']')) {\n    const pocketStart = boardPart.indexOf('[');\n    if (pocketStart === -1) return Result.err(new FenError(InvalidFen.Fen));\n    board = parseBoardFen(boardPart.slice(0, pocketStart));\n    pockets = parsePockets(boardPart.slice(pocketStart + 1, -1));\n  } else {\n    const pocketStart = nthIndexOf(boardPart, '/', 7);\n    if (pocketStart === -1) board = parseBoardFen(boardPart);\n    else {\n      board = parseBoardFen(boardPart.slice(0, pocketStart));\n      pockets = parsePockets(boardPart.slice(pocketStart + 1));\n    }\n  }\n\n  // Turn\n  let turn: Color;\n  const turnPart = parts.shift();\n  if (!defined(turnPart) || turnPart === 'w') turn = 'white';\n  else if (turnPart === 'b') turn = 'black';\n  else return Result.err(new FenError(InvalidFen.Turn));\n\n  return board.chain(board => {\n    // Castling\n    const castlingPart = parts.shift();\n    const castlingRights = defined(castlingPart) ? parseCastlingFen(board, castlingPart) : Result.ok(SquareSet.empty());\n\n    // En passant square\n    const epPart = parts.shift();\n    let epSquare: Square | undefined;\n    if (defined(epPart) && epPart !== '-') {\n      epSquare = parseSquare(epPart);\n      if (!defined(epSquare)) return Result.err(new FenError(InvalidFen.EpSquare));\n    }\n\n    // Halfmoves or remaining checks\n    let halfmovePart = parts.shift();\n    let earlyRemainingChecks: Result<RemainingChecks, FenError> | undefined;\n    if (defined(halfmovePart) && halfmovePart.includes('+')) {\n      earlyRemainingChecks = parseRemainingChecks(halfmovePart);\n      halfmovePart = parts.shift();\n    }\n    const halfmoves = defined(halfmovePart) ? parseSmallUint(halfmovePart) : 0;\n    if (!defined(halfmoves)) return Result.err(new FenError(InvalidFen.Halfmoves));\n\n    const fullmovesPart = parts.shift();\n    const fullmoves = defined(fullmovesPart) ? parseSmallUint(fullmovesPart) : 1;\n    if (!defined(fullmoves)) return Result.err(new FenError(InvalidFen.Fullmoves));\n\n    const remainingChecksPart = parts.shift();\n    let remainingChecks: Result<RemainingChecks | undefined, FenError> = Result.ok(undefined);\n    if (defined(remainingChecksPart)) {\n      if (defined(earlyRemainingChecks)) return Result.err(new FenError(InvalidFen.RemainingChecks));\n      remainingChecks = parseRemainingChecks(remainingChecksPart);\n    } else if (defined(earlyRemainingChecks)) {\n      remainingChecks = earlyRemainingChecks;\n    }\n\n    if (parts.length > 0) return Result.err(new FenError(InvalidFen.Fen));\n\n    return pockets.chain(pockets =>\n      castlingRights.chain(castlingRights =>\n        remainingChecks.map(remainingChecks => {\n          return {\n            board,\n            pockets,\n            turn,\n            castlingRights,\n            remainingChecks,\n            epSquare,\n            halfmoves,\n            fullmoves: Math.max(1, fullmoves),\n          };\n        })\n      )\n    );\n  });\n};\n\nexport interface FenOpts {\n  epd?: boolean;\n}\n\nexport const parsePiece = (str: string): Piece | undefined => {\n  if (!str) return;\n  const piece = charToPiece(str[0]);\n  if (!piece) return;\n  if (str.length === 2 && str[1] === '~') piece.promoted = true;\n  else if (str.length > 1) return;\n  return piece;\n};\n\nexport const makePiece = (piece: Piece): string => {\n  let r = roleToChar(piece.role);\n  if (piece.color === 'white') r = r.toUpperCase();\n  if (piece.promoted) r += '~';\n  return r;\n};\n\nexport const makeBoardFen = (board: Board): string => {\n  let fen = '';\n  let empty = 0;\n  for (let rank = 7; rank >= 0; rank--) {\n    for (let file = 0; file < 8; file++) {\n      const square = file + rank * 8;\n      const piece = board.get(square);\n      if (!piece) empty++;\n      else {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n        fen += makePiece(piece);\n      }\n\n      if (file === 7) {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n        if (rank !== 0) fen += '/';\n      }\n    }\n  }\n  return fen;\n};\n\nexport const makePocket = (material: MaterialSide): string =>\n  ROLES.map(role => roleToChar(role).repeat(material[role])).join('');\n\nexport const makePockets = (pocket: Material): string =>\n  makePocket(pocket.white).toUpperCase() + makePocket(pocket.black);\n\nexport const makeCastlingFen = (board: Board, castlingRights: SquareSet): string => {\n  let fen = '';\n  for (const color of COLORS) {\n    const backrank = SquareSet.backrank(color);\n    let king = board.kingOf(color);\n    if (defined(king) && !backrank.has(king)) king = undefined;\n    const candidates = board.pieces(color, 'rook').intersect(backrank);\n    for (const rook of castlingRights.intersect(backrank).reversed()) {\n      if (rook === candidates.first() && defined(king) && rook < king) {\n        fen += color === 'white' ? 'Q' : 'q';\n      } else if (rook === candidates.last() && defined(king) && king < rook) {\n        fen += color === 'white' ? 'K' : 'k';\n      } else {\n        const file = FILE_NAMES[squareFile(rook)];\n        fen += color === 'white' ? file.toUpperCase() : file;\n      }\n    }\n  }\n  return fen || '-';\n};\n\nexport const makeRemainingChecks = (checks: RemainingChecks): string => `${checks.white}+${checks.black}`;\n\nexport const makeFen = (setup: Setup, opts?: FenOpts): string =>\n  [\n    makeBoardFen(setup.board) + (setup.pockets ? `[${makePockets(setup.pockets)}]` : ''),\n    setup.turn[0],\n    makeCastlingFen(setup.board, setup.castlingRights),\n    defined(setup.epSquare) ? makeSquare(setup.epSquare) : '-',\n    ...(setup.remainingChecks ? [makeRemainingChecks(setup.remainingChecks)] : []),\n    ...(opts?.epd ? [] : [Math.max(0, Math.min(setup.halfmoves, 9999)), Math.max(1, Math.min(setup.fullmoves, 9999))]),\n  ].join(' ');\n","import { Board, boardEquals } from './board.js';\nimport { SquareSet } from './squareSet.js';\nimport { ROLES } from './types.js';\nexport class MaterialSide {\n    constructor() { }\n    static empty() {\n        const m = new MaterialSide();\n        for (const role of ROLES)\n            m[role] = 0;\n        return m;\n    }\n    static fromBoard(board, color) {\n        const m = new MaterialSide();\n        for (const role of ROLES)\n            m[role] = board.pieces(color, role).size();\n        return m;\n    }\n    clone() {\n        const m = new MaterialSide();\n        for (const role of ROLES)\n            m[role] = this[role];\n        return m;\n    }\n    equals(other) {\n        return ROLES.every(role => this[role] === other[role]);\n    }\n    add(other) {\n        const m = new MaterialSide();\n        for (const role of ROLES)\n            m[role] = this[role] + other[role];\n        return m;\n    }\n    subtract(other) {\n        const m = new MaterialSide();\n        for (const role of ROLES)\n            m[role] = this[role] - other[role];\n        return m;\n    }\n    nonEmpty() {\n        return ROLES.some(role => this[role] > 0);\n    }\n    isEmpty() {\n        return !this.nonEmpty();\n    }\n    hasPawns() {\n        return this.pawn > 0;\n    }\n    hasNonPawns() {\n        return this.knight > 0 || this.bishop > 0 || this.rook > 0 || this.queen > 0 || this.king > 0;\n    }\n    size() {\n        return this.pawn + this.knight + this.bishop + this.rook + this.queen + this.king;\n    }\n}\nexport class Material {\n    constructor(white, black) {\n        this.white = white;\n        this.black = black;\n    }\n    static empty() {\n        return new Material(MaterialSide.empty(), MaterialSide.empty());\n    }\n    static fromBoard(board) {\n        return new Material(MaterialSide.fromBoard(board, 'white'), MaterialSide.fromBoard(board, 'black'));\n    }\n    clone() {\n        return new Material(this.white.clone(), this.black.clone());\n    }\n    equals(other) {\n        return this.white.equals(other.white) && this.black.equals(other.black);\n    }\n    add(other) {\n        return new Material(this.white.add(other.white), this.black.add(other.black));\n    }\n    subtract(other) {\n        return new Material(this.white.subtract(other.white), this.black.subtract(other.black));\n    }\n    count(role) {\n        return this.white[role] + this.black[role];\n    }\n    size() {\n        return this.white.size() + this.black.size();\n    }\n    isEmpty() {\n        return this.white.isEmpty() && this.black.isEmpty();\n    }\n    nonEmpty() {\n        return !this.isEmpty();\n    }\n    hasPawns() {\n        return this.white.hasPawns() || this.black.hasPawns();\n    }\n    hasNonPawns() {\n        return this.white.hasNonPawns() || this.black.hasNonPawns();\n    }\n}\nexport class RemainingChecks {\n    constructor(white, black) {\n        this.white = white;\n        this.black = black;\n    }\n    static default() {\n        return new RemainingChecks(3, 3);\n    }\n    clone() {\n        return new RemainingChecks(this.white, this.black);\n    }\n    equals(other) {\n        return this.white === other.white && this.black === other.black;\n    }\n}\nexport const defaultSetup = () => ({\n    board: Board.default(),\n    pockets: undefined,\n    turn: 'white',\n    castlingRights: SquareSet.corners(),\n    epSquare: undefined,\n    remainingChecks: undefined,\n    halfmoves: 0,\n    fullmoves: 1,\n});\nexport const setupClone = (setup) => {\n    var _a, _b;\n    return ({\n        board: setup.board.clone(),\n        pockets: (_a = setup.pockets) === null || _a === void 0 ? void 0 : _a.clone(),\n        turn: setup.turn,\n        castlingRights: setup.castlingRights,\n        epSquare: setup.epSquare,\n        remainingChecks: (_b = setup.remainingChecks) === null || _b === void 0 ? void 0 : _b.clone(),\n        halfmoves: setup.halfmoves,\n        fullmoves: setup.fullmoves,\n    });\n};\nexport const setupEquals = (left, right) => {\n    var _a, _b;\n    return boardEquals(left.board, right.board)\n        && ((right.pockets && ((_a = left.pockets) === null || _a === void 0 ? void 0 : _a.equals(right.pockets))) || (!left.pockets && !right.pockets))\n        && left.turn === right.turn\n        && left.castlingRights.equals(right.castlingRights)\n        && left.epSquare === right.epSquare\n        && ((right.remainingChecks && ((_b = left.remainingChecks) === null || _b === void 0 ? void 0 : _b.equals(right.remainingChecks)))\n            || (!left.remainingChecks && !right.remainingChecks))\n        && left.halfmoves === right.halfmoves\n        && left.fullmoves === right.fullmoves;\n};\n//# sourceMappingURL=setup.js.map","import { Board, boardEquals } from './board.js';\nimport { SquareSet } from './squareSet.js';\nimport { ByColor, ByRole, Color, Role, ROLES, Square } from './types.js';\n\nexport class MaterialSide implements ByRole<number> {\n  pawn: number;\n  knight: number;\n  bishop: number;\n  rook: number;\n  queen: number;\n  king: number;\n\n  private constructor() {}\n\n  static empty(): MaterialSide {\n    const m = new MaterialSide();\n    for (const role of ROLES) m[role] = 0;\n    return m;\n  }\n\n  static fromBoard(board: Board, color: Color): MaterialSide {\n    const m = new MaterialSide();\n    for (const role of ROLES) m[role] = board.pieces(color, role).size();\n    return m;\n  }\n\n  clone(): MaterialSide {\n    const m = new MaterialSide();\n    for (const role of ROLES) m[role] = this[role];\n    return m;\n  }\n\n  equals(other: MaterialSide): boolean {\n    return ROLES.every(role => this[role] === other[role]);\n  }\n\n  add(other: MaterialSide): MaterialSide {\n    const m = new MaterialSide();\n    for (const role of ROLES) m[role] = this[role] + other[role];\n    return m;\n  }\n\n  subtract(other: MaterialSide): MaterialSide {\n    const m = new MaterialSide();\n    for (const role of ROLES) m[role] = this[role] - other[role];\n    return m;\n  }\n\n  nonEmpty(): boolean {\n    return ROLES.some(role => this[role] > 0);\n  }\n\n  isEmpty(): boolean {\n    return !this.nonEmpty();\n  }\n\n  hasPawns(): boolean {\n    return this.pawn > 0;\n  }\n\n  hasNonPawns(): boolean {\n    return this.knight > 0 || this.bishop > 0 || this.rook > 0 || this.queen > 0 || this.king > 0;\n  }\n\n  size(): number {\n    return this.pawn + this.knight + this.bishop + this.rook + this.queen + this.king;\n  }\n}\n\nexport class Material implements ByColor<MaterialSide> {\n  constructor(\n    public white: MaterialSide,\n    public black: MaterialSide,\n  ) {}\n\n  static empty(): Material {\n    return new Material(MaterialSide.empty(), MaterialSide.empty());\n  }\n\n  static fromBoard(board: Board): Material {\n    return new Material(MaterialSide.fromBoard(board, 'white'), MaterialSide.fromBoard(board, 'black'));\n  }\n\n  clone(): Material {\n    return new Material(this.white.clone(), this.black.clone());\n  }\n\n  equals(other: Material): boolean {\n    return this.white.equals(other.white) && this.black.equals(other.black);\n  }\n\n  add(other: Material): Material {\n    return new Material(this.white.add(other.white), this.black.add(other.black));\n  }\n\n  subtract(other: Material): Material {\n    return new Material(this.white.subtract(other.white), this.black.subtract(other.black));\n  }\n\n  count(role: Role): number {\n    return this.white[role] + this.black[role];\n  }\n\n  size(): number {\n    return this.white.size() + this.black.size();\n  }\n\n  isEmpty(): boolean {\n    return this.white.isEmpty() && this.black.isEmpty();\n  }\n\n  nonEmpty(): boolean {\n    return !this.isEmpty();\n  }\n\n  hasPawns(): boolean {\n    return this.white.hasPawns() || this.black.hasPawns();\n  }\n\n  hasNonPawns(): boolean {\n    return this.white.hasNonPawns() || this.black.hasNonPawns();\n  }\n}\n\nexport class RemainingChecks implements ByColor<number> {\n  constructor(\n    public white: number,\n    public black: number,\n  ) {}\n\n  static default(): RemainingChecks {\n    return new RemainingChecks(3, 3);\n  }\n\n  clone(): RemainingChecks {\n    return new RemainingChecks(this.white, this.black);\n  }\n\n  equals(other: RemainingChecks): boolean {\n    return this.white === other.white && this.black === other.black;\n  }\n}\n\n/**\n * A not necessarily legal chess or chess variant position.\n */\nexport interface Setup {\n  board: Board;\n  pockets: Material | undefined;\n  turn: Color;\n  castlingRights: SquareSet;\n  epSquare: Square | undefined;\n  remainingChecks: RemainingChecks | undefined;\n  halfmoves: number;\n  fullmoves: number;\n}\n\nexport const defaultSetup = (): Setup => ({\n  board: Board.default(),\n  pockets: undefined,\n  turn: 'white',\n  castlingRights: SquareSet.corners(),\n  epSquare: undefined,\n  remainingChecks: undefined,\n  halfmoves: 0,\n  fullmoves: 1,\n});\n\nexport const setupClone = (setup: Setup): Setup => ({\n  board: setup.board.clone(),\n  pockets: setup.pockets?.clone(),\n  turn: setup.turn,\n  castlingRights: setup.castlingRights,\n  epSquare: setup.epSquare,\n  remainingChecks: setup.remainingChecks?.clone(),\n  halfmoves: setup.halfmoves,\n  fullmoves: setup.fullmoves,\n});\n\nexport const setupEquals = (left: Setup, right: Setup): boolean =>\n  boardEquals(left.board, right.board)\n  && ((right.pockets && left.pockets?.equals(right.pockets)) || (!left.pockets && !right.pockets))\n  && left.turn === right.turn\n  && left.castlingRights.equals(right.castlingRights)\n  && left.epSquare === right.epSquare\n  && ((right.remainingChecks && left.remainingChecks?.equals(right.remainingChecks))\n    || (!left.remainingChecks && !right.remainingChecks))\n  && left.halfmoves === right.halfmoves\n  && left.fullmoves === right.fullmoves;\n","import { start } from './api.js';\nimport { configure } from './config.js';\nimport { defaults } from './state.js';\nimport { renderWrap } from './wrap.js';\nimport * as events from './events.js';\nimport { render, renderResized, updateBounds } from './render.js';\nimport * as autoPieces from './autoPieces.js';\nimport * as svg from './svg.js';\nimport * as util from './util.js';\nexport function initModule({ el, config }) {\n    return Chessground(el, config);\n}\nexport function Chessground(element, config) {\n    const maybeState = defaults();\n    configure(maybeState, config || {});\n    function redrawAll() {\n        const prevUnbind = 'dom' in maybeState ? maybeState.dom.unbind : undefined;\n        // compute bounds from existing board element if possible\n        // this allows non-square boards from CSS to be handled (for 3D)\n        const elements = renderWrap(element, maybeState), bounds = util.memo(() => elements.board.getBoundingClientRect()), redrawNow = (skipSvg) => {\n            render(state);\n            if (elements.autoPieces)\n                autoPieces.render(state, elements.autoPieces);\n            if (!skipSvg && elements.svg)\n                svg.renderSvg(state, elements.svg, elements.customSvg);\n        }, onResize = () => {\n            updateBounds(state);\n            renderResized(state);\n            if (elements.autoPieces)\n                autoPieces.renderResized(state);\n        };\n        const state = maybeState;\n        state.dom = {\n            elements,\n            bounds,\n            redraw: debounceRedraw(redrawNow),\n            redrawNow,\n            unbind: prevUnbind,\n        };\n        state.drawable.prevSvgHash = '';\n        updateBounds(state);\n        redrawNow(false);\n        events.bindBoard(state, onResize);\n        if (!prevUnbind)\n            state.dom.unbind = events.bindDocument(state, onResize);\n        state.events.insert && state.events.insert(elements);\n        return state;\n    }\n    return start(redrawAll(), redrawAll);\n}\nfunction debounceRedraw(redrawNow) {\n    let redrawing = false;\n    return () => {\n        if (redrawing)\n            return;\n        redrawing = true;\n        requestAnimationFrame(() => {\n            redrawNow();\n            redrawing = false;\n        });\n    };\n}\n//# sourceMappingURL=chessground.js.map","import { Api, start } from './api.js';\nimport { Config, configure } from './config.js';\nimport { HeadlessState, State, defaults } from './state.js';\n\nimport { renderWrap } from './wrap.js';\nimport * as events from './events.js';\nimport { render, renderResized, updateBounds } from './render.js';\nimport * as autoPieces from './autoPieces.js';\nimport * as svg from './svg.js';\nimport * as util from './util.js';\n\nexport function initModule({ el, config }: { el: HTMLElement; config?: Config }): Api {\n  return Chessground(el, config);\n}\n\nexport function Chessground(element: HTMLElement, config?: Config): Api {\n  const maybeState: State | HeadlessState = defaults();\n\n  configure(maybeState, config || {});\n\n  function redrawAll(): State {\n    const prevUnbind = 'dom' in maybeState ? maybeState.dom.unbind : undefined;\n    // compute bounds from existing board element if possible\n    // this allows non-square boards from CSS to be handled (for 3D)\n    const elements = renderWrap(element, maybeState),\n      bounds = util.memo(() => elements.board.getBoundingClientRect()),\n      redrawNow = (skipSvg?: boolean): void => {\n        render(state);\n        if (elements.autoPieces) autoPieces.render(state, elements.autoPieces);\n        if (!skipSvg && elements.svg) svg.renderSvg(state, elements.svg, elements.customSvg!);\n      },\n      onResize = (): void => {\n        updateBounds(state);\n        renderResized(state);\n        if (elements.autoPieces) autoPieces.renderResized(state);\n      };\n    const state = maybeState as State;\n    state.dom = {\n      elements,\n      bounds,\n      redraw: debounceRedraw(redrawNow),\n      redrawNow,\n      unbind: prevUnbind,\n    };\n    state.drawable.prevSvgHash = '';\n    updateBounds(state);\n    redrawNow(false);\n    events.bindBoard(state, onResize);\n    if (!prevUnbind) state.dom.unbind = events.bindDocument(state, onResize);\n    state.events.insert && state.events.insert(elements);\n    return state;\n  }\n\n  return start(redrawAll(), redrawAll);\n}\n\nfunction debounceRedraw(redrawNow: (skipSvg?: boolean) => void): () => void {\n  let redrawing = false;\n  return () => {\n    if (redrawing) return;\n    redrawing = true;\n    requestAnimationFrame(() => {\n      redrawNow();\n      redrawing = false;\n    });\n  };\n}\n","import * as board from './board.js';\nimport { write as fenWrite } from './fen.js';\nimport { configure, applyAnimation } from './config.js';\nimport { anim, render } from './anim.js';\nimport { cancel as dragCancel, dragNewPiece } from './drag.js';\nimport { explosion } from './explosion.js';\n// see API types and documentations in dts/api.d.ts\nexport function start(state, redrawAll) {\n    function toggleOrientation() {\n        board.toggleOrientation(state);\n        redrawAll();\n    }\n    return {\n        set(config) {\n            if (config.orientation && config.orientation !== state.orientation)\n                toggleOrientation();\n            applyAnimation(state, config);\n            (config.fen ? anim : render)(state => configure(state, config), state);\n        },\n        state,\n        getFen: () => fenWrite(state.pieces),\n        toggleOrientation,\n        setPieces(pieces) {\n            anim(state => board.setPieces(state, pieces), state);\n        },\n        selectSquare(key, force) {\n            if (key)\n                anim(state => board.selectSquare(state, key, force), state);\n            else if (state.selected) {\n                board.unselect(state);\n                state.dom.redraw();\n            }\n        },\n        move(orig, dest) {\n            anim(state => board.baseMove(state, orig, dest), state);\n        },\n        newPiece(piece, key) {\n            anim(state => board.baseNewPiece(state, piece, key), state);\n        },\n        playPremove() {\n            if (state.premovable.current) {\n                if (anim(board.playPremove, state))\n                    return true;\n                // if the premove couldn't be played, redraw to clear it up\n                state.dom.redraw();\n            }\n            return false;\n        },\n        playPredrop(validate) {\n            if (state.predroppable.current) {\n                const result = board.playPredrop(state, validate);\n                state.dom.redraw();\n                return result;\n            }\n            return false;\n        },\n        cancelPremove() {\n            render(board.unsetPremove, state);\n        },\n        cancelPredrop() {\n            render(board.unsetPredrop, state);\n        },\n        cancelMove() {\n            render(state => {\n                board.cancelMove(state);\n                dragCancel(state);\n            }, state);\n        },\n        stop() {\n            render(state => {\n                board.stop(state);\n                dragCancel(state);\n            }, state);\n        },\n        explode(keys) {\n            explosion(state, keys);\n        },\n        setAutoShapes(shapes) {\n            render(state => (state.drawable.autoShapes = shapes), state);\n        },\n        setShapes(shapes) {\n            render(state => (state.drawable.shapes = shapes), state);\n        },\n        getKeyAtDomPos(pos) {\n            return board.getKeyAtDomPos(pos, board.whitePov(state), state.dom.bounds());\n        },\n        redrawAll,\n        dragNewPiece(piece, event, force) {\n            dragNewPiece(state, piece, event, force);\n        },\n        destroy() {\n            board.stop(state);\n            state.dom.unbind && state.dom.unbind();\n            state.dom.destroyed = true;\n        },\n    };\n}\n//# sourceMappingURL=api.js.map","import { State } from './state.js';\nimport * as board from './board.js';\nimport { write as fenWrite } from './fen.js';\nimport { Config, configure, applyAnimation } from './config.js';\nimport { anim, render } from './anim.js';\nimport { cancel as dragCancel, dragNewPiece } from './drag.js';\nimport { DrawShape } from './draw.js';\nimport { explosion } from './explosion.js';\nimport * as cg from './types.js';\n\nexport interface Api {\n  // reconfigure the instance. Accepts all config options, except for viewOnly & drawable.visible.\n  // board will be animated accordingly, if animations are enabled.\n  set(config: Config): void;\n\n  // read chessground state; write at your own risks.\n  state: State;\n\n  // get the position as a FEN string (only contains pieces, no flags)\n  // e.g. rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR\n  getFen(): cg.FEN;\n\n  // change the view angle\n  toggleOrientation(): void;\n\n  // perform a move programmatically\n  move(orig: cg.Key, dest: cg.Key): void;\n\n  // add and/or remove arbitrary pieces on the board\n  setPieces(pieces: cg.PiecesDiff): void;\n\n  // click a square programmatically\n  selectSquare(key: cg.Key | null, force?: boolean): void;\n\n  // put a new piece on the board\n  newPiece(piece: cg.Piece, key: cg.Key): void;\n\n  // play the current premove, if any; returns true if premove was played\n  playPremove(): boolean;\n\n  // cancel the current premove, if any\n  cancelPremove(): void;\n\n  // play the current predrop, if any; returns true if premove was played\n  playPredrop(validate: (drop: cg.Drop) => boolean): boolean;\n\n  // cancel the current predrop, if any\n  cancelPredrop(): void;\n\n  // cancel the current move being made\n  cancelMove(): void;\n\n  // cancel current move and prevent further ones\n  stop(): void;\n\n  // make squares explode (atomic chess)\n  explode(keys: cg.Key[]): void;\n\n  // programmatically draw user shapes\n  setShapes(shapes: DrawShape[]): void;\n\n  // programmatically draw auto shapes\n  setAutoShapes(shapes: DrawShape[]): void;\n\n  // square name at this DOM position (like \"e4\")\n  getKeyAtDomPos(pos: cg.NumberPair): cg.Key | undefined;\n\n  // only useful when CSS changes the board width/height ratio (for 3D)\n  redrawAll: cg.Redraw;\n\n  // for crazyhouse and board editors\n  dragNewPiece(piece: cg.Piece, event: cg.MouchEvent, force?: boolean): void;\n\n  // unbinds all events\n  // (important for document-wide events like scroll and mousemove)\n  destroy: cg.Unbind;\n}\n\n// see API types and documentations in dts/api.d.ts\nexport function start(state: State, redrawAll: cg.Redraw): Api {\n  function toggleOrientation(): void {\n    board.toggleOrientation(state);\n    redrawAll();\n  }\n\n  return {\n    set(config): void {\n      if (config.orientation && config.orientation !== state.orientation) toggleOrientation();\n      applyAnimation(state, config);\n      (config.fen ? anim : render)(state => configure(state, config), state);\n    },\n\n    state,\n\n    getFen: () => fenWrite(state.pieces),\n\n    toggleOrientation,\n\n    setPieces(pieces): void {\n      anim(state => board.setPieces(state, pieces), state);\n    },\n\n    selectSquare(key, force): void {\n      if (key) anim(state => board.selectSquare(state, key, force), state);\n      else if (state.selected) {\n        board.unselect(state);\n        state.dom.redraw();\n      }\n    },\n\n    move(orig, dest): void {\n      anim(state => board.baseMove(state, orig, dest), state);\n    },\n\n    newPiece(piece, key): void {\n      anim(state => board.baseNewPiece(state, piece, key), state);\n    },\n\n    playPremove(): boolean {\n      if (state.premovable.current) {\n        if (anim(board.playPremove, state)) return true;\n        // if the premove couldn't be played, redraw to clear it up\n        state.dom.redraw();\n      }\n      return false;\n    },\n\n    playPredrop(validate): boolean {\n      if (state.predroppable.current) {\n        const result = board.playPredrop(state, validate);\n        state.dom.redraw();\n        return result;\n      }\n      return false;\n    },\n\n    cancelPremove(): void {\n      render(board.unsetPremove, state);\n    },\n\n    cancelPredrop(): void {\n      render(board.unsetPredrop, state);\n    },\n\n    cancelMove(): void {\n      render(state => {\n        board.cancelMove(state);\n        dragCancel(state);\n      }, state);\n    },\n\n    stop(): void {\n      render(state => {\n        board.stop(state);\n        dragCancel(state);\n      }, state);\n    },\n\n    explode(keys: cg.Key[]): void {\n      explosion(state, keys);\n    },\n\n    setAutoShapes(shapes: DrawShape[]): void {\n      render(state => (state.drawable.autoShapes = shapes), state);\n    },\n\n    setShapes(shapes: DrawShape[]): void {\n      render(state => (state.drawable.shapes = shapes), state);\n    },\n\n    getKeyAtDomPos(pos): cg.Key | undefined {\n      return board.getKeyAtDomPos(pos, board.whitePov(state), state.dom.bounds());\n    },\n\n    redrawAll,\n\n    dragNewPiece(piece, event, force): void {\n      dragNewPiece(state, piece, event, force);\n    },\n\n    destroy(): void {\n      board.stop(state);\n      state.dom.unbind && state.dom.unbind();\n      state.dom.destroyed = true;\n    },\n  };\n}\n","import { pos2key, key2pos, opposite, distanceSq, allPos, computeSquareCenter } from './util.js';\nimport { premove, queen, knight } from './premove.js';\nexport function callUserFunction(f, ...args) {\n    if (f)\n        setTimeout(() => f(...args), 1);\n}\nexport function toggleOrientation(state) {\n    state.orientation = opposite(state.orientation);\n    state.animation.current = state.draggable.current = state.selected = undefined;\n}\nexport function reset(state) {\n    state.lastMove = undefined;\n    unselect(state);\n    unsetPremove(state);\n    unsetPredrop(state);\n}\nexport function setPieces(state, pieces) {\n    for (const [key, piece] of pieces) {\n        if (piece)\n            state.pieces.set(key, piece);\n        else\n            state.pieces.delete(key);\n    }\n}\nexport function setCheck(state, color) {\n    state.check = undefined;\n    if (color === true)\n        color = state.turnColor;\n    if (color)\n        for (const [k, p] of state.pieces) {\n            if (p.role === 'king' && p.color === color) {\n                state.check = k;\n            }\n        }\n}\nfunction setPremove(state, orig, dest, meta) {\n    unsetPredrop(state);\n    state.premovable.current = [orig, dest];\n    callUserFunction(state.premovable.events.set, orig, dest, meta);\n}\nexport function unsetPremove(state) {\n    if (state.premovable.current) {\n        state.premovable.current = undefined;\n        callUserFunction(state.premovable.events.unset);\n    }\n}\nfunction setPredrop(state, role, key) {\n    unsetPremove(state);\n    state.predroppable.current = { role, key };\n    callUserFunction(state.predroppable.events.set, role, key);\n}\nexport function unsetPredrop(state) {\n    const pd = state.predroppable;\n    if (pd.current) {\n        pd.current = undefined;\n        callUserFunction(pd.events.unset);\n    }\n}\nfunction tryAutoCastle(state, orig, dest) {\n    if (!state.autoCastle)\n        return false;\n    const king = state.pieces.get(orig);\n    if (!king || king.role !== 'king')\n        return false;\n    const origPos = key2pos(orig);\n    const destPos = key2pos(dest);\n    if ((origPos[1] !== 0 && origPos[1] !== 7) || origPos[1] !== destPos[1])\n        return false;\n    if (origPos[0] === 4 && !state.pieces.has(dest)) {\n        if (destPos[0] === 6)\n            dest = pos2key([7, destPos[1]]);\n        else if (destPos[0] === 2)\n            dest = pos2key([0, destPos[1]]);\n    }\n    const rook = state.pieces.get(dest);\n    if (!rook || rook.color !== king.color || rook.role !== 'rook')\n        return false;\n    state.pieces.delete(orig);\n    state.pieces.delete(dest);\n    if (origPos[0] < destPos[0]) {\n        state.pieces.set(pos2key([6, destPos[1]]), king);\n        state.pieces.set(pos2key([5, destPos[1]]), rook);\n    }\n    else {\n        state.pieces.set(pos2key([2, destPos[1]]), king);\n        state.pieces.set(pos2key([3, destPos[1]]), rook);\n    }\n    return true;\n}\nexport function baseMove(state, orig, dest) {\n    const origPiece = state.pieces.get(orig), destPiece = state.pieces.get(dest);\n    if (orig === dest || !origPiece)\n        return false;\n    const captured = destPiece && destPiece.color !== origPiece.color ? destPiece : undefined;\n    if (dest === state.selected)\n        unselect(state);\n    callUserFunction(state.events.move, orig, dest, captured);\n    if (!tryAutoCastle(state, orig, dest)) {\n        state.pieces.set(dest, origPiece);\n        state.pieces.delete(orig);\n    }\n    state.lastMove = [orig, dest];\n    state.check = undefined;\n    callUserFunction(state.events.change);\n    return captured || true;\n}\nexport function baseNewPiece(state, piece, key, force) {\n    if (state.pieces.has(key)) {\n        if (force)\n            state.pieces.delete(key);\n        else\n            return false;\n    }\n    callUserFunction(state.events.dropNewPiece, piece, key);\n    state.pieces.set(key, piece);\n    state.lastMove = [key];\n    state.check = undefined;\n    callUserFunction(state.events.change);\n    state.movable.dests = undefined;\n    state.turnColor = opposite(state.turnColor);\n    return true;\n}\nfunction baseUserMove(state, orig, dest) {\n    const result = baseMove(state, orig, dest);\n    if (result) {\n        state.movable.dests = undefined;\n        state.turnColor = opposite(state.turnColor);\n        state.animation.current = undefined;\n    }\n    return result;\n}\nexport function userMove(state, orig, dest) {\n    if (canMove(state, orig, dest)) {\n        const result = baseUserMove(state, orig, dest);\n        if (result) {\n            const holdTime = state.hold.stop();\n            unselect(state);\n            const metadata = {\n                premove: false,\n                ctrlKey: state.stats.ctrlKey,\n                holdTime,\n            };\n            if (result !== true)\n                metadata.captured = result;\n            callUserFunction(state.movable.events.after, orig, dest, metadata);\n            return true;\n        }\n    }\n    else if (canPremove(state, orig, dest)) {\n        setPremove(state, orig, dest, {\n            ctrlKey: state.stats.ctrlKey,\n        });\n        unselect(state);\n        return true;\n    }\n    unselect(state);\n    return false;\n}\nexport function dropNewPiece(state, orig, dest, force) {\n    const piece = state.pieces.get(orig);\n    if (piece && (canDrop(state, orig, dest) || force)) {\n        state.pieces.delete(orig);\n        baseNewPiece(state, piece, dest, force);\n        callUserFunction(state.movable.events.afterNewPiece, piece.role, dest, {\n            premove: false,\n            predrop: false,\n        });\n    }\n    else if (piece && canPredrop(state, orig, dest)) {\n        setPredrop(state, piece.role, dest);\n    }\n    else {\n        unsetPremove(state);\n        unsetPredrop(state);\n    }\n    state.pieces.delete(orig);\n    unselect(state);\n}\nexport function selectSquare(state, key, force) {\n    callUserFunction(state.events.select, key);\n    if (state.selected) {\n        if (state.selected === key && !state.draggable.enabled) {\n            unselect(state);\n            state.hold.cancel();\n            return;\n        }\n        else if ((state.selectable.enabled || force) && state.selected !== key) {\n            if (userMove(state, state.selected, key)) {\n                state.stats.dragged = false;\n                return;\n            }\n        }\n    }\n    if ((state.selectable.enabled || state.draggable.enabled) &&\n        (isMovable(state, key) || isPremovable(state, key))) {\n        setSelected(state, key);\n        state.hold.start();\n    }\n}\nexport function setSelected(state, key) {\n    state.selected = key;\n    if (isPremovable(state, key)) {\n        // calculate chess premoves if custom premoves are not passed\n        if (!state.premovable.customDests) {\n            state.premovable.dests = premove(state.pieces, key, state.premovable.castle);\n        }\n    }\n    else\n        state.premovable.dests = undefined;\n}\nexport function unselect(state) {\n    state.selected = undefined;\n    state.premovable.dests = undefined;\n    state.hold.cancel();\n}\nfunction isMovable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return (!!piece &&\n        (state.movable.color === 'both' ||\n            (state.movable.color === piece.color && state.turnColor === piece.color)));\n}\nexport const canMove = (state, orig, dest) => {\n    var _a, _b;\n    return orig !== dest &&\n        isMovable(state, orig) &&\n        (state.movable.free || !!((_b = (_a = state.movable.dests) === null || _a === void 0 ? void 0 : _a.get(orig)) === null || _b === void 0 ? void 0 : _b.includes(dest)));\n};\nfunction canDrop(state, orig, dest) {\n    const piece = state.pieces.get(orig);\n    return (!!piece &&\n        (orig === dest || !state.pieces.has(dest)) &&\n        (state.movable.color === 'both' ||\n            (state.movable.color === piece.color && state.turnColor === piece.color)));\n}\nfunction isPremovable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return (!!piece &&\n        state.premovable.enabled &&\n        state.movable.color === piece.color &&\n        state.turnColor !== piece.color);\n}\nfunction canPremove(state, orig, dest) {\n    var _a, _b;\n    const validPremoves = (_b = (_a = state.premovable.customDests) === null || _a === void 0 ? void 0 : _a.get(orig)) !== null && _b !== void 0 ? _b : premove(state.pieces, orig, state.premovable.castle);\n    return orig !== dest && isPremovable(state, orig) && validPremoves.includes(dest);\n}\nfunction canPredrop(state, orig, dest) {\n    const piece = state.pieces.get(orig);\n    const destPiece = state.pieces.get(dest);\n    return (!!piece &&\n        (!destPiece || destPiece.color !== state.movable.color) &&\n        state.predroppable.enabled &&\n        (piece.role !== 'pawn' || (dest[1] !== '1' && dest[1] !== '8')) &&\n        state.movable.color === piece.color &&\n        state.turnColor !== piece.color);\n}\nexport function isDraggable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return (!!piece &&\n        state.draggable.enabled &&\n        (state.movable.color === 'both' ||\n            (state.movable.color === piece.color && (state.turnColor === piece.color || state.premovable.enabled))));\n}\nexport function playPremove(state) {\n    const move = state.premovable.current;\n    if (!move)\n        return false;\n    const orig = move[0], dest = move[1];\n    let success = false;\n    if (canMove(state, orig, dest)) {\n        const result = baseUserMove(state, orig, dest);\n        if (result) {\n            const metadata = { premove: true };\n            if (result !== true)\n                metadata.captured = result;\n            callUserFunction(state.movable.events.after, orig, dest, metadata);\n            success = true;\n        }\n    }\n    unsetPremove(state);\n    return success;\n}\nexport function playPredrop(state, validate) {\n    const drop = state.predroppable.current;\n    let success = false;\n    if (!drop)\n        return false;\n    if (validate(drop)) {\n        const piece = {\n            role: drop.role,\n            color: state.movable.color,\n        };\n        if (baseNewPiece(state, piece, drop.key)) {\n            callUserFunction(state.movable.events.afterNewPiece, drop.role, drop.key, {\n                premove: false,\n                predrop: true,\n            });\n            success = true;\n        }\n    }\n    unsetPredrop(state);\n    return success;\n}\nexport function cancelMove(state) {\n    unsetPremove(state);\n    unsetPredrop(state);\n    unselect(state);\n}\nexport function stop(state) {\n    state.movable.color = state.movable.dests = state.animation.current = undefined;\n    cancelMove(state);\n}\nexport function getKeyAtDomPos(pos, asWhite, bounds) {\n    let file = Math.floor((8 * (pos[0] - bounds.left)) / bounds.width);\n    if (!asWhite)\n        file = 7 - file;\n    let rank = 7 - Math.floor((8 * (pos[1] - bounds.top)) / bounds.height);\n    if (!asWhite)\n        rank = 7 - rank;\n    return file >= 0 && file < 8 && rank >= 0 && rank < 8 ? pos2key([file, rank]) : undefined;\n}\nexport function getSnappedKeyAtDomPos(orig, pos, asWhite, bounds) {\n    const origPos = key2pos(orig);\n    const validSnapPos = allPos.filter(pos2 => queen(origPos[0], origPos[1], pos2[0], pos2[1]) || knight(origPos[0], origPos[1], pos2[0], pos2[1]));\n    const validSnapCenters = validSnapPos.map(pos2 => computeSquareCenter(pos2key(pos2), asWhite, bounds));\n    const validSnapDistances = validSnapCenters.map(pos2 => distanceSq(pos, pos2));\n    const [, closestSnapIndex] = validSnapDistances.reduce((a, b, index) => (a[0] < b ? a : [b, index]), [validSnapDistances[0], 0]);\n    return pos2key(validSnapPos[closestSnapIndex]);\n}\nexport const whitePov = (s) => s.orientation === 'white';\n//# sourceMappingURL=board.js.map","import { HeadlessState } from './state.js';\nimport { pos2key, key2pos, opposite, distanceSq, allPos, computeSquareCenter } from './util.js';\nimport { premove, queen, knight } from './premove.js';\nimport * as cg from './types.js';\n\nexport function callUserFunction<T extends (...args: any[]) => void>(\n  f: T | undefined,\n  ...args: Parameters<T>\n): void {\n  if (f) setTimeout(() => f(...args), 1);\n}\n\nexport function toggleOrientation(state: HeadlessState): void {\n  state.orientation = opposite(state.orientation);\n  state.animation.current = state.draggable.current = state.selected = undefined;\n}\n\nexport function reset(state: HeadlessState): void {\n  state.lastMove = undefined;\n  unselect(state);\n  unsetPremove(state);\n  unsetPredrop(state);\n}\n\nexport function setPieces(state: HeadlessState, pieces: cg.PiecesDiff): void {\n  for (const [key, piece] of pieces) {\n    if (piece) state.pieces.set(key, piece);\n    else state.pieces.delete(key);\n  }\n}\n\nexport function setCheck(state: HeadlessState, color: cg.Color | boolean): void {\n  state.check = undefined;\n  if (color === true) color = state.turnColor;\n  if (color)\n    for (const [k, p] of state.pieces) {\n      if (p.role === 'king' && p.color === color) {\n        state.check = k;\n      }\n    }\n}\n\nfunction setPremove(state: HeadlessState, orig: cg.Key, dest: cg.Key, meta: cg.SetPremoveMetadata): void {\n  unsetPredrop(state);\n  state.premovable.current = [orig, dest];\n  callUserFunction(state.premovable.events.set, orig, dest, meta);\n}\n\nexport function unsetPremove(state: HeadlessState): void {\n  if (state.premovable.current) {\n    state.premovable.current = undefined;\n    callUserFunction(state.premovable.events.unset);\n  }\n}\n\nfunction setPredrop(state: HeadlessState, role: cg.Role, key: cg.Key): void {\n  unsetPremove(state);\n  state.predroppable.current = { role, key };\n  callUserFunction(state.predroppable.events.set, role, key);\n}\n\nexport function unsetPredrop(state: HeadlessState): void {\n  const pd = state.predroppable;\n  if (pd.current) {\n    pd.current = undefined;\n    callUserFunction(pd.events.unset);\n  }\n}\n\nfunction tryAutoCastle(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  if (!state.autoCastle) return false;\n\n  const king = state.pieces.get(orig);\n  if (!king || king.role !== 'king') return false;\n\n  const origPos = key2pos(orig);\n  const destPos = key2pos(dest);\n  if ((origPos[1] !== 0 && origPos[1] !== 7) || origPos[1] !== destPos[1]) return false;\n  if (origPos[0] === 4 && !state.pieces.has(dest)) {\n    if (destPos[0] === 6) dest = pos2key([7, destPos[1]]);\n    else if (destPos[0] === 2) dest = pos2key([0, destPos[1]]);\n  }\n  const rook = state.pieces.get(dest);\n  if (!rook || rook.color !== king.color || rook.role !== 'rook') return false;\n\n  state.pieces.delete(orig);\n  state.pieces.delete(dest);\n\n  if (origPos[0] < destPos[0]) {\n    state.pieces.set(pos2key([6, destPos[1]]), king);\n    state.pieces.set(pos2key([5, destPos[1]]), rook);\n  } else {\n    state.pieces.set(pos2key([2, destPos[1]]), king);\n    state.pieces.set(pos2key([3, destPos[1]]), rook);\n  }\n  return true;\n}\n\nexport function baseMove(state: HeadlessState, orig: cg.Key, dest: cg.Key): cg.Piece | boolean {\n  const origPiece = state.pieces.get(orig),\n    destPiece = state.pieces.get(dest);\n  if (orig === dest || !origPiece) return false;\n  const captured = destPiece && destPiece.color !== origPiece.color ? destPiece : undefined;\n  if (dest === state.selected) unselect(state);\n  callUserFunction(state.events.move, orig, dest, captured);\n  if (!tryAutoCastle(state, orig, dest)) {\n    state.pieces.set(dest, origPiece);\n    state.pieces.delete(orig);\n  }\n  state.lastMove = [orig, dest];\n  state.check = undefined;\n  callUserFunction(state.events.change);\n  return captured || true;\n}\n\nexport function baseNewPiece(state: HeadlessState, piece: cg.Piece, key: cg.Key, force?: boolean): boolean {\n  if (state.pieces.has(key)) {\n    if (force) state.pieces.delete(key);\n    else return false;\n  }\n  callUserFunction(state.events.dropNewPiece, piece, key);\n  state.pieces.set(key, piece);\n  state.lastMove = [key];\n  state.check = undefined;\n  callUserFunction(state.events.change);\n  state.movable.dests = undefined;\n  state.turnColor = opposite(state.turnColor);\n  return true;\n}\n\nfunction baseUserMove(state: HeadlessState, orig: cg.Key, dest: cg.Key): cg.Piece | boolean {\n  const result = baseMove(state, orig, dest);\n  if (result) {\n    state.movable.dests = undefined;\n    state.turnColor = opposite(state.turnColor);\n    state.animation.current = undefined;\n  }\n  return result;\n}\n\nexport function userMove(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  if (canMove(state, orig, dest)) {\n    const result = baseUserMove(state, orig, dest);\n    if (result) {\n      const holdTime = state.hold.stop();\n      unselect(state);\n      const metadata: cg.MoveMetadata = {\n        premove: false,\n        ctrlKey: state.stats.ctrlKey,\n        holdTime,\n      };\n      if (result !== true) metadata.captured = result;\n      callUserFunction(state.movable.events.after, orig, dest, metadata);\n      return true;\n    }\n  } else if (canPremove(state, orig, dest)) {\n    setPremove(state, orig, dest, {\n      ctrlKey: state.stats.ctrlKey,\n    });\n    unselect(state);\n    return true;\n  }\n  unselect(state);\n  return false;\n}\n\nexport function dropNewPiece(state: HeadlessState, orig: cg.Key, dest: cg.Key, force?: boolean): void {\n  const piece = state.pieces.get(orig);\n  if (piece && (canDrop(state, orig, dest) || force)) {\n    state.pieces.delete(orig);\n    baseNewPiece(state, piece, dest, force);\n    callUserFunction(state.movable.events.afterNewPiece, piece.role, dest, {\n      premove: false,\n      predrop: false,\n    });\n  } else if (piece && canPredrop(state, orig, dest)) {\n    setPredrop(state, piece.role, dest);\n  } else {\n    unsetPremove(state);\n    unsetPredrop(state);\n  }\n  state.pieces.delete(orig);\n  unselect(state);\n}\n\nexport function selectSquare(state: HeadlessState, key: cg.Key, force?: boolean): void {\n  callUserFunction(state.events.select, key);\n  if (state.selected) {\n    if (state.selected === key && !state.draggable.enabled) {\n      unselect(state);\n      state.hold.cancel();\n      return;\n    } else if ((state.selectable.enabled || force) && state.selected !== key) {\n      if (userMove(state, state.selected, key)) {\n        state.stats.dragged = false;\n        return;\n      }\n    }\n  }\n  if (\n    (state.selectable.enabled || state.draggable.enabled) &&\n    (isMovable(state, key) || isPremovable(state, key))\n  ) {\n    setSelected(state, key);\n    state.hold.start();\n  }\n}\n\nexport function setSelected(state: HeadlessState, key: cg.Key): void {\n  state.selected = key;\n  if (isPremovable(state, key)) {\n    // calculate chess premoves if custom premoves are not passed\n    if (!state.premovable.customDests) {\n      state.premovable.dests = premove(state.pieces, key, state.premovable.castle);\n    }\n  } else state.premovable.dests = undefined;\n}\n\nexport function unselect(state: HeadlessState): void {\n  state.selected = undefined;\n  state.premovable.dests = undefined;\n  state.hold.cancel();\n}\n\nfunction isMovable(state: HeadlessState, orig: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return (\n    !!piece &&\n    (state.movable.color === 'both' ||\n      (state.movable.color === piece.color && state.turnColor === piece.color))\n  );\n}\n\nexport const canMove = (state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean =>\n  orig !== dest &&\n  isMovable(state, orig) &&\n  (state.movable.free || !!state.movable.dests?.get(orig)?.includes(dest));\n\nfunction canDrop(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return (\n    !!piece &&\n    (orig === dest || !state.pieces.has(dest)) &&\n    (state.movable.color === 'both' ||\n      (state.movable.color === piece.color && state.turnColor === piece.color))\n  );\n}\n\nfunction isPremovable(state: HeadlessState, orig: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return (\n    !!piece &&\n    state.premovable.enabled &&\n    state.movable.color === piece.color &&\n    state.turnColor !== piece.color\n  );\n}\n\nfunction canPremove(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  const validPremoves: cg.Key[] =\n    state.premovable.customDests?.get(orig) ?? premove(state.pieces, orig, state.premovable.castle);\n  return orig !== dest && isPremovable(state, orig) && validPremoves.includes(dest);\n}\n\nfunction canPredrop(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  const destPiece = state.pieces.get(dest);\n  return (\n    !!piece &&\n    (!destPiece || destPiece.color !== state.movable.color) &&\n    state.predroppable.enabled &&\n    (piece.role !== 'pawn' || (dest[1] !== '1' && dest[1] !== '8')) &&\n    state.movable.color === piece.color &&\n    state.turnColor !== piece.color\n  );\n}\n\nexport function isDraggable(state: HeadlessState, orig: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return (\n    !!piece &&\n    state.draggable.enabled &&\n    (state.movable.color === 'both' ||\n      (state.movable.color === piece.color && (state.turnColor === piece.color || state.premovable.enabled)))\n  );\n}\n\nexport function playPremove(state: HeadlessState): boolean {\n  const move = state.premovable.current;\n  if (!move) return false;\n  const orig = move[0],\n    dest = move[1];\n  let success = false;\n  if (canMove(state, orig, dest)) {\n    const result = baseUserMove(state, orig, dest);\n    if (result) {\n      const metadata: cg.MoveMetadata = { premove: true };\n      if (result !== true) metadata.captured = result;\n      callUserFunction(state.movable.events.after, orig, dest, metadata);\n      success = true;\n    }\n  }\n  unsetPremove(state);\n  return success;\n}\n\nexport function playPredrop(state: HeadlessState, validate: (drop: cg.Drop) => boolean): boolean {\n  const drop = state.predroppable.current;\n  let success = false;\n  if (!drop) return false;\n  if (validate(drop)) {\n    const piece = {\n      role: drop.role,\n      color: state.movable.color,\n    } as cg.Piece;\n    if (baseNewPiece(state, piece, drop.key)) {\n      callUserFunction(state.movable.events.afterNewPiece, drop.role, drop.key, {\n        premove: false,\n        predrop: true,\n      });\n      success = true;\n    }\n  }\n  unsetPredrop(state);\n  return success;\n}\n\nexport function cancelMove(state: HeadlessState): void {\n  unsetPremove(state);\n  unsetPredrop(state);\n  unselect(state);\n}\n\nexport function stop(state: HeadlessState): void {\n  state.movable.color = state.movable.dests = state.animation.current = undefined;\n  cancelMove(state);\n}\n\nexport function getKeyAtDomPos(\n  pos: cg.NumberPair,\n  asWhite: boolean,\n  bounds: DOMRectReadOnly,\n): cg.Key | undefined {\n  let file = Math.floor((8 * (pos[0] - bounds.left)) / bounds.width);\n  if (!asWhite) file = 7 - file;\n  let rank = 7 - Math.floor((8 * (pos[1] - bounds.top)) / bounds.height);\n  if (!asWhite) rank = 7 - rank;\n  return file >= 0 && file < 8 && rank >= 0 && rank < 8 ? pos2key([file, rank]) : undefined;\n}\n\nexport function getSnappedKeyAtDomPos(\n  orig: cg.Key,\n  pos: cg.NumberPair,\n  asWhite: boolean,\n  bounds: DOMRectReadOnly,\n): cg.Key | undefined {\n  const origPos = key2pos(orig);\n  const validSnapPos = allPos.filter(\n    pos2 =>\n      queen(origPos[0], origPos[1], pos2[0], pos2[1]) || knight(origPos[0], origPos[1], pos2[0], pos2[1]),\n  );\n  const validSnapCenters = validSnapPos.map(pos2 => computeSquareCenter(pos2key(pos2), asWhite, bounds));\n  const validSnapDistances = validSnapCenters.map(pos2 => distanceSq(pos, pos2));\n  const [, closestSnapIndex] = validSnapDistances.reduce(\n    (a, b, index) => (a[0] < b ? a : [b, index]),\n    [validSnapDistances[0], 0],\n  );\n  return pos2key(validSnapPos[closestSnapIndex]);\n}\n\nexport const whitePov = (s: HeadlessState): boolean => s.orientation === 'white';\n","import * as cg from './types.js';\nexport const invRanks = [...cg.ranks].reverse();\nexport const allKeys = Array.prototype.concat(...cg.files.map(c => cg.ranks.map(r => c + r)));\nexport const pos2key = (pos) => allKeys[8 * pos[0] + pos[1]];\nexport const key2pos = (k) => [k.charCodeAt(0) - 97, k.charCodeAt(1) - 49];\nexport const uciToMove = (uci) => {\n    if (!uci)\n        return undefined;\n    if (uci[1] === '@')\n        return [uci.slice(2, 4)];\n    return [uci.slice(0, 2), uci.slice(2, 4)];\n};\nexport const allPos = allKeys.map(key2pos);\nexport function memo(f) {\n    let v;\n    const ret = () => {\n        if (v === undefined)\n            v = f();\n        return v;\n    };\n    ret.clear = () => {\n        v = undefined;\n    };\n    return ret;\n}\nexport const timer = () => {\n    let startAt;\n    return {\n        start() {\n            startAt = performance.now();\n        },\n        cancel() {\n            startAt = undefined;\n        },\n        stop() {\n            if (!startAt)\n                return 0;\n            const time = performance.now() - startAt;\n            startAt = undefined;\n            return time;\n        },\n    };\n};\nexport const opposite = (c) => (c === 'white' ? 'black' : 'white');\nexport const distanceSq = (pos1, pos2) => {\n    const dx = pos1[0] - pos2[0], dy = pos1[1] - pos2[1];\n    return dx * dx + dy * dy;\n};\nexport const samePiece = (p1, p2) => p1.role === p2.role && p1.color === p2.color;\nexport const posToTranslate = (bounds) => (pos, asWhite) => [\n    ((asWhite ? pos[0] : 7 - pos[0]) * bounds.width) / 8,\n    ((asWhite ? 7 - pos[1] : pos[1]) * bounds.height) / 8,\n];\nexport const translate = (el, pos) => {\n    el.style.transform = `translate(${pos[0]}px,${pos[1]}px)`;\n};\nexport const translateAndScale = (el, pos, scale = 1) => {\n    el.style.transform = `translate(${pos[0]}px,${pos[1]}px) scale(${scale})`;\n};\nexport const setVisible = (el, v) => {\n    el.style.visibility = v ? 'visible' : 'hidden';\n};\nexport const eventPosition = (e) => {\n    var _a;\n    if (e.clientX || e.clientX === 0)\n        return [e.clientX, e.clientY];\n    if ((_a = e.targetTouches) === null || _a === void 0 ? void 0 : _a[0])\n        return [e.targetTouches[0].clientX, e.targetTouches[0].clientY];\n    return; // touchend has no position!\n};\nexport const isRightButton = (e) => e.button === 2;\nexport const createEl = (tagName, className) => {\n    const el = document.createElement(tagName);\n    if (className)\n        el.className = className;\n    return el;\n};\nexport function computeSquareCenter(key, asWhite, bounds) {\n    const pos = key2pos(key);\n    if (!asWhite) {\n        pos[0] = 7 - pos[0];\n        pos[1] = 7 - pos[1];\n    }\n    return [\n        bounds.left + (bounds.width * pos[0]) / 8 + bounds.width / 16,\n        bounds.top + (bounds.height * (7 - pos[1])) / 8 + bounds.height / 16,\n    ];\n}\n//# sourceMappingURL=util.js.map","import * as cg from './types.js';\n\nexport const invRanks: readonly cg.Rank[] = [...cg.ranks].reverse();\n\nexport const allKeys: readonly cg.Key[] = Array.prototype.concat(\n  ...cg.files.map(c => cg.ranks.map(r => c + r)),\n);\n\nexport const pos2key = (pos: cg.Pos): cg.Key => allKeys[8 * pos[0] + pos[1]];\n\nexport const key2pos = (k: cg.Key): cg.Pos => [k.charCodeAt(0) - 97, k.charCodeAt(1) - 49];\n\nexport const uciToMove = (uci: string | undefined): cg.Key[] | undefined => {\n  if (!uci) return undefined;\n  if (uci[1] === '@') return [uci.slice(2, 4) as cg.Key];\n  return [uci.slice(0, 2), uci.slice(2, 4)] as cg.Key[];\n};\n\nexport const allPos: readonly cg.Pos[] = allKeys.map(key2pos);\n\nexport function memo<A>(f: () => A): cg.Memo<A> {\n  let v: A | undefined;\n  const ret = (): A => {\n    if (v === undefined) v = f();\n    return v;\n  };\n  ret.clear = () => {\n    v = undefined;\n  };\n  return ret;\n}\n\nexport const timer = (): cg.Timer => {\n  let startAt: number | undefined;\n  return {\n    start() {\n      startAt = performance.now();\n    },\n    cancel() {\n      startAt = undefined;\n    },\n    stop() {\n      if (!startAt) return 0;\n      const time = performance.now() - startAt;\n      startAt = undefined;\n      return time;\n    },\n  };\n};\n\nexport const opposite = (c: cg.Color): cg.Color => (c === 'white' ? 'black' : 'white');\n\nexport const distanceSq = (pos1: cg.Pos, pos2: cg.Pos): number => {\n  const dx = pos1[0] - pos2[0],\n    dy = pos1[1] - pos2[1];\n  return dx * dx + dy * dy;\n};\n\nexport const samePiece = (p1: cg.Piece, p2: cg.Piece): boolean =>\n  p1.role === p2.role && p1.color === p2.color;\n\nexport const posToTranslate =\n  (bounds: DOMRectReadOnly): ((pos: cg.Pos, asWhite: boolean) => cg.NumberPair) =>\n  (pos, asWhite) => [\n    ((asWhite ? pos[0] : 7 - pos[0]) * bounds.width) / 8,\n    ((asWhite ? 7 - pos[1] : pos[1]) * bounds.height) / 8,\n  ];\n\nexport const translate = (el: HTMLElement, pos: cg.NumberPair): void => {\n  el.style.transform = `translate(${pos[0]}px,${pos[1]}px)`;\n};\n\nexport const translateAndScale = (el: HTMLElement, pos: cg.NumberPair, scale = 1): void => {\n  el.style.transform = `translate(${pos[0]}px,${pos[1]}px) scale(${scale})`;\n};\n\nexport const setVisible = (el: HTMLElement, v: boolean): void => {\n  el.style.visibility = v ? 'visible' : 'hidden';\n};\n\nexport const eventPosition = (e: cg.MouchEvent): cg.NumberPair | undefined => {\n  if (e.clientX || e.clientX === 0) return [e.clientX, e.clientY!];\n  if (e.targetTouches?.[0]) return [e.targetTouches[0].clientX, e.targetTouches[0].clientY];\n  return; // touchend has no position!\n};\n\nexport const isRightButton = (e: cg.MouchEvent): boolean => e.button === 2;\n\nexport const createEl = (tagName: string, className?: string): HTMLElement => {\n  const el = document.createElement(tagName);\n  if (className) el.className = className;\n  return el;\n};\n\nexport function computeSquareCenter(key: cg.Key, asWhite: boolean, bounds: DOMRectReadOnly): cg.NumberPair {\n  const pos = key2pos(key);\n  if (!asWhite) {\n    pos[0] = 7 - pos[0];\n    pos[1] = 7 - pos[1];\n  }\n  return [\n    bounds.left + (bounds.width * pos[0]) / 8 + bounds.width / 16,\n    bounds.top + (bounds.height * (7 - pos[1])) / 8 + bounds.height / 16,\n  ];\n}\n","export const colors = ['white', 'black'];\nexport const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\nexport const ranks = ['1', '2', '3', '4', '5', '6', '7', '8'];\n//# sourceMappingURL=types.js.map","export type Color = (typeof colors)[number];\nexport type Role = 'king' | 'queen' | 'rook' | 'bishop' | 'knight' | 'pawn';\nexport type File = (typeof files)[number];\nexport type Rank = (typeof ranks)[number];\nexport type Key = 'a0' | `${File}${Rank}`;\nexport type FEN = string;\nexport type Pos = [number, number];\nexport interface Piece {\n  role: Role;\n  color: Color;\n  promoted?: boolean;\n}\nexport interface Drop {\n  role: Role;\n  key: Key;\n}\nexport type Pieces = Map<Key, Piece>;\nexport type PiecesDiff = Map<Key, Piece | undefined>;\n\nexport type KeyPair = [Key, Key];\n\nexport type NumberPair = [number, number];\n\nexport type NumberQuad = [number, number, number, number];\n\nexport interface Rect {\n  left: number;\n  top: number;\n  width: number;\n  height: number;\n}\n\nexport type Dests = Map<Key, Key[]>;\n\nexport interface Elements {\n  board: HTMLElement;\n  wrap: HTMLElement;\n  container: HTMLElement;\n  ghost?: HTMLElement;\n  svg?: SVGElement;\n  customSvg?: SVGElement;\n  autoPieces?: HTMLElement;\n}\nexport interface Dom {\n  elements: Elements;\n  bounds: Memo<DOMRectReadOnly>;\n  redraw: () => void;\n  redrawNow: (skipSvg?: boolean) => void;\n  unbind?: Unbind;\n  destroyed?: boolean;\n}\nexport interface Exploding {\n  stage: number;\n  keys: readonly Key[];\n}\n\nexport interface MoveMetadata {\n  premove: boolean;\n  ctrlKey?: boolean;\n  holdTime?: number;\n  captured?: Piece;\n  predrop?: boolean;\n}\nexport interface SetPremoveMetadata {\n  ctrlKey?: boolean;\n}\n\nexport type MouchEvent = Event & Partial<MouseEvent & TouchEvent>;\n\nexport interface KeyedNode extends HTMLElement {\n  cgKey: Key;\n}\nexport interface PieceNode extends KeyedNode {\n  tagName: 'PIECE';\n  cgPiece: string;\n  cgAnimating?: boolean;\n  cgFading?: boolean;\n  cgDragging?: boolean;\n  cgScale?: number;\n}\nexport interface SquareNode extends KeyedNode {\n  tagName: 'SQUARE';\n}\n\nexport interface Memo<A> {\n  (): A;\n  clear: () => void;\n}\n\nexport interface Timer {\n  start: () => void;\n  cancel: () => void;\n  stop: () => number;\n}\n\nexport type Redraw = () => void;\nexport type Unbind = () => void;\nexport type Milliseconds = number;\nexport type KHz = number;\n\nexport const colors = ['white', 'black'] as const;\nexport const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] as const;\nexport const ranks = ['1', '2', '3', '4', '5', '6', '7', '8'] as const;\n\nexport type RanksPosition = 'left' | 'right';\n\nexport type BrushColor = 'green' | 'red' | 'blue' | 'yellow';\n\nexport type SquareClasses = Map<Key, string>;\n","import * as util from './util.js';\nconst diff = (a, b) => Math.abs(a - b);\nconst pawn = (color) => (x1, y1, x2, y2) => diff(x1, x2) < 2 &&\n    (color === 'white'\n        ? // allow 2 squares from first two ranks, for horde\n            y2 === y1 + 1 || (y1 <= 1 && y2 === y1 + 2 && x1 === x2)\n        : y2 === y1 - 1 || (y1 >= 6 && y2 === y1 - 2 && x1 === x2));\nexport const knight = (x1, y1, x2, y2) => {\n    const xd = diff(x1, x2);\n    const yd = diff(y1, y2);\n    return (xd === 1 && yd === 2) || (xd === 2 && yd === 1);\n};\nconst bishop = (x1, y1, x2, y2) => {\n    return diff(x1, x2) === diff(y1, y2);\n};\nconst rook = (x1, y1, x2, y2) => {\n    return x1 === x2 || y1 === y2;\n};\nexport const queen = (x1, y1, x2, y2) => {\n    return bishop(x1, y1, x2, y2) || rook(x1, y1, x2, y2);\n};\nconst king = (color, rookFiles, canCastle) => (x1, y1, x2, y2) => (diff(x1, x2) < 2 && diff(y1, y2) < 2) ||\n    (canCastle &&\n        y1 === y2 &&\n        y1 === (color === 'white' ? 0 : 7) &&\n        ((x1 === 4 && ((x2 === 2 && rookFiles.includes(0)) || (x2 === 6 && rookFiles.includes(7)))) ||\n            rookFiles.includes(x2)));\nfunction rookFilesOf(pieces, color) {\n    const backrank = color === 'white' ? '1' : '8';\n    const files = [];\n    for (const [key, piece] of pieces) {\n        if (key[1] === backrank && piece.color === color && piece.role === 'rook') {\n            files.push(util.key2pos(key)[0]);\n        }\n    }\n    return files;\n}\nexport function premove(pieces, key, canCastle) {\n    const piece = pieces.get(key);\n    if (!piece)\n        return [];\n    const pos = util.key2pos(key), r = piece.role, mobility = r === 'pawn'\n        ? pawn(piece.color)\n        : r === 'knight'\n            ? knight\n            : r === 'bishop'\n                ? bishop\n                : r === 'rook'\n                    ? rook\n                    : r === 'queen'\n                        ? queen\n                        : king(piece.color, rookFilesOf(pieces, piece.color), canCastle);\n    return util.allPos\n        .filter(pos2 => (pos[0] !== pos2[0] || pos[1] !== pos2[1]) && mobility(pos[0], pos[1], pos2[0], pos2[1]))\n        .map(util.pos2key);\n}\n//# sourceMappingURL=premove.js.map","import * as util from './util.js';\nimport * as cg from './types.js';\n\ntype Mobility = (x1: number, y1: number, x2: number, y2: number) => boolean;\n\nconst diff = (a: number, b: number): number => Math.abs(a - b);\n\nconst pawn =\n  (color: cg.Color): Mobility =>\n  (x1, y1, x2, y2) =>\n    diff(x1, x2) < 2 &&\n    (color === 'white'\n      ? // allow 2 squares from first two ranks, for horde\n        y2 === y1 + 1 || (y1 <= 1 && y2 === y1 + 2 && x1 === x2)\n      : y2 === y1 - 1 || (y1 >= 6 && y2 === y1 - 2 && x1 === x2));\n\nexport const knight: Mobility = (x1, y1, x2, y2) => {\n  const xd = diff(x1, x2);\n  const yd = diff(y1, y2);\n  return (xd === 1 && yd === 2) || (xd === 2 && yd === 1);\n};\n\nconst bishop: Mobility = (x1, y1, x2, y2) => {\n  return diff(x1, x2) === diff(y1, y2);\n};\n\nconst rook: Mobility = (x1, y1, x2, y2) => {\n  return x1 === x2 || y1 === y2;\n};\n\nexport const queen: Mobility = (x1, y1, x2, y2) => {\n  return bishop(x1, y1, x2, y2) || rook(x1, y1, x2, y2);\n};\n\nconst king =\n  (color: cg.Color, rookFiles: number[], canCastle: boolean): Mobility =>\n  (x1, y1, x2, y2) =>\n    (diff(x1, x2) < 2 && diff(y1, y2) < 2) ||\n    (canCastle &&\n      y1 === y2 &&\n      y1 === (color === 'white' ? 0 : 7) &&\n      ((x1 === 4 && ((x2 === 2 && rookFiles.includes(0)) || (x2 === 6 && rookFiles.includes(7)))) ||\n        rookFiles.includes(x2)));\n\nfunction rookFilesOf(pieces: cg.Pieces, color: cg.Color) {\n  const backrank = color === 'white' ? '1' : '8';\n  const files = [];\n  for (const [key, piece] of pieces) {\n    if (key[1] === backrank && piece.color === color && piece.role === 'rook') {\n      files.push(util.key2pos(key)[0]);\n    }\n  }\n  return files;\n}\n\nexport function premove(pieces: cg.Pieces, key: cg.Key, canCastle: boolean): cg.Key[] {\n  const piece = pieces.get(key);\n  if (!piece) return [];\n  const pos = util.key2pos(key),\n    r = piece.role,\n    mobility: Mobility =\n      r === 'pawn'\n        ? pawn(piece.color)\n        : r === 'knight'\n          ? knight\n          : r === 'bishop'\n            ? bishop\n            : r === 'rook'\n              ? rook\n              : r === 'queen'\n                ? queen\n                : king(piece.color, rookFilesOf(pieces, piece.color), canCastle);\n  return util.allPos\n    .filter(pos2 => (pos[0] !== pos2[0] || pos[1] !== pos2[1]) && mobility(pos[0], pos[1], pos2[0], pos2[1]))\n    .map(util.pos2key);\n}\n","import { pos2key, invRanks } from './util.js';\nimport * as cg from './types.js';\nexport const initial = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\nconst roles = {\n    p: 'pawn',\n    r: 'rook',\n    n: 'knight',\n    b: 'bishop',\n    q: 'queen',\n    k: 'king',\n};\nconst letters = {\n    pawn: 'p',\n    rook: 'r',\n    knight: 'n',\n    bishop: 'b',\n    queen: 'q',\n    king: 'k',\n};\nexport function read(fen) {\n    if (fen === 'start')\n        fen = initial;\n    const pieces = new Map();\n    let row = 7, col = 0;\n    for (const c of fen) {\n        switch (c) {\n            case ' ':\n            case '[':\n                return pieces;\n            case '/':\n                --row;\n                if (row < 0)\n                    return pieces;\n                col = 0;\n                break;\n            case '~': {\n                const piece = pieces.get(pos2key([col - 1, row]));\n                if (piece)\n                    piece.promoted = true;\n                break;\n            }\n            default: {\n                const nb = c.charCodeAt(0);\n                if (nb < 57)\n                    col += nb - 48;\n                else {\n                    const role = c.toLowerCase();\n                    pieces.set(pos2key([col, row]), {\n                        role: roles[role],\n                        color: c === role ? 'black' : 'white',\n                    });\n                    ++col;\n                }\n            }\n        }\n    }\n    return pieces;\n}\nexport function write(pieces) {\n    return invRanks\n        .map(y => cg.files\n        .map(x => {\n        const piece = pieces.get((x + y));\n        if (piece) {\n            let p = letters[piece.role];\n            if (piece.color === 'white')\n                p = p.toUpperCase();\n            if (piece.promoted)\n                p += '~';\n            return p;\n        }\n        else\n            return '1';\n    })\n        .join(''))\n        .join('/')\n        .replace(/1{2,}/g, s => s.length.toString());\n}\n//# sourceMappingURL=fen.js.map","import { pos2key, invRanks } from './util.js';\nimport * as cg from './types.js';\n\nexport const initial: cg.FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\n\nconst roles: { [letter: string]: cg.Role } = {\n  p: 'pawn',\n  r: 'rook',\n  n: 'knight',\n  b: 'bishop',\n  q: 'queen',\n  k: 'king',\n};\n\nconst letters = {\n  pawn: 'p',\n  rook: 'r',\n  knight: 'n',\n  bishop: 'b',\n  queen: 'q',\n  king: 'k',\n};\n\nexport function read(fen: cg.FEN): cg.Pieces {\n  if (fen === 'start') fen = initial;\n  const pieces: cg.Pieces = new Map();\n  let row = 7,\n    col = 0;\n  for (const c of fen) {\n    switch (c) {\n      case ' ':\n      case '[':\n        return pieces;\n      case '/':\n        --row;\n        if (row < 0) return pieces;\n        col = 0;\n        break;\n      case '~': {\n        const piece = pieces.get(pos2key([col - 1, row]));\n        if (piece) piece.promoted = true;\n        break;\n      }\n      default: {\n        const nb = c.charCodeAt(0);\n        if (nb < 57) col += nb - 48;\n        else {\n          const role = c.toLowerCase();\n          pieces.set(pos2key([col, row]), {\n            role: roles[role],\n            color: c === role ? 'black' : 'white',\n          });\n          ++col;\n        }\n      }\n    }\n  }\n  return pieces;\n}\n\nexport function write(pieces: cg.Pieces): cg.FEN {\n  return invRanks\n    .map(y =>\n      cg.files\n        .map(x => {\n          const piece = pieces.get((x + y) as cg.Key);\n          if (piece) {\n            let p = letters[piece.role];\n            if (piece.color === 'white') p = p.toUpperCase();\n            if (piece.promoted) p += '~';\n            return p;\n          } else return '1';\n        })\n        .join(''),\n    )\n    .join('/')\n    .replace(/1{2,}/g, s => s.length.toString());\n}\n","import { setCheck, setSelected } from './board.js';\nimport { read as fenRead } from './fen.js';\nexport function applyAnimation(state, config) {\n    if (config.animation) {\n        deepMerge(state.animation, config.animation);\n        // no need for such short animations\n        if ((state.animation.duration || 0) < 70)\n            state.animation.enabled = false;\n    }\n}\nexport function configure(state, config) {\n    var _a, _b, _c;\n    // don't merge destinations and autoShapes. Just override.\n    if ((_a = config.movable) === null || _a === void 0 ? void 0 : _a.dests)\n        state.movable.dests = undefined;\n    if ((_b = config.drawable) === null || _b === void 0 ? void 0 : _b.autoShapes)\n        state.drawable.autoShapes = [];\n    deepMerge(state, config);\n    // if a fen was provided, replace the pieces\n    if (config.fen) {\n        state.pieces = fenRead(config.fen);\n        state.drawable.shapes = ((_c = config.drawable) === null || _c === void 0 ? void 0 : _c.shapes) || [];\n    }\n    // apply config values that could be undefined yet meaningful\n    if ('check' in config)\n        setCheck(state, config.check || false);\n    if ('lastMove' in config && !config.lastMove)\n        state.lastMove = undefined;\n    // in case of ZH drop last move, there's a single square.\n    // if the previous last move had two squares,\n    // the merge algorithm will incorrectly keep the second square.\n    else if (config.lastMove)\n        state.lastMove = config.lastMove;\n    // fix move/premove dests\n    if (state.selected)\n        setSelected(state, state.selected);\n    applyAnimation(state, config);\n    if (!state.movable.rookCastle && state.movable.dests) {\n        const rank = state.movable.color === 'white' ? '1' : '8', kingStartPos = ('e' + rank), dests = state.movable.dests.get(kingStartPos), king = state.pieces.get(kingStartPos);\n        if (!dests || !king || king.role !== 'king')\n            return;\n        state.movable.dests.set(kingStartPos, dests.filter(d => !(d === 'a' + rank && dests.includes(('c' + rank))) &&\n            !(d === 'h' + rank && dests.includes(('g' + rank)))));\n    }\n}\nfunction deepMerge(base, extend) {\n    for (const key in extend) {\n        if (Object.prototype.hasOwnProperty.call(extend, key)) {\n            if (Object.prototype.hasOwnProperty.call(base, key) &&\n                isPlainObject(base[key]) &&\n                isPlainObject(extend[key]))\n                deepMerge(base[key], extend[key]);\n            else\n                base[key] = extend[key];\n        }\n    }\n}\nfunction isPlainObject(o) {\n    if (typeof o !== 'object' || o === null)\n        return false;\n    const proto = Object.getPrototypeOf(o);\n    return proto === Object.prototype || proto === null;\n}\n//# sourceMappingURL=config.js.map","import { HeadlessState } from './state.js';\nimport { setCheck, setSelected } from './board.js';\nimport { read as fenRead } from './fen.js';\nimport { DrawShape, DrawBrushes } from './draw.js';\nimport * as cg from './types.js';\n\nexport interface Config {\n  fen?: cg.FEN; // chess position in Forsyth notation\n  orientation?: cg.Color; // board orientation. white | black\n  turnColor?: cg.Color; // turn to play. white | black\n  check?: cg.Color | boolean; // true for current color, false to unset\n  lastMove?: cg.Key[]; // squares part of the last move [\"c3\", \"c4\"]\n  selected?: cg.Key; // square currently selected \"a1\"\n  coordinates?: boolean; // include coords attributes\n  coordinatesOnSquares?: boolean; // include coords attributes on every square\n  autoCastle?: boolean; // immediately complete the castle by moving the rook after king move\n  viewOnly?: boolean; // don't bind events: the user will never be able to move pieces around\n  disableContextMenu?: boolean; // because who needs a context menu on a chessboard\n  addPieceZIndex?: boolean; // adds z-index values to pieces (for 3D)\n  addDimensionsCssVarsTo?: HTMLElement; // add ---cg-width and ---cg-height CSS vars containing the board's dimensions to this element\n  blockTouchScroll?: boolean; // block scrolling via touch dragging on the board, e.g. for coordinate training\n  // pieceKey: boolean; // add a data-key attribute to piece elements\n  trustAllEvents?: boolean; // disable checking for human only input (e.isTrusted)\n  highlight?: {\n    lastMove?: boolean; // add last-move class to squares\n    check?: boolean; // add check class to squares\n    custom?: cg.SquareClasses; // add custom classes to custom squares\n  };\n  animation?: {\n    enabled?: boolean;\n    duration?: number;\n  };\n  movable?: {\n    free?: boolean; // all moves are valid - board editor\n    color?: cg.Color | 'both'; // color that can move. white | black | both | undefined\n    dests?: cg.Dests; // valid moves. {\"a2\" [\"a3\" \"a4\"] \"b1\" [\"a3\" \"c3\"]}\n    showDests?: boolean; // whether to add the move-dest class on squares\n    events?: {\n      after?: (orig: cg.Key, dest: cg.Key, metadata: cg.MoveMetadata) => void; // called after the move has been played\n      afterNewPiece?: (role: cg.Role, key: cg.Key, metadata: cg.MoveMetadata) => void; // called after a new piece is dropped on the board\n    };\n    rookCastle?: boolean; // castle by moving the king to the rook\n  };\n  premovable?: {\n    enabled?: boolean; // allow premoves for color that can not move\n    showDests?: boolean; // whether to add the premove-dest class on squares\n    castle?: boolean; // whether to allow king castle premoves\n    dests?: cg.Key[]; // premove destinations for the current selection\n    customDests?: cg.Dests; // use custom valid premoves. {\"a2\" [\"a3\" \"a4\"] \"b1\" [\"a3\" \"c3\"]}\n    events?: {\n      set?: (orig: cg.Key, dest: cg.Key, metadata?: cg.SetPremoveMetadata) => void; // called after the premove has been set\n      unset?: () => void; // called after the premove has been unset\n    };\n  };\n  predroppable?: {\n    enabled?: boolean; // allow predrops for color that can not move\n    events?: {\n      set?: (role: cg.Role, key: cg.Key) => void; // called after the predrop has been set\n      unset?: () => void; // called after the predrop has been unset\n    };\n  };\n  draggable?: {\n    enabled?: boolean; // allow moves & premoves to use drag'n drop\n    distance?: number; // minimum distance to initiate a drag; in pixels\n    autoDistance?: boolean; // lets chessground set distance to zero when user drags pieces\n    showGhost?: boolean; // show ghost of piece being dragged\n    deleteOnDropOff?: boolean; // delete a piece when it is dropped off the board\n  };\n  selectable?: {\n    // disable to enforce dragging over click-click move\n    enabled?: boolean;\n  };\n  events?: {\n    change?: () => void; // called after the situation changes on the board\n    // called after a piece has been moved.\n    // capturedPiece is undefined or like {color: 'white'; 'role': 'queen'}\n    move?: (orig: cg.Key, dest: cg.Key, capturedPiece?: cg.Piece) => void;\n    dropNewPiece?: (piece: cg.Piece, key: cg.Key) => void;\n    select?: (key: cg.Key) => void; // called when a square is selected\n    insert?: (elements: cg.Elements) => void; // when the board DOM has been (re)inserted\n  };\n  drawable?: {\n    enabled?: boolean; // can draw\n    visible?: boolean; // can view\n    defaultSnapToValidMove?: boolean;\n    // false to keep the drawing if a movable piece is clicked.\n    // Clicking an empty square or immovable piece will clear the drawing regardless.\n    eraseOnClick?: boolean;\n    shapes?: DrawShape[];\n    autoShapes?: DrawShape[];\n    brushes?: DrawBrushes;\n    onChange?: (shapes: DrawShape[]) => void; // called after drawable shapes change\n  };\n}\n\nexport function applyAnimation(state: HeadlessState, config: Config): void {\n  if (config.animation) {\n    deepMerge(state.animation, config.animation);\n    // no need for such short animations\n    if ((state.animation.duration || 0) < 70) state.animation.enabled = false;\n  }\n}\n\nexport function configure(state: HeadlessState, config: Config): void {\n  // don't merge destinations and autoShapes. Just override.\n  if (config.movable?.dests) state.movable.dests = undefined;\n  if (config.drawable?.autoShapes) state.drawable.autoShapes = [];\n\n  deepMerge(state, config);\n\n  // if a fen was provided, replace the pieces\n  if (config.fen) {\n    state.pieces = fenRead(config.fen);\n    state.drawable.shapes = config.drawable?.shapes || [];\n  }\n\n  // apply config values that could be undefined yet meaningful\n  if ('check' in config) setCheck(state, config.check || false);\n  if ('lastMove' in config && !config.lastMove) state.lastMove = undefined;\n  // in case of ZH drop last move, there's a single square.\n  // if the previous last move had two squares,\n  // the merge algorithm will incorrectly keep the second square.\n  else if (config.lastMove) state.lastMove = config.lastMove;\n\n  // fix move/premove dests\n  if (state.selected) setSelected(state, state.selected);\n\n  applyAnimation(state, config);\n\n  if (!state.movable.rookCastle && state.movable.dests) {\n    const rank = state.movable.color === 'white' ? '1' : '8',\n      kingStartPos = ('e' + rank) as cg.Key,\n      dests = state.movable.dests.get(kingStartPos),\n      king = state.pieces.get(kingStartPos);\n    if (!dests || !king || king.role !== 'king') return;\n    state.movable.dests.set(\n      kingStartPos,\n      dests.filter(\n        d =>\n          !(d === 'a' + rank && dests.includes(('c' + rank) as cg.Key)) &&\n          !(d === 'h' + rank && dests.includes(('g' + rank) as cg.Key)),\n      ),\n    );\n  }\n}\n\nfunction deepMerge(base: any, extend: any): void {\n  for (const key in extend) {\n    if (Object.prototype.hasOwnProperty.call(extend, key)) {\n      if (\n        Object.prototype.hasOwnProperty.call(base, key) &&\n        isPlainObject(base[key]) &&\n        isPlainObject(extend[key])\n      )\n        deepMerge(base[key], extend[key]);\n      else base[key] = extend[key];\n    }\n  }\n}\n\nfunction isPlainObject(o: unknown): boolean {\n  if (typeof o !== 'object' || o === null) return false;\n  const proto = Object.getPrototypeOf(o);\n  return proto === Object.prototype || proto === null;\n}\n","import * as util from './util.js';\nexport const anim = (mutation, state) => state.animation.enabled ? animate(mutation, state) : render(mutation, state);\nexport function render(mutation, state) {\n    const result = mutation(state);\n    state.dom.redraw();\n    return result;\n}\nconst makePiece = (key, piece) => ({\n    key: key,\n    pos: util.key2pos(key),\n    piece: piece,\n});\nconst closer = (piece, pieces) => pieces.sort((p1, p2) => util.distanceSq(piece.pos, p1.pos) - util.distanceSq(piece.pos, p2.pos))[0];\nfunction computePlan(prevPieces, current) {\n    const anims = new Map(), animedOrigs = [], fadings = new Map(), missings = [], news = [], prePieces = new Map();\n    let curP, preP, vector;\n    for (const [k, p] of prevPieces) {\n        prePieces.set(k, makePiece(k, p));\n    }\n    for (const key of util.allKeys) {\n        curP = current.pieces.get(key);\n        preP = prePieces.get(key);\n        if (curP) {\n            if (preP) {\n                if (!util.samePiece(curP, preP.piece)) {\n                    missings.push(preP);\n                    news.push(makePiece(key, curP));\n                }\n            }\n            else\n                news.push(makePiece(key, curP));\n        }\n        else if (preP)\n            missings.push(preP);\n    }\n    for (const newP of news) {\n        preP = closer(newP, missings.filter(p => util.samePiece(newP.piece, p.piece)));\n        if (preP) {\n            vector = [preP.pos[0] - newP.pos[0], preP.pos[1] - newP.pos[1]];\n            anims.set(newP.key, vector.concat(vector));\n            animedOrigs.push(preP.key);\n        }\n    }\n    for (const p of missings) {\n        if (!animedOrigs.includes(p.key))\n            fadings.set(p.key, p.piece);\n    }\n    return {\n        anims: anims,\n        fadings: fadings,\n    };\n}\nfunction step(state, now) {\n    const cur = state.animation.current;\n    if (cur === undefined) {\n        // animation was canceled :(\n        if (!state.dom.destroyed)\n            state.dom.redrawNow();\n        return;\n    }\n    const rest = 1 - (now - cur.start) * cur.frequency;\n    if (rest <= 0) {\n        state.animation.current = undefined;\n        state.dom.redrawNow();\n    }\n    else {\n        const ease = easing(rest);\n        for (const cfg of cur.plan.anims.values()) {\n            cfg[2] = cfg[0] * ease;\n            cfg[3] = cfg[1] * ease;\n        }\n        state.dom.redrawNow(true); // optimisation: don't render SVG changes during animations\n        requestAnimationFrame((now = performance.now()) => step(state, now));\n    }\n}\nfunction animate(mutation, state) {\n    // clone state before mutating it\n    const prevPieces = new Map(state.pieces);\n    const result = mutation(state);\n    const plan = computePlan(prevPieces, state);\n    if (plan.anims.size || plan.fadings.size) {\n        const alreadyRunning = state.animation.current && state.animation.current.start;\n        state.animation.current = {\n            start: performance.now(),\n            frequency: 1 / state.animation.duration,\n            plan: plan,\n        };\n        if (!alreadyRunning)\n            step(state, performance.now());\n    }\n    else {\n        // don't animate, just render right away\n        state.dom.redraw();\n    }\n    return result;\n}\n// https://gist.github.com/gre/1650294\nconst easing = (t) => (t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1);\n//# sourceMappingURL=anim.js.map","import { State } from './state.js';\nimport * as util from './util.js';\nimport * as cg from './types.js';\n\nexport type Mutation<A> = (state: State) => A;\n\n// 0,1 animation goal\n// 2,3 animation current status\nexport type AnimVector = cg.NumberQuad;\n\nexport type AnimVectors = Map<cg.Key, AnimVector>;\n\nexport type AnimFadings = Map<cg.Key, cg.Piece>;\n\nexport interface AnimPlan {\n  anims: AnimVectors;\n  fadings: AnimFadings;\n}\n\nexport interface AnimCurrent {\n  start: DOMHighResTimeStamp;\n  frequency: cg.KHz;\n  plan: AnimPlan;\n}\n\nexport const anim = <A>(mutation: Mutation<A>, state: State): A =>\n  state.animation.enabled ? animate(mutation, state) : render(mutation, state);\n\nexport function render<A>(mutation: Mutation<A>, state: State): A {\n  const result = mutation(state);\n  state.dom.redraw();\n  return result;\n}\n\ninterface AnimPiece {\n  key: cg.Key;\n  pos: cg.Pos;\n  piece: cg.Piece;\n}\ntype AnimPieces = Map<cg.Key, AnimPiece>;\n\nconst makePiece = (key: cg.Key, piece: cg.Piece): AnimPiece => ({\n  key: key,\n  pos: util.key2pos(key),\n  piece: piece,\n});\n\nconst closer = (piece: AnimPiece, pieces: AnimPiece[]): AnimPiece | undefined =>\n  pieces.sort((p1, p2) => util.distanceSq(piece.pos, p1.pos) - util.distanceSq(piece.pos, p2.pos))[0];\n\nfunction computePlan(prevPieces: cg.Pieces, current: State): AnimPlan {\n  const anims: AnimVectors = new Map(),\n    animedOrigs: cg.Key[] = [],\n    fadings: AnimFadings = new Map(),\n    missings: AnimPiece[] = [],\n    news: AnimPiece[] = [],\n    prePieces: AnimPieces = new Map();\n  let curP: cg.Piece | undefined, preP: AnimPiece | undefined, vector: cg.NumberPair;\n  for (const [k, p] of prevPieces) {\n    prePieces.set(k, makePiece(k, p));\n  }\n  for (const key of util.allKeys) {\n    curP = current.pieces.get(key);\n    preP = prePieces.get(key);\n    if (curP) {\n      if (preP) {\n        if (!util.samePiece(curP, preP.piece)) {\n          missings.push(preP);\n          news.push(makePiece(key, curP));\n        }\n      } else news.push(makePiece(key, curP));\n    } else if (preP) missings.push(preP);\n  }\n  for (const newP of news) {\n    preP = closer(\n      newP,\n      missings.filter(p => util.samePiece(newP.piece, p.piece)),\n    );\n    if (preP) {\n      vector = [preP.pos[0] - newP.pos[0], preP.pos[1] - newP.pos[1]];\n      anims.set(newP.key, vector.concat(vector) as AnimVector);\n      animedOrigs.push(preP.key);\n    }\n  }\n  for (const p of missings) {\n    if (!animedOrigs.includes(p.key)) fadings.set(p.key, p.piece);\n  }\n\n  return {\n    anims: anims,\n    fadings: fadings,\n  };\n}\n\nfunction step(state: State, now: DOMHighResTimeStamp): void {\n  const cur = state.animation.current;\n  if (cur === undefined) {\n    // animation was canceled :(\n    if (!state.dom.destroyed) state.dom.redrawNow();\n    return;\n  }\n  const rest = 1 - (now - cur.start) * cur.frequency;\n  if (rest <= 0) {\n    state.animation.current = undefined;\n    state.dom.redrawNow();\n  } else {\n    const ease = easing(rest);\n    for (const cfg of cur.plan.anims.values()) {\n      cfg[2] = cfg[0] * ease;\n      cfg[3] = cfg[1] * ease;\n    }\n    state.dom.redrawNow(true); // optimisation: don't render SVG changes during animations\n    requestAnimationFrame((now = performance.now()) => step(state, now));\n  }\n}\n\nfunction animate<A>(mutation: Mutation<A>, state: State): A {\n  // clone state before mutating it\n  const prevPieces: cg.Pieces = new Map(state.pieces);\n\n  const result = mutation(state);\n  const plan = computePlan(prevPieces, state);\n  if (plan.anims.size || plan.fadings.size) {\n    const alreadyRunning = state.animation.current && state.animation.current.start;\n    state.animation.current = {\n      start: performance.now(),\n      frequency: 1 / state.animation.duration,\n      plan: plan,\n    };\n    if (!alreadyRunning) step(state, performance.now());\n  } else {\n    // don't animate, just render right away\n    state.dom.redraw();\n  }\n  return result;\n}\n\n// https://gist.github.com/gre/1650294\nconst easing = (t: number): number => (t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1);\n","import * as board from './board.js';\nimport * as util from './util.js';\nimport { clear as drawClear } from './draw.js';\nimport { anim } from './anim.js';\nexport function start(s, e) {\n    if (!(s.trustAllEvents || e.isTrusted))\n        return; // only trust when trustAllEvents is enabled\n    if (e.buttons !== undefined && e.buttons > 1)\n        return; // only touch or left click\n    if (e.touches && e.touches.length > 1)\n        return; // support one finger touch only\n    const bounds = s.dom.bounds(), position = util.eventPosition(e), orig = board.getKeyAtDomPos(position, board.whitePov(s), bounds);\n    if (!orig)\n        return;\n    const piece = s.pieces.get(orig);\n    const previouslySelected = s.selected;\n    if (!previouslySelected &&\n        s.drawable.enabled &&\n        (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor))\n        drawClear(s);\n    // Prevent touch scroll and create no corresponding mouse event, if there\n    // is an intent to interact with the board.\n    if (e.cancelable !== false &&\n        (!e.touches || s.blockTouchScroll || piece || previouslySelected || pieceCloseTo(s, position)))\n        e.preventDefault();\n    else if (e.touches)\n        return; // Handle only corresponding mouse event https://github.com/lichess-org/chessground/pull/268\n    const hadPremove = !!s.premovable.current;\n    const hadPredrop = !!s.predroppable.current;\n    s.stats.ctrlKey = e.ctrlKey;\n    if (s.selected && board.canMove(s, s.selected, orig)) {\n        anim(state => board.selectSquare(state, orig), s);\n    }\n    else {\n        board.selectSquare(s, orig);\n    }\n    const stillSelected = s.selected === orig;\n    const element = pieceElementByKey(s, orig);\n    if (piece && element && stillSelected && board.isDraggable(s, orig)) {\n        s.draggable.current = {\n            orig,\n            piece,\n            origPos: position,\n            pos: position,\n            started: s.draggable.autoDistance && s.stats.dragged,\n            element,\n            previouslySelected,\n            originTarget: e.target,\n            keyHasChanged: false,\n        };\n        element.cgDragging = true;\n        element.classList.add('dragging');\n        // place ghost\n        const ghost = s.dom.elements.ghost;\n        if (ghost) {\n            ghost.className = `ghost ${piece.color} ${piece.role}`;\n            util.translate(ghost, util.posToTranslate(bounds)(util.key2pos(orig), board.whitePov(s)));\n            util.setVisible(ghost, true);\n        }\n        processDrag(s);\n    }\n    else {\n        if (hadPremove)\n            board.unsetPremove(s);\n        if (hadPredrop)\n            board.unsetPredrop(s);\n    }\n    s.dom.redraw();\n}\nfunction pieceCloseTo(s, pos) {\n    const asWhite = board.whitePov(s), bounds = s.dom.bounds(), radiusSq = Math.pow(bounds.width / 8, 2);\n    for (const key of s.pieces.keys()) {\n        const center = util.computeSquareCenter(key, asWhite, bounds);\n        if (util.distanceSq(center, pos) <= radiusSq)\n            return true;\n    }\n    return false;\n}\nexport function dragNewPiece(s, piece, e, force) {\n    const key = 'a0';\n    s.pieces.set(key, piece);\n    s.dom.redraw();\n    const position = util.eventPosition(e);\n    s.draggable.current = {\n        orig: key,\n        piece,\n        origPos: position,\n        pos: position,\n        started: true,\n        element: () => pieceElementByKey(s, key),\n        originTarget: e.target,\n        newPiece: true,\n        force: !!force,\n        keyHasChanged: false,\n    };\n    processDrag(s);\n}\nfunction processDrag(s) {\n    requestAnimationFrame(() => {\n        var _a;\n        const cur = s.draggable.current;\n        if (!cur)\n            return;\n        // cancel animations while dragging\n        if ((_a = s.animation.current) === null || _a === void 0 ? void 0 : _a.plan.anims.has(cur.orig))\n            s.animation.current = undefined;\n        // if moving piece is gone, cancel\n        const origPiece = s.pieces.get(cur.orig);\n        if (!origPiece || !util.samePiece(origPiece, cur.piece))\n            cancel(s);\n        else {\n            if (!cur.started && util.distanceSq(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2))\n                cur.started = true;\n            if (cur.started) {\n                // support lazy elements\n                if (typeof cur.element === 'function') {\n                    const found = cur.element();\n                    if (!found)\n                        return;\n                    found.cgDragging = true;\n                    found.classList.add('dragging');\n                    cur.element = found;\n                }\n                const bounds = s.dom.bounds();\n                util.translate(cur.element, [\n                    cur.pos[0] - bounds.left - bounds.width / 16,\n                    cur.pos[1] - bounds.top - bounds.height / 16,\n                ]);\n                cur.keyHasChanged || (cur.keyHasChanged = cur.orig !== board.getKeyAtDomPos(cur.pos, board.whitePov(s), bounds));\n            }\n        }\n        processDrag(s);\n    });\n}\nexport function move(s, e) {\n    // support one finger touch only\n    if (s.draggable.current && (!e.touches || e.touches.length < 2)) {\n        s.draggable.current.pos = util.eventPosition(e);\n    }\n}\nexport function end(s, e) {\n    const cur = s.draggable.current;\n    if (!cur)\n        return;\n    // create no corresponding mouse event\n    if (e.type === 'touchend' && e.cancelable !== false)\n        e.preventDefault();\n    // comparing with the origin target is an easy way to test that the end event\n    // has the same touch origin\n    if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {\n        s.draggable.current = undefined;\n        return;\n    }\n    board.unsetPremove(s);\n    board.unsetPredrop(s);\n    // touchend has no position; so use the last touchmove position instead\n    const eventPos = util.eventPosition(e) || cur.pos;\n    const dest = board.getKeyAtDomPos(eventPos, board.whitePov(s), s.dom.bounds());\n    if (dest && cur.started && cur.orig !== dest) {\n        if (cur.newPiece)\n            board.dropNewPiece(s, cur.orig, dest, cur.force);\n        else {\n            s.stats.ctrlKey = e.ctrlKey;\n            if (board.userMove(s, cur.orig, dest))\n                s.stats.dragged = true;\n        }\n    }\n    else if (cur.newPiece) {\n        s.pieces.delete(cur.orig);\n    }\n    else if (s.draggable.deleteOnDropOff && !dest) {\n        s.pieces.delete(cur.orig);\n        board.callUserFunction(s.events.change);\n    }\n    if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest))\n        board.unselect(s);\n    else if (!s.selectable.enabled)\n        board.unselect(s);\n    removeDragElements(s);\n    s.draggable.current = undefined;\n    s.dom.redraw();\n}\nexport function cancel(s) {\n    const cur = s.draggable.current;\n    if (cur) {\n        if (cur.newPiece)\n            s.pieces.delete(cur.orig);\n        s.draggable.current = undefined;\n        board.unselect(s);\n        removeDragElements(s);\n        s.dom.redraw();\n    }\n}\nfunction removeDragElements(s) {\n    const e = s.dom.elements;\n    if (e.ghost)\n        util.setVisible(e.ghost, false);\n}\nfunction pieceElementByKey(s, key) {\n    let el = s.dom.elements.board.firstChild;\n    while (el) {\n        if (el.cgKey === key && el.tagName === 'PIECE')\n            return el;\n        el = el.nextSibling;\n    }\n    return;\n}\n//# sourceMappingURL=drag.js.map","import { State } from './state.js';\nimport * as board from './board.js';\nimport * as util from './util.js';\nimport { clear as drawClear } from './draw.js';\nimport * as cg from './types.js';\nimport { anim } from './anim.js';\n\nexport interface DragCurrent {\n  orig: cg.Key; // orig key of dragging piece\n  piece: cg.Piece;\n  origPos: cg.NumberPair; // first event position\n  pos: cg.NumberPair; // latest event position\n  started: boolean; // whether the drag has started; as per the distance setting\n  element: cg.PieceNode | (() => cg.PieceNode | undefined);\n  newPiece?: boolean; // it it a new piece from outside the board\n  force?: boolean; // can the new piece replace an existing one (editor)\n  previouslySelected?: cg.Key;\n  originTarget: EventTarget | null;\n  keyHasChanged: boolean; // whether the drag has left the orig key\n}\n\nexport function start(s: State, e: cg.MouchEvent): void {\n  if (!(s.trustAllEvents || e.isTrusted)) return; // only trust when trustAllEvents is enabled\n  if (e.buttons !== undefined && e.buttons > 1) return; // only touch or left click\n  if (e.touches && e.touches.length > 1) return; // support one finger touch only\n  const bounds = s.dom.bounds(),\n    position = util.eventPosition(e)!,\n    orig = board.getKeyAtDomPos(position, board.whitePov(s), bounds);\n  if (!orig) return;\n  const piece = s.pieces.get(orig);\n  const previouslySelected = s.selected;\n  if (\n    !previouslySelected &&\n    s.drawable.enabled &&\n    (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor)\n  )\n    drawClear(s);\n  // Prevent touch scroll and create no corresponding mouse event, if there\n  // is an intent to interact with the board.\n  if (\n    e.cancelable !== false &&\n    (!e.touches || s.blockTouchScroll || piece || previouslySelected || pieceCloseTo(s, position))\n  )\n    e.preventDefault();\n  else if (e.touches) return; // Handle only corresponding mouse event https://github.com/lichess-org/chessground/pull/268\n\n  const hadPremove = !!s.premovable.current;\n  const hadPredrop = !!s.predroppable.current;\n  s.stats.ctrlKey = e.ctrlKey;\n  if (s.selected && board.canMove(s, s.selected, orig)) {\n    anim(state => board.selectSquare(state, orig), s);\n  } else {\n    board.selectSquare(s, orig);\n  }\n  const stillSelected = s.selected === orig;\n  const element = pieceElementByKey(s, orig);\n  if (piece && element && stillSelected && board.isDraggable(s, orig)) {\n    s.draggable.current = {\n      orig,\n      piece,\n      origPos: position,\n      pos: position,\n      started: s.draggable.autoDistance && s.stats.dragged,\n      element,\n      previouslySelected,\n      originTarget: e.target,\n      keyHasChanged: false,\n    };\n    element.cgDragging = true;\n    element.classList.add('dragging');\n    // place ghost\n    const ghost = s.dom.elements.ghost;\n    if (ghost) {\n      ghost.className = `ghost ${piece.color} ${piece.role}`;\n      util.translate(ghost, util.posToTranslate(bounds)(util.key2pos(orig), board.whitePov(s)));\n      util.setVisible(ghost, true);\n    }\n    processDrag(s);\n  } else {\n    if (hadPremove) board.unsetPremove(s);\n    if (hadPredrop) board.unsetPredrop(s);\n  }\n  s.dom.redraw();\n}\n\nfunction pieceCloseTo(s: State, pos: cg.NumberPair): boolean {\n  const asWhite = board.whitePov(s),\n    bounds = s.dom.bounds(),\n    radiusSq = Math.pow(bounds.width / 8, 2);\n  for (const key of s.pieces.keys()) {\n    const center = util.computeSquareCenter(key, asWhite, bounds);\n    if (util.distanceSq(center, pos) <= radiusSq) return true;\n  }\n  return false;\n}\n\nexport function dragNewPiece(s: State, piece: cg.Piece, e: cg.MouchEvent, force?: boolean): void {\n  const key: cg.Key = 'a0';\n  s.pieces.set(key, piece);\n  s.dom.redraw();\n\n  const position = util.eventPosition(e)!;\n\n  s.draggable.current = {\n    orig: key,\n    piece,\n    origPos: position,\n    pos: position,\n    started: true,\n    element: () => pieceElementByKey(s, key),\n    originTarget: e.target,\n    newPiece: true,\n    force: !!force,\n    keyHasChanged: false,\n  };\n  processDrag(s);\n}\n\nfunction processDrag(s: State): void {\n  requestAnimationFrame(() => {\n    const cur = s.draggable.current;\n    if (!cur) return;\n    // cancel animations while dragging\n    if (s.animation.current?.plan.anims.has(cur.orig)) s.animation.current = undefined;\n    // if moving piece is gone, cancel\n    const origPiece = s.pieces.get(cur.orig);\n    if (!origPiece || !util.samePiece(origPiece, cur.piece)) cancel(s);\n    else {\n      if (!cur.started && util.distanceSq(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2))\n        cur.started = true;\n      if (cur.started) {\n        // support lazy elements\n        if (typeof cur.element === 'function') {\n          const found = cur.element();\n          if (!found) return;\n          found.cgDragging = true;\n          found.classList.add('dragging');\n          cur.element = found;\n        }\n\n        const bounds = s.dom.bounds();\n        util.translate(cur.element, [\n          cur.pos[0] - bounds.left - bounds.width / 16,\n          cur.pos[1] - bounds.top - bounds.height / 16,\n        ]);\n\n        cur.keyHasChanged ||= cur.orig !== board.getKeyAtDomPos(cur.pos, board.whitePov(s), bounds);\n      }\n    }\n    processDrag(s);\n  });\n}\n\nexport function move(s: State, e: cg.MouchEvent): void {\n  // support one finger touch only\n  if (s.draggable.current && (!e.touches || e.touches.length < 2)) {\n    s.draggable.current.pos = util.eventPosition(e)!;\n  }\n}\n\nexport function end(s: State, e: cg.MouchEvent): void {\n  const cur = s.draggable.current;\n  if (!cur) return;\n  // create no corresponding mouse event\n  if (e.type === 'touchend' && e.cancelable !== false) e.preventDefault();\n  // comparing with the origin target is an easy way to test that the end event\n  // has the same touch origin\n  if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {\n    s.draggable.current = undefined;\n    return;\n  }\n  board.unsetPremove(s);\n  board.unsetPredrop(s);\n  // touchend has no position; so use the last touchmove position instead\n  const eventPos = util.eventPosition(e) || cur.pos;\n  const dest = board.getKeyAtDomPos(eventPos, board.whitePov(s), s.dom.bounds());\n  if (dest && cur.started && cur.orig !== dest) {\n    if (cur.newPiece) board.dropNewPiece(s, cur.orig, dest, cur.force);\n    else {\n      s.stats.ctrlKey = e.ctrlKey;\n      if (board.userMove(s, cur.orig, dest)) s.stats.dragged = true;\n    }\n  } else if (cur.newPiece) {\n    s.pieces.delete(cur.orig);\n  } else if (s.draggable.deleteOnDropOff && !dest) {\n    s.pieces.delete(cur.orig);\n    board.callUserFunction(s.events.change);\n  }\n  if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest))\n    board.unselect(s);\n  else if (!s.selectable.enabled) board.unselect(s);\n\n  removeDragElements(s);\n\n  s.draggable.current = undefined;\n  s.dom.redraw();\n}\n\nexport function cancel(s: State): void {\n  const cur = s.draggable.current;\n  if (cur) {\n    if (cur.newPiece) s.pieces.delete(cur.orig);\n    s.draggable.current = undefined;\n    board.unselect(s);\n    removeDragElements(s);\n    s.dom.redraw();\n  }\n}\n\nfunction removeDragElements(s: State): void {\n  const e = s.dom.elements;\n  if (e.ghost) util.setVisible(e.ghost, false);\n}\n\nfunction pieceElementByKey(s: State, key: cg.Key): cg.PieceNode | undefined {\n  let el = s.dom.elements.board.firstChild;\n  while (el) {\n    if ((el as cg.KeyedNode).cgKey === key && (el as cg.KeyedNode).tagName === 'PIECE')\n      return el as cg.PieceNode;\n    el = el.nextSibling;\n  }\n  return;\n}\n","import { unselect, cancelMove, getKeyAtDomPos, getSnappedKeyAtDomPos, whitePov } from './board.js';\nimport { eventPosition, isRightButton } from './util.js';\nconst brushes = ['green', 'red', 'blue', 'yellow'];\nexport function start(state, e) {\n    // support one finger touch only\n    if (e.touches && e.touches.length > 1)\n        return;\n    e.stopPropagation();\n    e.preventDefault();\n    e.ctrlKey ? unselect(state) : cancelMove(state);\n    const pos = eventPosition(e), orig = getKeyAtDomPos(pos, whitePov(state), state.dom.bounds());\n    if (!orig)\n        return;\n    state.drawable.current = {\n        orig,\n        pos,\n        brush: eventBrush(e),\n        snapToValidMove: state.drawable.defaultSnapToValidMove,\n    };\n    processDraw(state);\n}\nexport function processDraw(state) {\n    requestAnimationFrame(() => {\n        const cur = state.drawable.current;\n        if (cur) {\n            const keyAtDomPos = getKeyAtDomPos(cur.pos, whitePov(state), state.dom.bounds());\n            if (!keyAtDomPos) {\n                cur.snapToValidMove = false;\n            }\n            const mouseSq = cur.snapToValidMove\n                ? getSnappedKeyAtDomPos(cur.orig, cur.pos, whitePov(state), state.dom.bounds())\n                : keyAtDomPos;\n            if (mouseSq !== cur.mouseSq) {\n                cur.mouseSq = mouseSq;\n                cur.dest = mouseSq !== cur.orig ? mouseSq : undefined;\n                state.dom.redrawNow();\n            }\n            processDraw(state);\n        }\n    });\n}\nexport function move(state, e) {\n    if (state.drawable.current)\n        state.drawable.current.pos = eventPosition(e);\n}\nexport function end(state) {\n    const cur = state.drawable.current;\n    if (cur) {\n        if (cur.mouseSq)\n            addShape(state.drawable, cur);\n        cancel(state);\n    }\n}\nexport function cancel(state) {\n    if (state.drawable.current) {\n        state.drawable.current = undefined;\n        state.dom.redraw();\n    }\n}\nexport function clear(state) {\n    if (state.drawable.shapes.length) {\n        state.drawable.shapes = [];\n        state.dom.redraw();\n        onChange(state.drawable);\n    }\n}\nfunction eventBrush(e) {\n    var _a;\n    const modA = (e.shiftKey || e.ctrlKey) && isRightButton(e);\n    const modB = e.altKey || e.metaKey || ((_a = e.getModifierState) === null || _a === void 0 ? void 0 : _a.call(e, 'AltGraph'));\n    return brushes[(modA ? 1 : 0) + (modB ? 2 : 0)];\n}\nfunction addShape(drawable, cur) {\n    const sameShape = (s) => s.orig === cur.orig && s.dest === cur.dest;\n    const similar = drawable.shapes.find(sameShape);\n    if (similar)\n        drawable.shapes = drawable.shapes.filter(s => !sameShape(s));\n    if (!similar || similar.brush !== cur.brush)\n        drawable.shapes.push({\n            orig: cur.orig,\n            dest: cur.dest,\n            brush: cur.brush,\n        });\n    onChange(drawable);\n}\nfunction onChange(drawable) {\n    if (drawable.onChange)\n        drawable.onChange(drawable.shapes);\n}\n//# sourceMappingURL=draw.js.map","import { State } from './state.js';\nimport { unselect, cancelMove, getKeyAtDomPos, getSnappedKeyAtDomPos, whitePov } from './board.js';\nimport { eventPosition, isRightButton } from './util.js';\nimport * as cg from './types.js';\n\nexport interface DrawShape {\n  orig: cg.Key;\n  dest?: cg.Key;\n  brush?: string; // if no brush, no shape. label moved to top right of square\n  modifiers?: DrawModifiers;\n  piece?: DrawShapePiece;\n  customSvg?: { html: string; center?: 'orig' | 'dest' | 'label' }; // 100 x 100 viewbox cenetered at [50,50]\n  label?: { text: string; fill?: string }; // fill is in '#rrggbb' format\n}\n\nexport interface DrawModifiers {\n  lineWidth?: number;\n  hilite?: boolean;\n}\n\nexport interface DrawShapePiece {\n  role: cg.Role;\n  color: cg.Color;\n  scale?: number;\n}\n\nexport interface DrawBrush {\n  key: string;\n  color: string;\n  opacity: number;\n  lineWidth: number;\n}\n\nexport interface DrawBrushes {\n  green: DrawBrush;\n  red: DrawBrush;\n  blue: DrawBrush;\n  yellow: DrawBrush;\n  [color: string]: DrawBrush;\n}\n\nexport interface Drawable {\n  enabled: boolean; // can draw\n  visible: boolean; // can view\n  defaultSnapToValidMove: boolean;\n  eraseOnClick: boolean;\n  onChange?: (shapes: DrawShape[]) => void;\n  shapes: DrawShape[]; // user shapes\n  autoShapes: DrawShape[]; // computer shapes\n  current?: DrawCurrent;\n  brushes: DrawBrushes;\n  prevSvgHash: string;\n}\n\nexport interface DrawCurrent {\n  orig: cg.Key; // orig key of drawing\n  dest?: cg.Key; // shape dest, or undefined for circle\n  mouseSq?: cg.Key; // square being moused over\n  pos: cg.NumberPair; // relative current position\n  brush: cg.BrushColor; // brush name for shape\n  snapToValidMove: boolean; // whether to snap to valid piece moves\n}\n\nconst brushes: cg.BrushColor[] = ['green', 'red', 'blue', 'yellow'];\n\nexport function start(state: State, e: cg.MouchEvent): void {\n  // support one finger touch only\n  if (e.touches && e.touches.length > 1) return;\n  e.stopPropagation();\n  e.preventDefault();\n  e.ctrlKey ? unselect(state) : cancelMove(state);\n  const pos = eventPosition(e)!,\n    orig = getKeyAtDomPos(pos, whitePov(state), state.dom.bounds());\n  if (!orig) return;\n  state.drawable.current = {\n    orig,\n    pos,\n    brush: eventBrush(e),\n    snapToValidMove: state.drawable.defaultSnapToValidMove,\n  };\n\n  processDraw(state);\n}\n\nexport function processDraw(state: State): void {\n  requestAnimationFrame(() => {\n    const cur = state.drawable.current;\n    if (cur) {\n      const keyAtDomPos = getKeyAtDomPos(cur.pos, whitePov(state), state.dom.bounds());\n      if (!keyAtDomPos) {\n        cur.snapToValidMove = false;\n      }\n      const mouseSq = cur.snapToValidMove\n        ? getSnappedKeyAtDomPos(cur.orig, cur.pos, whitePov(state), state.dom.bounds())\n        : keyAtDomPos;\n      if (mouseSq !== cur.mouseSq) {\n        cur.mouseSq = mouseSq;\n        cur.dest = mouseSq !== cur.orig ? mouseSq : undefined;\n        state.dom.redrawNow();\n      }\n      processDraw(state);\n    }\n  });\n}\n\nexport function move(state: State, e: cg.MouchEvent): void {\n  if (state.drawable.current) state.drawable.current.pos = eventPosition(e)!;\n}\n\nexport function end(state: State): void {\n  const cur = state.drawable.current;\n  if (cur) {\n    if (cur.mouseSq) addShape(state.drawable, cur);\n    cancel(state);\n  }\n}\n\nexport function cancel(state: State): void {\n  if (state.drawable.current) {\n    state.drawable.current = undefined;\n    state.dom.redraw();\n  }\n}\n\nexport function clear(state: State): void {\n  if (state.drawable.shapes.length) {\n    state.drawable.shapes = [];\n    state.dom.redraw();\n    onChange(state.drawable);\n  }\n}\n\nfunction eventBrush(e: cg.MouchEvent): cg.BrushColor {\n  const modA = (e.shiftKey || e.ctrlKey) && isRightButton(e);\n  const modB = e.altKey || e.metaKey || e.getModifierState?.('AltGraph');\n  return brushes[(modA ? 1 : 0) + (modB ? 2 : 0)];\n}\n\nfunction addShape(drawable: Drawable, cur: DrawCurrent): void {\n  const sameShape = (s: DrawShape) => s.orig === cur.orig && s.dest === cur.dest;\n  const similar = drawable.shapes.find(sameShape);\n  if (similar) drawable.shapes = drawable.shapes.filter(s => !sameShape(s));\n  if (!similar || similar.brush !== cur.brush)\n    drawable.shapes.push({\n      orig: cur.orig,\n      dest: cur.dest,\n      brush: cur.brush,\n    });\n  onChange(drawable);\n}\n\nfunction onChange(drawable: Drawable): void {\n  if (drawable.onChange) drawable.onChange(drawable.shapes);\n}\n","export function explosion(state, keys) {\n    state.exploding = { stage: 1, keys };\n    state.dom.redraw();\n    setTimeout(() => {\n        setStage(state, 2);\n        setTimeout(() => setStage(state, undefined), 120);\n    }, 120);\n}\nfunction setStage(state, stage) {\n    if (state.exploding) {\n        if (stage)\n            state.exploding.stage = stage;\n        else\n            state.exploding = undefined;\n        state.dom.redraw();\n    }\n}\n//# sourceMappingURL=explosion.js.map","import { State } from './state.js';\nimport { Key } from './types.js';\n\nexport function explosion(state: State, keys: Key[]): void {\n  state.exploding = { stage: 1, keys };\n  state.dom.redraw();\n  setTimeout(() => {\n    setStage(state, 2);\n    setTimeout(() => setStage(state, undefined), 120);\n  }, 120);\n}\n\nfunction setStage(state: State, stage: number | undefined): void {\n  if (state.exploding) {\n    if (stage) state.exploding.stage = stage;\n    else state.exploding = undefined;\n    state.dom.redraw();\n  }\n}\n","import * as fen from './fen.js';\nimport { timer } from './util.js';\nexport function defaults() {\n    return {\n        pieces: fen.read(fen.initial),\n        orientation: 'white',\n        turnColor: 'white',\n        coordinates: true,\n        coordinatesOnSquares: false,\n        ranksPosition: 'right',\n        autoCastle: true,\n        viewOnly: false,\n        disableContextMenu: false,\n        addPieceZIndex: false,\n        blockTouchScroll: false,\n        pieceKey: false,\n        trustAllEvents: false,\n        highlight: {\n            lastMove: true,\n            check: true,\n        },\n        animation: {\n            enabled: true,\n            duration: 200,\n        },\n        movable: {\n            free: true,\n            color: 'both',\n            showDests: true,\n            events: {},\n            rookCastle: true,\n        },\n        premovable: {\n            enabled: true,\n            showDests: true,\n            castle: true,\n            events: {},\n        },\n        predroppable: {\n            enabled: false,\n            events: {},\n        },\n        draggable: {\n            enabled: true,\n            distance: 3,\n            autoDistance: true,\n            showGhost: true,\n            deleteOnDropOff: false,\n        },\n        dropmode: {\n            active: false,\n        },\n        selectable: {\n            enabled: true,\n        },\n        stats: {\n            // on touchscreen, default to \"tap-tap\" moves\n            // instead of drag\n            dragged: !('ontouchstart' in window),\n        },\n        events: {},\n        drawable: {\n            enabled: true,\n            visible: true,\n            defaultSnapToValidMove: true,\n            eraseOnClick: true,\n            shapes: [],\n            autoShapes: [],\n            brushes: {\n                green: { key: 'g', color: '#15781B', opacity: 1, lineWidth: 10 },\n                red: { key: 'r', color: '#882020', opacity: 1, lineWidth: 10 },\n                blue: { key: 'b', color: '#003088', opacity: 1, lineWidth: 10 },\n                yellow: { key: 'y', color: '#e68f00', opacity: 1, lineWidth: 10 },\n                paleBlue: { key: 'pb', color: '#003088', opacity: 0.4, lineWidth: 15 },\n                paleGreen: { key: 'pg', color: '#15781B', opacity: 0.4, lineWidth: 15 },\n                paleRed: { key: 'pr', color: '#882020', opacity: 0.4, lineWidth: 15 },\n                paleGrey: {\n                    key: 'pgr',\n                    color: '#4a4a4a',\n                    opacity: 0.35,\n                    lineWidth: 15,\n                },\n                purple: { key: 'purple', color: '#68217a', opacity: 0.65, lineWidth: 10 },\n                pink: { key: 'pink', color: '#ee2080', opacity: 0.5, lineWidth: 10 },\n                white: { key: 'white', color: 'white', opacity: 1, lineWidth: 10 },\n            },\n            prevSvgHash: '',\n        },\n        hold: timer(),\n    };\n}\n//# sourceMappingURL=state.js.map","import * as fen from './fen.js';\nimport { AnimCurrent } from './anim.js';\nimport { DragCurrent } from './drag.js';\nimport { Drawable } from './draw.js';\nimport { timer } from './util.js';\nimport * as cg from './types.js';\n\nexport interface HeadlessState {\n  pieces: cg.Pieces;\n  orientation: cg.Color; // board orientation. white | black\n  turnColor: cg.Color; // turn to play. white | black\n  check?: cg.Key; // square currently in check \"a2\"\n  lastMove?: cg.Key[]; // squares part of the last move [\"c3\"; \"c4\"]\n  selected?: cg.Key; // square currently selected \"a1\"\n  coordinates: boolean; // include coords attributes\n  coordinatesOnSquares: boolean; // include coords attributes on every square\n  ranksPosition: cg.RanksPosition; // position ranks on either side. left | right\n  autoCastle: boolean; // immediately complete the castle by moving the rook after king move\n  viewOnly: boolean; // don't bind events: the user will never be able to move pieces around\n  disableContextMenu: boolean; // because who needs a context menu on a chessboard\n  addPieceZIndex: boolean; // adds z-index values to pieces (for 3D)\n  addDimensionsCssVarsTo?: HTMLElement; // add ---cg-width and ---cg-height CSS vars containing the board's dimensions to this element\n  blockTouchScroll: boolean; // block scrolling via touch dragging on the board, e.g. for coordinate training\n  pieceKey: boolean; // add a data-key attribute to piece elements\n  trustAllEvents?: boolean; // disable checking for human only input (e.isTrusted)\n  highlight: {\n    lastMove: boolean; // add last-move class to squares\n    check: boolean; // add check class to squares\n    custom?: cg.SquareClasses; // add custom classes to custom squares\n  };\n  animation: {\n    enabled: boolean;\n    duration: number;\n    current?: AnimCurrent;\n  };\n  movable: {\n    free: boolean; // all moves are valid - board editor\n    color?: cg.Color | 'both'; // color that can move. white | black | both\n    dests?: cg.Dests; // valid moves. {\"a2\" [\"a3\" \"a4\"] \"b1\" [\"a3\" \"c3\"]}\n    showDests: boolean; // whether to add the move-dest class on squares\n    events: {\n      after?: (orig: cg.Key, dest: cg.Key, metadata: cg.MoveMetadata) => void; // called after the move has been played\n      afterNewPiece?: (role: cg.Role, key: cg.Key, metadata: cg.MoveMetadata) => void; // called after a new piece is dropped on the board\n    };\n    rookCastle: boolean; // castle by moving the king to the rook\n  };\n  premovable: {\n    enabled: boolean; // allow premoves for color that can not move\n    showDests: boolean; // whether to add the premove-dest class on squares\n    castle: boolean; // whether to allow king castle premoves\n    dests?: cg.Key[]; // premove destinations for the current selection\n    customDests?: cg.Dests; // use custom valid premoves. {\"a2\" [\"a3\" \"a4\"] \"b1\" [\"a3\" \"c3\"]}\n    current?: cg.KeyPair; // keys of the current saved premove [\"e2\" \"e4\"]\n    events: {\n      set?: (orig: cg.Key, dest: cg.Key, metadata?: cg.SetPremoveMetadata) => void; // called after the premove has been set\n      unset?: () => void; // called after the premove has been unset\n    };\n  };\n  predroppable: {\n    enabled: boolean; // allow predrops for color that can not move\n    current?: {\n      // current saved predrop {role: 'knight'; key: 'e4'}\n      role: cg.Role;\n      key: cg.Key;\n    };\n    events: {\n      set?: (role: cg.Role, key: cg.Key) => void; // called after the predrop has been set\n      unset?: () => void; // called after the predrop has been unset\n    };\n  };\n  draggable: {\n    enabled: boolean; // allow moves & premoves to use drag'n drop\n    distance: number; // minimum distance to initiate a drag; in pixels\n    autoDistance: boolean; // lets chessground set distance to zero when user drags pieces\n    showGhost: boolean; // show ghost of piece being dragged\n    deleteOnDropOff: boolean; // delete a piece when it is dropped off the board\n    current?: DragCurrent;\n  };\n  dropmode: {\n    active: boolean;\n    piece?: cg.Piece;\n  };\n  selectable: {\n    // disable to enforce dragging over click-click move\n    enabled: boolean;\n  };\n  stats: {\n    // was last piece dragged or clicked?\n    // needs default to false for touch\n    dragged: boolean;\n    ctrlKey?: boolean;\n  };\n  events: {\n    change?: () => void; // called after the situation changes on the board\n    // called after a piece has been moved.\n    // capturedPiece is undefined or like {color: 'white'; 'role': 'queen'}\n    move?: (orig: cg.Key, dest: cg.Key, capturedPiece?: cg.Piece) => void;\n    dropNewPiece?: (piece: cg.Piece, key: cg.Key) => void;\n    select?: (key: cg.Key) => void; // called when a square is selected\n    insert?: (elements: cg.Elements) => void; // when the board DOM has been (re)inserted\n  };\n  drawable: Drawable;\n  exploding?: cg.Exploding;\n  hold: cg.Timer;\n}\n\nexport interface State extends HeadlessState {\n  dom: cg.Dom;\n}\n\nexport function defaults(): HeadlessState {\n  return {\n    pieces: fen.read(fen.initial),\n    orientation: 'white',\n    turnColor: 'white',\n    coordinates: true,\n    coordinatesOnSquares: false,\n    ranksPosition: 'right',\n    autoCastle: true,\n    viewOnly: false,\n    disableContextMenu: false,\n    addPieceZIndex: false,\n    blockTouchScroll: false,\n    pieceKey: false,\n    trustAllEvents: false,\n    highlight: {\n      lastMove: true,\n      check: true,\n    },\n    animation: {\n      enabled: true,\n      duration: 200,\n    },\n    movable: {\n      free: true,\n      color: 'both',\n      showDests: true,\n      events: {},\n      rookCastle: true,\n    },\n    premovable: {\n      enabled: true,\n      showDests: true,\n      castle: true,\n      events: {},\n    },\n    predroppable: {\n      enabled: false,\n      events: {},\n    },\n    draggable: {\n      enabled: true,\n      distance: 3,\n      autoDistance: true,\n      showGhost: true,\n      deleteOnDropOff: false,\n    },\n    dropmode: {\n      active: false,\n    },\n    selectable: {\n      enabled: true,\n    },\n    stats: {\n      // on touchscreen, default to \"tap-tap\" moves\n      // instead of drag\n      dragged: !('ontouchstart' in window),\n    },\n    events: {},\n    drawable: {\n      enabled: true, // can draw\n      visible: true, // can view\n      defaultSnapToValidMove: true,\n      eraseOnClick: true,\n      shapes: [],\n      autoShapes: [],\n      brushes: {\n        green: { key: 'g', color: '#15781B', opacity: 1, lineWidth: 10 },\n        red: { key: 'r', color: '#882020', opacity: 1, lineWidth: 10 },\n        blue: { key: 'b', color: '#003088', opacity: 1, lineWidth: 10 },\n        yellow: { key: 'y', color: '#e68f00', opacity: 1, lineWidth: 10 },\n        paleBlue: { key: 'pb', color: '#003088', opacity: 0.4, lineWidth: 15 },\n        paleGreen: { key: 'pg', color: '#15781B', opacity: 0.4, lineWidth: 15 },\n        paleRed: { key: 'pr', color: '#882020', opacity: 0.4, lineWidth: 15 },\n        paleGrey: {\n          key: 'pgr',\n          color: '#4a4a4a',\n          opacity: 0.35,\n          lineWidth: 15,\n        },\n        purple: { key: 'purple', color: '#68217a', opacity: 0.65, lineWidth: 10 },\n        pink: { key: 'pink', color: '#ee2080', opacity: 0.5, lineWidth: 10 },\n        white: { key: 'white', color: 'white', opacity: 1, lineWidth: 10 },\n      },\n      prevSvgHash: '',\n    },\n    hold: timer(),\n  };\n}\n","import { setVisible, createEl } from './util.js';\nimport { colors, files, ranks } from './types.js';\nimport { createElement as createSVG, setAttributes, createDefs } from './svg.js';\nexport function renderWrap(element, s) {\n    // .cg-wrap (element passed to Chessground)\n    //   cg-container\n    //     cg-board\n    //     svg.cg-shapes\n    //       defs\n    //       g\n    //     svg.cg-custom-svgs\n    //       g\n    //     cg-auto-pieces\n    //     coords.ranks\n    //     coords.files\n    //     piece.ghost\n    element.innerHTML = '';\n    // ensure the cg-wrap class is set\n    // so bounds calculation can use the CSS width/height values\n    // add that class yourself to the element before calling chessground\n    // for a slight performance improvement! (avoids recomputing style)\n    element.classList.add('cg-wrap');\n    for (const c of colors)\n        element.classList.toggle('orientation-' + c, s.orientation === c);\n    element.classList.toggle('manipulable', !s.viewOnly);\n    const container = createEl('cg-container');\n    element.appendChild(container);\n    const board = createEl('cg-board');\n    container.appendChild(board);\n    let svg;\n    let customSvg;\n    let autoPieces;\n    if (s.drawable.visible) {\n        svg = setAttributes(createSVG('svg'), {\n            class: 'cg-shapes',\n            viewBox: '-4 -4 8 8',\n            preserveAspectRatio: 'xMidYMid slice',\n        });\n        svg.appendChild(createDefs());\n        svg.appendChild(createSVG('g'));\n        customSvg = setAttributes(createSVG('svg'), {\n            class: 'cg-custom-svgs',\n            viewBox: '-3.5 -3.5 8 8',\n            preserveAspectRatio: 'xMidYMid slice',\n        });\n        customSvg.appendChild(createSVG('g'));\n        autoPieces = createEl('cg-auto-pieces');\n        container.appendChild(svg);\n        container.appendChild(customSvg);\n        container.appendChild(autoPieces);\n    }\n    if (s.coordinates) {\n        const orientClass = s.orientation === 'black' ? ' black' : '';\n        const ranksPositionClass = s.ranksPosition === 'left' ? ' left' : '';\n        if (s.coordinatesOnSquares) {\n            const rankN = s.orientation === 'white' ? i => i + 1 : i => 8 - i;\n            files.forEach((f, i) => container.appendChild(renderCoords(ranks.map(r => f + r), 'squares rank' + rankN(i) + orientClass + ranksPositionClass)));\n        }\n        else {\n            container.appendChild(renderCoords(ranks, 'ranks' + orientClass + ranksPositionClass));\n            container.appendChild(renderCoords(files, 'files' + orientClass));\n        }\n    }\n    let ghost;\n    if (s.draggable.enabled && s.draggable.showGhost) {\n        ghost = createEl('piece', 'ghost');\n        setVisible(ghost, false);\n        container.appendChild(ghost);\n    }\n    return {\n        board,\n        container,\n        wrap: element,\n        ghost,\n        svg,\n        customSvg,\n        autoPieces,\n    };\n}\nfunction renderCoords(elems, className) {\n    const el = createEl('coords', className);\n    let f;\n    for (const elem of elems) {\n        f = createEl('coord');\n        f.textContent = elem;\n        el.appendChild(f);\n    }\n    return el;\n}\n//# sourceMappingURL=wrap.js.map","import { HeadlessState } from './state.js';\nimport { setVisible, createEl } from './util.js';\nimport { colors, files, ranks, Elements } from './types.js';\nimport { createElement as createSVG, setAttributes, createDefs } from './svg.js';\n\nexport function renderWrap(element: HTMLElement, s: HeadlessState): Elements {\n  // .cg-wrap (element passed to Chessground)\n  //   cg-container\n  //     cg-board\n  //     svg.cg-shapes\n  //       defs\n  //       g\n  //     svg.cg-custom-svgs\n  //       g\n  //     cg-auto-pieces\n  //     coords.ranks\n  //     coords.files\n  //     piece.ghost\n\n  element.innerHTML = '';\n\n  // ensure the cg-wrap class is set\n  // so bounds calculation can use the CSS width/height values\n  // add that class yourself to the element before calling chessground\n  // for a slight performance improvement! (avoids recomputing style)\n  element.classList.add('cg-wrap');\n\n  for (const c of colors) element.classList.toggle('orientation-' + c, s.orientation === c);\n  element.classList.toggle('manipulable', !s.viewOnly);\n\n  const container = createEl('cg-container');\n  element.appendChild(container);\n\n  const board = createEl('cg-board');\n  container.appendChild(board);\n\n  let svg: SVGElement | undefined;\n  let customSvg: SVGElement | undefined;\n  let autoPieces: HTMLElement | undefined;\n\n  if (s.drawable.visible) {\n    svg = setAttributes(createSVG('svg'), {\n      class: 'cg-shapes',\n      viewBox: '-4 -4 8 8',\n      preserveAspectRatio: 'xMidYMid slice',\n    });\n    svg.appendChild(createDefs());\n    svg.appendChild(createSVG('g'));\n\n    customSvg = setAttributes(createSVG('svg'), {\n      class: 'cg-custom-svgs',\n      viewBox: '-3.5 -3.5 8 8',\n      preserveAspectRatio: 'xMidYMid slice',\n    });\n    customSvg.appendChild(createSVG('g'));\n\n    autoPieces = createEl('cg-auto-pieces');\n\n    container.appendChild(svg);\n    container.appendChild(customSvg);\n    container.appendChild(autoPieces);\n  }\n\n  if (s.coordinates) {\n    const orientClass = s.orientation === 'black' ? ' black' : '';\n    const ranksPositionClass = s.ranksPosition === 'left' ? ' left' : '';\n\n    if (s.coordinatesOnSquares) {\n      const rankN: (i: number) => number = s.orientation === 'white' ? i => i + 1 : i => 8 - i;\n      files.forEach((f, i) =>\n        container.appendChild(\n          renderCoords(\n            ranks.map(r => f + r),\n            'squares rank' + rankN(i) + orientClass + ranksPositionClass,\n          ),\n        ),\n      );\n    } else {\n      container.appendChild(renderCoords(ranks, 'ranks' + orientClass + ranksPositionClass));\n      container.appendChild(renderCoords(files, 'files' + orientClass));\n    }\n  }\n\n  let ghost: HTMLElement | undefined;\n  if (s.draggable.enabled && s.draggable.showGhost) {\n    ghost = createEl('piece', 'ghost');\n    setVisible(ghost, false);\n    container.appendChild(ghost);\n  }\n\n  return {\n    board,\n    container,\n    wrap: element,\n    ghost,\n    svg,\n    customSvg,\n    autoPieces,\n  };\n}\n\nfunction renderCoords(elems: readonly string[], className: string): HTMLElement {\n  const el = createEl('coords', className);\n  let f: HTMLElement;\n  for (const elem of elems) {\n    f = createEl('coord');\n    f.textContent = elem;\n    el.appendChild(f);\n  }\n  return el;\n}\n","import { key2pos } from './util.js';\nconst hilites = {\n    hilitePrimary: { key: 'hilitePrimary', color: '#3291ff', opacity: 1, lineWidth: 1 },\n    hiliteWhite: { key: 'hiliteWhite', color: '#ffffff', opacity: 1, lineWidth: 1 },\n};\nexport { createElement, setAttributes };\nexport function createDefs() {\n    const defs = createElement('defs');\n    const filter = setAttributes(createElement('filter'), { id: 'cg-filter-blur' });\n    filter.appendChild(setAttributes(createElement('feGaussianBlur'), { stdDeviation: '0.019' }));\n    defs.appendChild(filter);\n    return defs;\n}\nexport function renderSvg(state, shapesEl, customsEl) {\n    var _a;\n    const d = state.drawable, curD = d.current, cur = curD && curD.mouseSq ? curD : undefined, dests = new Map(), bounds = state.dom.bounds(), nonPieceAutoShapes = d.autoShapes.filter(autoShape => !autoShape.piece);\n    for (const s of d.shapes.concat(nonPieceAutoShapes).concat(cur ? [cur] : [])) {\n        if (!s.dest)\n            continue;\n        const sources = (_a = dests.get(s.dest)) !== null && _a !== void 0 ? _a : new Set(), from = pos2user(orient(key2pos(s.orig), state.orientation), bounds), to = pos2user(orient(key2pos(s.dest), state.orientation), bounds);\n        sources.add(moveAngle(from, to));\n        dests.set(s.dest, sources);\n    }\n    const shapes = d.shapes.concat(nonPieceAutoShapes).map((s) => {\n        return {\n            shape: s,\n            current: false,\n            hash: shapeHash(s, isShort(s.dest, dests), false, bounds),\n        };\n    });\n    if (cur)\n        shapes.push({\n            shape: cur,\n            current: true,\n            hash: shapeHash(cur, isShort(cur.dest, dests), true, bounds),\n        });\n    const fullHash = shapes.map(sc => sc.hash).join(';');\n    if (fullHash === state.drawable.prevSvgHash)\n        return;\n    state.drawable.prevSvgHash = fullHash;\n    /*\n      -- DOM hierarchy --\n      <svg class=\"cg-shapes\">      (<= svg)\n        <defs>\n          ...(for brushes)...\n        </defs>\n        <g>\n          ...(for arrows and circles)...\n        </g>\n      </svg>\n      <svg class=\"cg-custom-svgs\"> (<= customSvg)\n        <g>\n          ...(for custom svgs)...\n        </g>\n      </svg>\n    */\n    const defsEl = shapesEl.querySelector('defs');\n    syncDefs(d, shapes, defsEl);\n    syncShapes(shapes, shapesEl.querySelector('g'), customsEl.querySelector('g'), s => renderShape(state, s, d.brushes, dests, bounds));\n}\n// append only. Don't try to update/remove.\nfunction syncDefs(d, shapes, defsEl) {\n    var _a;\n    const brushes = new Map();\n    let brush;\n    for (const s of shapes.filter(s => s.shape.dest && s.shape.brush)) {\n        brush = makeCustomBrush(d.brushes[s.shape.brush], s.shape.modifiers);\n        if ((_a = s.shape.modifiers) === null || _a === void 0 ? void 0 : _a.hilite)\n            brushes.set(hilite(brush).key, hilite(brush));\n        brushes.set(brush.key, brush);\n    }\n    const keysInDom = new Set();\n    let el = defsEl.firstElementChild;\n    while (el) {\n        keysInDom.add(el.getAttribute('cgKey'));\n        el = el.nextElementSibling;\n    }\n    for (const [key, brush] of brushes.entries()) {\n        if (!keysInDom.has(key))\n            defsEl.appendChild(renderMarker(brush));\n    }\n}\nfunction syncShapes(syncables, shapes, customs, renderShape) {\n    const hashesInDom = new Map();\n    for (const sc of syncables)\n        hashesInDom.set(sc.hash, false);\n    for (const root of [shapes, customs]) {\n        const toRemove = [];\n        let el = root.firstElementChild, elHash;\n        while (el) {\n            elHash = el.getAttribute('cgHash');\n            if (hashesInDom.has(elHash))\n                hashesInDom.set(elHash, true);\n            else\n                toRemove.push(el);\n            el = el.nextElementSibling;\n        }\n        for (const el of toRemove)\n            root.removeChild(el);\n    }\n    // insert shapes that are not yet in dom\n    for (const sc of syncables.filter(s => !hashesInDom.get(s.hash))) {\n        for (const svg of renderShape(sc)) {\n            if (svg.isCustom)\n                customs.appendChild(svg.el);\n            else\n                shapes.appendChild(svg.el);\n        }\n    }\n}\nfunction shapeHash({ orig, dest, brush, piece, modifiers, customSvg, label }, shorten, current, bounds) {\n    var _a, _b;\n    // a shape and an overlay svg share a lifetime and have the same cgHash attribute\n    return [\n        bounds.width,\n        bounds.height,\n        current,\n        orig,\n        dest,\n        brush,\n        shorten && '-',\n        piece && pieceHash(piece),\n        modifiers && modifiersHash(modifiers),\n        customSvg && `custom-${textHash(customSvg.html)},${(_b = (_a = customSvg.center) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'o'}`,\n        label && `label-${textHash(label.text)}`,\n    ]\n        .filter(x => x)\n        .join(',');\n}\nfunction pieceHash(piece) {\n    return [piece.color, piece.role, piece.scale].filter(x => x).join(',');\n}\nfunction modifiersHash(m) {\n    return [m.lineWidth, m.hilite && '*'].filter(x => x).join(',');\n}\nfunction textHash(s) {\n    // Rolling hash with base 31 (cf. https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript)\n    let h = 0;\n    for (let i = 0; i < s.length; i++) {\n        h = ((h << 5) - h + s.charCodeAt(i)) >>> 0;\n    }\n    return h.toString();\n}\nfunction renderShape(state, { shape, current, hash }, brushes, dests, bounds) {\n    var _a, _b;\n    const from = pos2user(orient(key2pos(shape.orig), state.orientation), bounds), to = shape.dest ? pos2user(orient(key2pos(shape.dest), state.orientation), bounds) : from, brush = shape.brush && makeCustomBrush(brushes[shape.brush], shape.modifiers), slots = dests.get(shape.dest), svgs = [];\n    if (brush) {\n        const el = setAttributes(createElement('g'), { cgHash: hash });\n        svgs.push({ el });\n        if (from[0] !== to[0] || from[1] !== to[1])\n            el.appendChild(renderArrow(shape, brush, from, to, current, isShort(shape.dest, dests)));\n        else\n            el.appendChild(renderCircle(brushes[shape.brush], from, current, bounds));\n    }\n    if (shape.label) {\n        const label = shape.label;\n        (_a = label.fill) !== null && _a !== void 0 ? _a : (label.fill = shape.brush && brushes[shape.brush].color);\n        const corner = shape.brush ? undefined : 'tr';\n        svgs.push({ el: renderLabel(label, hash, from, to, slots, corner), isCustom: true });\n    }\n    if (shape.customSvg) {\n        const on = (_b = shape.customSvg.center) !== null && _b !== void 0 ? _b : 'orig';\n        const [x, y] = on === 'label' ? labelCoords(from, to, slots).map(c => c - 0.5) : on === 'dest' ? to : from;\n        const el = setAttributes(createElement('g'), { transform: `translate(${x},${y})`, cgHash: hash });\n        el.innerHTML = `<svg width=\"1\" height=\"1\" viewBox=\"0 0 100 100\">${shape.customSvg.html}</svg>`;\n        svgs.push({ el, isCustom: true });\n    }\n    return svgs;\n}\nfunction renderCircle(brush, at, current, bounds) {\n    const widths = circleWidth(), radius = (bounds.width + bounds.height) / (4 * Math.max(bounds.width, bounds.height));\n    return setAttributes(createElement('circle'), {\n        stroke: brush.color,\n        'stroke-width': widths[current ? 0 : 1],\n        fill: 'none',\n        opacity: opacity(brush, current),\n        cx: at[0],\n        cy: at[1],\n        r: radius - widths[1] / 2,\n    });\n}\nfunction hilite(brush) {\n    return ['#ffffff', '#fff', 'white'].includes(brush.color)\n        ? hilites['hilitePrimary']\n        : hilites['hiliteWhite'];\n}\nfunction renderArrow(s, brush, from, to, current, shorten) {\n    var _a;\n    function renderLine(isHilite) {\n        var _a;\n        const m = arrowMargin(shorten && !current), dx = to[0] - from[0], dy = to[1] - from[1], angle = Math.atan2(dy, dx), xo = Math.cos(angle) * m, yo = Math.sin(angle) * m;\n        return setAttributes(createElement('line'), {\n            stroke: isHilite ? hilite(brush).color : brush.color,\n            'stroke-width': lineWidth(brush, current) + (isHilite ? 0.04 : 0),\n            'stroke-linecap': 'round',\n            'marker-end': `url(#arrowhead-${isHilite ? hilite(brush).key : brush.key})`,\n            opacity: ((_a = s.modifiers) === null || _a === void 0 ? void 0 : _a.hilite) ? 1 : opacity(brush, current),\n            x1: from[0],\n            y1: from[1],\n            x2: to[0] - xo,\n            y2: to[1] - yo,\n        });\n    }\n    if (!((_a = s.modifiers) === null || _a === void 0 ? void 0 : _a.hilite))\n        return renderLine(false);\n    const g = createElement('g');\n    const blurred = setAttributes(createElement('g'), { filter: 'url(#cg-filter-blur)' });\n    blurred.appendChild(filterBox(from, to));\n    blurred.appendChild(renderLine(true));\n    g.appendChild(blurred);\n    g.appendChild(renderLine(false));\n    return g;\n}\nfunction renderMarker(brush) {\n    const marker = setAttributes(createElement('marker'), {\n        id: 'arrowhead-' + brush.key,\n        orient: 'auto',\n        overflow: 'visible',\n        markerWidth: 4,\n        markerHeight: 4,\n        refX: brush.key.startsWith('hilite') ? 1.86 : 2.05,\n        refY: 2,\n    });\n    marker.appendChild(setAttributes(createElement('path'), {\n        d: 'M0,0 V4 L3,2 Z',\n        fill: brush.color,\n    }));\n    marker.setAttribute('cgKey', brush.key);\n    return marker;\n}\nfunction renderLabel(label, hash, from, to, slots, corner) {\n    var _a;\n    const labelSize = 0.4, fontSize = labelSize * 0.75 ** label.text.length, at = labelCoords(from, to, slots), cornerOff = corner === 'tr' ? 0.4 : 0, g = setAttributes(createElement('g'), {\n        transform: `translate(${at[0] + cornerOff},${at[1] - cornerOff})`,\n        cgHash: hash,\n    });\n    g.appendChild(setAttributes(createElement('circle'), {\n        r: labelSize / 2,\n        'fill-opacity': corner ? 1.0 : 0.8,\n        'stroke-opacity': corner ? 1.0 : 0.7,\n        'stroke-width': 0.03,\n        fill: (_a = label.fill) !== null && _a !== void 0 ? _a : '#666',\n        stroke: 'white',\n    }));\n    const labelEl = setAttributes(createElement('text'), {\n        'font-size': fontSize,\n        'font-family': 'Noto Sans',\n        'text-anchor': 'middle',\n        fill: 'white',\n        y: 0.13 * 0.75 ** label.text.length,\n    });\n    labelEl.innerHTML = label.text;\n    g.appendChild(labelEl);\n    return g;\n}\nfunction orient(pos, color) {\n    return color === 'white' ? pos : [7 - pos[0], 7 - pos[1]];\n}\nfunction isShort(dest, dests) {\n    return true === (dest && dests.has(dest) && dests.get(dest).size > 1);\n}\nfunction createElement(tagName) {\n    return document.createElementNS('http://www.w3.org/2000/svg', tagName);\n}\nfunction setAttributes(el, attrs) {\n    for (const key in attrs) {\n        if (Object.prototype.hasOwnProperty.call(attrs, key))\n            el.setAttribute(key, attrs[key]);\n    }\n    return el;\n}\nfunction makeCustomBrush(base, modifiers) {\n    return !modifiers\n        ? base\n        : {\n            color: base.color,\n            opacity: Math.round(base.opacity * 10) / 10,\n            lineWidth: Math.round(modifiers.lineWidth || base.lineWidth),\n            key: [base.key, modifiers.lineWidth].filter(x => x).join(''),\n        };\n}\nfunction circleWidth() {\n    return [3 / 64, 4 / 64];\n}\nfunction lineWidth(brush, current) {\n    return ((brush.lineWidth || 10) * (current ? 0.85 : 1)) / 64;\n}\nfunction opacity(brush, current) {\n    return (brush.opacity || 1) * (current ? 0.9 : 1);\n}\nfunction arrowMargin(shorten) {\n    return (shorten ? 20 : 10) / 64;\n}\nfunction pos2user(pos, bounds) {\n    const xScale = Math.min(1, bounds.width / bounds.height);\n    const yScale = Math.min(1, bounds.height / bounds.width);\n    return [(pos[0] - 3.5) * xScale, (3.5 - pos[1]) * yScale];\n}\nfunction filterBox(from, to) {\n    // lines/arrows are considered to be one dimensional for the purposes of SVG filters,\n    // so we add a transparent bounding box to ensure they apply to the 2nd dimension\n    const box = {\n        from: [Math.floor(Math.min(from[0], to[0])), Math.floor(Math.min(from[1], to[1]))],\n        to: [Math.ceil(Math.max(from[0], to[0])), Math.ceil(Math.max(from[1], to[1]))],\n    };\n    return setAttributes(createElement('rect'), {\n        x: box.from[0],\n        y: box.from[1],\n        width: box.to[0] - box.from[0],\n        height: box.to[1] - box.from[1],\n        fill: 'none',\n        stroke: 'none',\n    });\n}\nfunction moveAngle(from, to, asSlot = true) {\n    const angle = Math.atan2(to[1] - from[1], to[0] - from[0]) + Math.PI;\n    return asSlot ? (Math.round((angle * 8) / Math.PI) + 16) % 16 : angle;\n}\nfunction dist(from, to) {\n    return Math.sqrt([from[0] - to[0], from[1] - to[1]].reduce((acc, x) => acc + x * x, 0));\n}\n/*\n try to place label at the junction of the destination shaft and arrowhead. if there's more than\n 1 arrow pointing to a square, the arrow shortens by 10 / 64 units so the label must move as well.\n \n if the angle between two incoming arrows is pi / 8, such as when an adjacent knight and bishop\n attack the same square, the knight's label is slid further down the shaft by an amount equal to\n our label size to avoid collision\n*/\nfunction labelCoords(from, to, slots) {\n    let mag = dist(from, to);\n    //if (mag === 0) return [from[0], from[1]];\n    const angle = moveAngle(from, to, false);\n    if (slots) {\n        mag -= 33 / 64; // reduce by arrowhead length\n        if (slots.size > 1) {\n            mag -= 10 / 64; // reduce by shortening factor\n            const slot = moveAngle(from, to);\n            if (slots.has((slot + 1) % 16) || slots.has((slot + 15) % 16)) {\n                if (slot & 1)\n                    mag -= 0.4;\n                // and by label size for the knight if another arrow is within pi / 8.\n            }\n        }\n    }\n    return [from[0] - Math.cos(angle) * mag, from[1] - Math.sin(angle) * mag].map(c => c + 0.5);\n}\n//# sourceMappingURL=svg.js.map","import { State } from './state.js';\nimport { key2pos } from './util.js';\nimport { Drawable, DrawShape, DrawShapePiece, DrawBrush, DrawBrushes, DrawModifiers } from './draw.js';\nimport { SyncableShape, Hash } from './sync.js';\nimport * as cg from './types.js';\n\ntype CustomBrushes = Map<string, DrawBrush>; // by hash\ntype Svg = { el: SVGElement; isCustom?: boolean };\ntype AngleSlots = Set<number>; // arrow angle slots for label positioning\ntype ArrowDests = Map<cg.Key | undefined, AngleSlots>; // angle slots per dest\n\nconst hilites: { [name: string]: DrawBrush } = {\n  hilitePrimary: { key: 'hilitePrimary', color: '#3291ff', opacity: 1, lineWidth: 1 },\n  hiliteWhite: { key: 'hiliteWhite', color: '#ffffff', opacity: 1, lineWidth: 1 },\n};\n\nexport { createElement, setAttributes };\n\nexport function createDefs(): Element {\n  const defs = createElement('defs');\n  const filter = setAttributes(createElement('filter'), { id: 'cg-filter-blur' });\n  filter.appendChild(setAttributes(createElement('feGaussianBlur'), { stdDeviation: '0.019' }));\n  defs.appendChild(filter);\n  return defs;\n}\n\nexport function renderSvg(state: State, shapesEl: SVGElement, customsEl: SVGElement): void {\n  const d = state.drawable,\n    curD = d.current,\n    cur = curD && curD.mouseSq ? (curD as DrawShape) : undefined,\n    dests: ArrowDests = new Map(),\n    bounds = state.dom.bounds(),\n    nonPieceAutoShapes = d.autoShapes.filter(autoShape => !autoShape.piece);\n\n  for (const s of d.shapes.concat(nonPieceAutoShapes).concat(cur ? [cur] : [])) {\n    if (!s.dest) continue;\n    const sources = dests.get(s.dest) ?? new Set(),\n      from = pos2user(orient(key2pos(s.orig), state.orientation), bounds),\n      to = pos2user(orient(key2pos(s.dest), state.orientation), bounds);\n    sources.add(moveAngle(from, to));\n    dests.set(s.dest, sources);\n  }\n  const shapes: SyncableShape[] = d.shapes.concat(nonPieceAutoShapes).map((s: DrawShape) => {\n    return {\n      shape: s,\n      current: false,\n      hash: shapeHash(s, isShort(s.dest, dests), false, bounds),\n    };\n  });\n  if (cur)\n    shapes.push({\n      shape: cur,\n      current: true,\n      hash: shapeHash(cur, isShort(cur.dest, dests), true, bounds),\n    });\n\n  const fullHash = shapes.map(sc => sc.hash).join(';');\n  if (fullHash === state.drawable.prevSvgHash) return;\n  state.drawable.prevSvgHash = fullHash;\n\n  /*\n    -- DOM hierarchy --\n    <svg class=\"cg-shapes\">      (<= svg)\n      <defs>\n        ...(for brushes)...\n      </defs>\n      <g>\n        ...(for arrows and circles)...\n      </g>\n    </svg>\n    <svg class=\"cg-custom-svgs\"> (<= customSvg)\n      <g>\n        ...(for custom svgs)...\n      </g>\n    </svg>\n  */\n\n  const defsEl = shapesEl.querySelector('defs') as SVGElement;\n\n  syncDefs(d, shapes, defsEl);\n  syncShapes(shapes, shapesEl.querySelector('g')!, customsEl.querySelector('g')!, s =>\n    renderShape(state, s, d.brushes, dests, bounds),\n  );\n}\n\n// append only. Don't try to update/remove.\nfunction syncDefs(d: Drawable, shapes: SyncableShape[], defsEl: SVGElement) {\n  const brushes: CustomBrushes = new Map();\n  let brush: DrawBrush;\n  for (const s of shapes.filter(s => s.shape.dest && s.shape.brush)) {\n    brush = makeCustomBrush(d.brushes[s.shape.brush!], s.shape.modifiers);\n    if (s.shape.modifiers?.hilite) brushes.set(hilite(brush).key, hilite(brush));\n    brushes.set(brush.key, brush);\n  }\n  const keysInDom = new Set();\n  let el: SVGElement | undefined = defsEl.firstElementChild as SVGElement;\n  while (el) {\n    keysInDom.add(el.getAttribute('cgKey'));\n    el = el.nextElementSibling as SVGElement | undefined;\n  }\n  for (const [key, brush] of brushes.entries()) {\n    if (!keysInDom.has(key)) defsEl.appendChild(renderMarker(brush));\n  }\n}\n\nfunction syncShapes(\n  syncables: SyncableShape[],\n  shapes: Element,\n  customs: Element,\n  renderShape: (shape: SyncableShape) => Svg[],\n): void {\n  const hashesInDom = new Map();\n\n  for (const sc of syncables) hashesInDom.set(sc.hash, false);\n  for (const root of [shapes, customs]) {\n    const toRemove: SVGElement[] = [];\n    let el: SVGElement | undefined = root.firstElementChild as SVGElement,\n      elHash: Hash | null;\n    while (el) {\n      elHash = el.getAttribute('cgHash') as Hash;\n      if (hashesInDom.has(elHash)) hashesInDom.set(elHash, true);\n      else toRemove.push(el);\n      el = el.nextElementSibling as SVGElement | undefined;\n    }\n    for (const el of toRemove) root.removeChild(el);\n  }\n  // insert shapes that are not yet in dom\n  for (const sc of syncables.filter(s => !hashesInDom.get(s.hash))) {\n    for (const svg of renderShape(sc)) {\n      if (svg.isCustom) customs.appendChild(svg.el);\n      else shapes.appendChild(svg.el);\n    }\n  }\n}\n\nfunction shapeHash(\n  { orig, dest, brush, piece, modifiers, customSvg, label }: DrawShape,\n  shorten: boolean,\n  current: boolean,\n  bounds: DOMRectReadOnly,\n): Hash {\n  // a shape and an overlay svg share a lifetime and have the same cgHash attribute\n  return [\n    bounds.width,\n    bounds.height,\n    current,\n    orig,\n    dest,\n    brush,\n    shorten && '-',\n    piece && pieceHash(piece),\n    modifiers && modifiersHash(modifiers),\n    customSvg && `custom-${textHash(customSvg.html)},${customSvg.center?.[0] ?? 'o'}`,\n    label && `label-${textHash(label.text)}`,\n  ]\n    .filter(x => x)\n    .join(',');\n}\n\nfunction pieceHash(piece: DrawShapePiece): Hash {\n  return [piece.color, piece.role, piece.scale].filter(x => x).join(',');\n}\n\nfunction modifiersHash(m: DrawModifiers): Hash {\n  return [m.lineWidth, m.hilite && '*'].filter(x => x).join(',');\n}\n\nfunction textHash(s: string): Hash {\n  // Rolling hash with base 31 (cf. https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript)\n  let h = 0;\n  for (let i = 0; i < s.length; i++) {\n    h = ((h << 5) - h + s.charCodeAt(i)) >>> 0;\n  }\n  return h.toString();\n}\n\nfunction renderShape(\n  state: State,\n  { shape, current, hash }: SyncableShape,\n  brushes: DrawBrushes,\n  dests: ArrowDests,\n  bounds: DOMRectReadOnly,\n): Svg[] {\n  const from = pos2user(orient(key2pos(shape.orig), state.orientation), bounds),\n    to = shape.dest ? pos2user(orient(key2pos(shape.dest), state.orientation), bounds) : from,\n    brush = shape.brush && makeCustomBrush(brushes[shape.brush], shape.modifiers),\n    slots = dests.get(shape.dest),\n    svgs: Svg[] = [];\n\n  if (brush) {\n    const el = setAttributes(createElement('g'), { cgHash: hash });\n    svgs.push({ el });\n\n    if (from[0] !== to[0] || from[1] !== to[1])\n      el.appendChild(renderArrow(shape, brush, from, to, current, isShort(shape.dest, dests)));\n    else el.appendChild(renderCircle(brushes[shape.brush!], from, current, bounds));\n  }\n  if (shape.label) {\n    const label = shape.label;\n    label.fill ??= shape.brush && brushes[shape.brush].color;\n    const corner = shape.brush ? undefined : 'tr';\n    svgs.push({ el: renderLabel(label, hash, from, to, slots, corner), isCustom: true });\n  }\n  if (shape.customSvg) {\n    const on = shape.customSvg.center ?? 'orig';\n    const [x, y] =\n      on === 'label' ? labelCoords(from, to, slots).map(c => c - 0.5) : on === 'dest' ? to : from;\n    const el = setAttributes(createElement('g'), { transform: `translate(${x},${y})`, cgHash: hash });\n    el.innerHTML = `<svg width=\"1\" height=\"1\" viewBox=\"0 0 100 100\">${shape.customSvg.html}</svg>`;\n    svgs.push({ el, isCustom: true });\n  }\n  return svgs;\n}\n\nfunction renderCircle(\n  brush: DrawBrush,\n  at: cg.NumberPair,\n  current: boolean,\n  bounds: DOMRectReadOnly,\n): SVGElement {\n  const widths = circleWidth(),\n    radius = (bounds.width + bounds.height) / (4 * Math.max(bounds.width, bounds.height));\n  return setAttributes(createElement('circle'), {\n    stroke: brush.color,\n    'stroke-width': widths[current ? 0 : 1],\n    fill: 'none',\n    opacity: opacity(brush, current),\n    cx: at[0],\n    cy: at[1],\n    r: radius - widths[1] / 2,\n  });\n}\n\nfunction hilite(brush: DrawBrush): DrawBrush {\n  return ['#ffffff', '#fff', 'white'].includes(brush.color)\n    ? hilites['hilitePrimary']\n    : hilites['hiliteWhite'];\n}\n\nfunction renderArrow(\n  s: DrawShape,\n  brush: DrawBrush,\n  from: cg.NumberPair,\n  to: cg.NumberPair,\n  current: boolean,\n  shorten: boolean,\n): SVGElement {\n  function renderLine(isHilite: boolean) {\n    const m = arrowMargin(shorten && !current),\n      dx = to[0] - from[0],\n      dy = to[1] - from[1],\n      angle = Math.atan2(dy, dx),\n      xo = Math.cos(angle) * m,\n      yo = Math.sin(angle) * m;\n    return setAttributes(createElement('line'), {\n      stroke: isHilite ? hilite(brush).color : brush.color,\n      'stroke-width': lineWidth(brush, current) + (isHilite ? 0.04 : 0),\n      'stroke-linecap': 'round',\n      'marker-end': `url(#arrowhead-${isHilite ? hilite(brush).key : brush.key})`,\n      opacity: s.modifiers?.hilite ? 1 : opacity(brush, current),\n      x1: from[0],\n      y1: from[1],\n      x2: to[0] - xo,\n      y2: to[1] - yo,\n    });\n  }\n  if (!s.modifiers?.hilite) return renderLine(false);\n\n  const g = createElement('g');\n  const blurred = setAttributes(createElement('g'), { filter: 'url(#cg-filter-blur)' });\n  blurred.appendChild(filterBox(from, to));\n  blurred.appendChild(renderLine(true));\n  g.appendChild(blurred);\n  g.appendChild(renderLine(false));\n  return g;\n}\n\nfunction renderMarker(brush: DrawBrush): SVGElement {\n  const marker = setAttributes(createElement('marker'), {\n    id: 'arrowhead-' + brush.key,\n    orient: 'auto',\n    overflow: 'visible',\n    markerWidth: 4,\n    markerHeight: 4,\n    refX: brush.key.startsWith('hilite') ? 1.86 : 2.05,\n    refY: 2,\n  });\n  marker.appendChild(\n    setAttributes(createElement('path'), {\n      d: 'M0,0 V4 L3,2 Z',\n      fill: brush.color,\n    }),\n  );\n  marker.setAttribute('cgKey', brush.key);\n  return marker;\n}\n\nfunction renderLabel(\n  label: { text: string; fill?: string },\n  hash: string,\n  from: cg.NumberPair,\n  to: cg.NumberPair,\n  slots?: AngleSlots,\n  corner?: 'tr',\n): SVGElement {\n  const labelSize = 0.4,\n    fontSize = labelSize * 0.75 ** label.text.length,\n    at = labelCoords(from, to, slots),\n    cornerOff = corner === 'tr' ? 0.4 : 0,\n    g = setAttributes(createElement('g'), {\n      transform: `translate(${at[0] + cornerOff},${at[1] - cornerOff})`,\n      cgHash: hash,\n    });\n  g.appendChild(\n    setAttributes(createElement('circle'), {\n      r: labelSize / 2,\n      'fill-opacity': corner ? 1.0 : 0.8,\n      'stroke-opacity': corner ? 1.0 : 0.7,\n      'stroke-width': 0.03,\n      fill: label.fill ?? '#666',\n      stroke: 'white',\n    }),\n  );\n  const labelEl = setAttributes(createElement('text'), {\n    'font-size': fontSize,\n    'font-family': 'Noto Sans',\n    'text-anchor': 'middle',\n    fill: 'white',\n    y: 0.13 * 0.75 ** label.text.length,\n  });\n  labelEl.innerHTML = label.text;\n  g.appendChild(labelEl);\n  return g;\n}\n\nfunction orient(pos: cg.Pos, color: cg.Color): cg.Pos {\n  return color === 'white' ? pos : [7 - pos[0], 7 - pos[1]];\n}\n\nfunction isShort(dest: cg.Key | undefined, dests: ArrowDests) {\n  return true === (dest && dests.has(dest) && dests.get(dest)!.size > 1);\n}\n\nfunction createElement(tagName: string): SVGElement {\n  return document.createElementNS('http://www.w3.org/2000/svg', tagName);\n}\n\nfunction setAttributes(el: SVGElement, attrs: { [key: string]: any }): SVGElement {\n  for (const key in attrs) {\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) el.setAttribute(key, attrs[key]);\n  }\n  return el;\n}\n\nfunction makeCustomBrush(base: DrawBrush, modifiers: DrawModifiers | undefined): DrawBrush {\n  return !modifiers\n    ? base\n    : {\n        color: base.color,\n        opacity: Math.round(base.opacity * 10) / 10,\n        lineWidth: Math.round(modifiers.lineWidth || base.lineWidth),\n        key: [base.key, modifiers.lineWidth].filter(x => x).join(''),\n      };\n}\n\nfunction circleWidth(): [number, number] {\n  return [3 / 64, 4 / 64];\n}\n\nfunction lineWidth(brush: DrawBrush, current: boolean): number {\n  return ((brush.lineWidth || 10) * (current ? 0.85 : 1)) / 64;\n}\n\nfunction opacity(brush: DrawBrush, current: boolean): number {\n  return (brush.opacity || 1) * (current ? 0.9 : 1);\n}\n\nfunction arrowMargin(shorten: boolean): number {\n  return (shorten ? 20 : 10) / 64;\n}\n\nfunction pos2user(pos: cg.Pos, bounds: DOMRectReadOnly): cg.NumberPair {\n  const xScale = Math.min(1, bounds.width / bounds.height);\n  const yScale = Math.min(1, bounds.height / bounds.width);\n  return [(pos[0] - 3.5) * xScale, (3.5 - pos[1]) * yScale];\n}\n\nfunction filterBox(from: cg.NumberPair, to: cg.NumberPair): SVGElement {\n  // lines/arrows are considered to be one dimensional for the purposes of SVG filters,\n  // so we add a transparent bounding box to ensure they apply to the 2nd dimension\n  const box = {\n    from: [Math.floor(Math.min(from[0], to[0])), Math.floor(Math.min(from[1], to[1]))],\n    to: [Math.ceil(Math.max(from[0], to[0])), Math.ceil(Math.max(from[1], to[1]))],\n  };\n  return setAttributes(createElement('rect'), {\n    x: box.from[0],\n    y: box.from[1],\n    width: box.to[0] - box.from[0],\n    height: box.to[1] - box.from[1],\n    fill: 'none',\n    stroke: 'none',\n  });\n}\n\nfunction moveAngle(from: cg.NumberPair, to: cg.NumberPair, asSlot = true) {\n  const angle = Math.atan2(to[1] - from[1], to[0] - from[0]) + Math.PI;\n  return asSlot ? (Math.round((angle * 8) / Math.PI) + 16) % 16 : angle;\n}\n\nfunction dist(from: cg.NumberPair, to: cg.NumberPair): number {\n  return Math.sqrt([from[0] - to[0], from[1] - to[1]].reduce((acc, x) => acc + x * x, 0));\n}\n\n/*\n try to place label at the junction of the destination shaft and arrowhead. if there's more than\n 1 arrow pointing to a square, the arrow shortens by 10 / 64 units so the label must move as well. \n \n if the angle between two incoming arrows is pi / 8, such as when an adjacent knight and bishop\n attack the same square, the knight's label is slid further down the shaft by an amount equal to\n our label size to avoid collision\n*/\n\nfunction labelCoords(from: cg.NumberPair, to: cg.NumberPair, slots?: AngleSlots): cg.NumberPair {\n  let mag = dist(from, to);\n  //if (mag === 0) return [from[0], from[1]];\n  const angle = moveAngle(from, to, false);\n  if (slots) {\n    mag -= 33 / 64; // reduce by arrowhead length\n    if (slots.size > 1) {\n      mag -= 10 / 64; // reduce by shortening factor\n      const slot = moveAngle(from, to);\n      if (slots.has((slot + 1) % 16) || slots.has((slot + 15) % 16)) {\n        if (slot & 1) mag -= 0.4;\n        // and by label size for the knight if another arrow is within pi / 8.\n      }\n    }\n  }\n  return [from[0] - Math.cos(angle) * mag, from[1] - Math.sin(angle) * mag].map(\n    c => c + 0.5,\n  ) as cg.NumberPair;\n}\n","import * as drag from './drag.js';\nimport * as draw from './draw.js';\nimport { drop } from './drop.js';\nimport { isRightButton } from './util.js';\nexport function bindBoard(s, onResize) {\n    const boardEl = s.dom.elements.board;\n    if ('ResizeObserver' in window)\n        new ResizeObserver(onResize).observe(s.dom.elements.wrap);\n    if (s.disableContextMenu || s.drawable.enabled) {\n        boardEl.addEventListener('contextmenu', e => e.preventDefault());\n    }\n    if (s.viewOnly)\n        return;\n    // Cannot be passive, because we prevent touch scrolling and dragging of\n    // selected elements.\n    const onStart = startDragOrDraw(s);\n    boardEl.addEventListener('touchstart', onStart, {\n        passive: false,\n    });\n    boardEl.addEventListener('mousedown', onStart, {\n        passive: false,\n    });\n}\n// returns the unbind function\nexport function bindDocument(s, onResize) {\n    const unbinds = [];\n    // Old versions of Edge and Safari do not support ResizeObserver. Send\n    // chessground.resize if a user action has changed the bounds of the board.\n    if (!('ResizeObserver' in window))\n        unbinds.push(unbindable(document.body, 'chessground.resize', onResize));\n    if (!s.viewOnly) {\n        const onmove = dragOrDraw(s, drag.move, draw.move);\n        const onend = dragOrDraw(s, drag.end, draw.end);\n        for (const ev of ['touchmove', 'mousemove'])\n            unbinds.push(unbindable(document, ev, onmove));\n        for (const ev of ['touchend', 'mouseup'])\n            unbinds.push(unbindable(document, ev, onend));\n        const onScroll = () => s.dom.bounds.clear();\n        unbinds.push(unbindable(document, 'scroll', onScroll, { capture: true, passive: true }));\n        unbinds.push(unbindable(window, 'resize', onScroll, { passive: true }));\n    }\n    return () => unbinds.forEach(f => f());\n}\nfunction unbindable(el, eventName, callback, options) {\n    el.addEventListener(eventName, callback, options);\n    return () => el.removeEventListener(eventName, callback, options);\n}\nconst startDragOrDraw = (s) => e => {\n    if (s.draggable.current)\n        drag.cancel(s);\n    else if (s.drawable.current)\n        draw.cancel(s);\n    else if (e.shiftKey || isRightButton(e)) {\n        if (s.drawable.enabled)\n            draw.start(s, e);\n    }\n    else if (!s.viewOnly) {\n        if (s.dropmode.active)\n            drop(s, e);\n        else\n            drag.start(s, e);\n    }\n};\nconst dragOrDraw = (s, withDrag, withDraw) => e => {\n    if (s.drawable.current) {\n        if (s.drawable.enabled)\n            withDraw(s, e);\n    }\n    else if (!s.viewOnly)\n        withDrag(s, e);\n};\n//# sourceMappingURL=events.js.map","import { State } from './state.js';\nimport * as drag from './drag.js';\nimport * as draw from './draw.js';\nimport { drop } from './drop.js';\nimport { isRightButton } from './util.js';\nimport * as cg from './types.js';\n\ntype MouchBind = (e: cg.MouchEvent) => void;\ntype StateMouchBind = (d: State, e: cg.MouchEvent) => void;\n\nexport function bindBoard(s: State, onResize: () => void): void {\n  const boardEl = s.dom.elements.board;\n\n  if ('ResizeObserver' in window) new ResizeObserver(onResize).observe(s.dom.elements.wrap);\n\n  if (s.disableContextMenu || s.drawable.enabled) {\n    boardEl.addEventListener('contextmenu', e => e.preventDefault());\n  }\n\n  if (s.viewOnly) return;\n\n  // Cannot be passive, because we prevent touch scrolling and dragging of\n  // selected elements.\n  const onStart = startDragOrDraw(s);\n  boardEl.addEventListener('touchstart', onStart as EventListener, {\n    passive: false,\n  });\n  boardEl.addEventListener('mousedown', onStart as EventListener, {\n    passive: false,\n  });\n}\n\n// returns the unbind function\nexport function bindDocument(s: State, onResize: () => void): cg.Unbind {\n  const unbinds: cg.Unbind[] = [];\n\n  // Old versions of Edge and Safari do not support ResizeObserver. Send\n  // chessground.resize if a user action has changed the bounds of the board.\n  if (!('ResizeObserver' in window)) unbinds.push(unbindable(document.body, 'chessground.resize', onResize));\n\n  if (!s.viewOnly) {\n    const onmove = dragOrDraw(s, drag.move, draw.move);\n    const onend = dragOrDraw(s, drag.end, draw.end);\n\n    for (const ev of ['touchmove', 'mousemove'])\n      unbinds.push(unbindable(document, ev, onmove as EventListener));\n    for (const ev of ['touchend', 'mouseup']) unbinds.push(unbindable(document, ev, onend as EventListener));\n\n    const onScroll = () => s.dom.bounds.clear();\n    unbinds.push(unbindable(document, 'scroll', onScroll, { capture: true, passive: true }));\n    unbinds.push(unbindable(window, 'resize', onScroll, { passive: true }));\n  }\n\n  return () => unbinds.forEach(f => f());\n}\n\nfunction unbindable(\n  el: EventTarget,\n  eventName: string,\n  callback: EventListener,\n  options?: AddEventListenerOptions,\n): cg.Unbind {\n  el.addEventListener(eventName, callback, options);\n  return () => el.removeEventListener(eventName, callback, options);\n}\n\nconst startDragOrDraw =\n  (s: State): MouchBind =>\n  e => {\n    if (s.draggable.current) drag.cancel(s);\n    else if (s.drawable.current) draw.cancel(s);\n    else if (e.shiftKey || isRightButton(e)) {\n      if (s.drawable.enabled) draw.start(s, e);\n    } else if (!s.viewOnly) {\n      if (s.dropmode.active) drop(s, e);\n      else drag.start(s, e);\n    }\n  };\n\nconst dragOrDraw =\n  (s: State, withDrag: StateMouchBind, withDraw: StateMouchBind): MouchBind =>\n  e => {\n    if (s.drawable.current) {\n      if (s.drawable.enabled) withDraw(s, e);\n    } else if (!s.viewOnly) withDrag(s, e);\n  };\n","import * as board from './board.js';\nimport * as util from './util.js';\nimport { cancel as dragCancel } from './drag.js';\nexport function setDropMode(s, piece) {\n    s.dropmode = {\n        active: true,\n        piece,\n    };\n    dragCancel(s);\n}\nexport function cancelDropMode(s) {\n    s.dropmode = {\n        active: false,\n    };\n}\nexport function drop(s, e) {\n    if (!s.dropmode.active)\n        return;\n    board.unsetPremove(s);\n    board.unsetPredrop(s);\n    const piece = s.dropmode.piece;\n    if (piece) {\n        s.pieces.set('a0', piece);\n        const position = util.eventPosition(e);\n        const dest = position && board.getKeyAtDomPos(position, board.whitePov(s), s.dom.bounds());\n        if (dest)\n            board.dropNewPiece(s, 'a0', dest);\n    }\n    s.dom.redraw();\n}\n//# sourceMappingURL=drop.js.map","import { State } from './state.js';\nimport * as cg from './types.js';\nimport * as board from './board.js';\nimport * as util from './util.js';\nimport { cancel as dragCancel } from './drag.js';\n\nexport function setDropMode(s: State, piece?: cg.Piece): void {\n  s.dropmode = {\n    active: true,\n    piece,\n  };\n  dragCancel(s);\n}\n\nexport function cancelDropMode(s: State): void {\n  s.dropmode = {\n    active: false,\n  };\n}\n\nexport function drop(s: State, e: cg.MouchEvent): void {\n  if (!s.dropmode.active) return;\n\n  board.unsetPremove(s);\n  board.unsetPredrop(s);\n\n  const piece = s.dropmode.piece;\n\n  if (piece) {\n    s.pieces.set('a0', piece);\n    const position = util.eventPosition(e);\n    const dest = position && board.getKeyAtDomPos(position, board.whitePov(s), s.dom.bounds());\n    if (dest) board.dropNewPiece(s, 'a0', dest);\n  }\n  s.dom.redraw();\n}\n","import { key2pos, createEl, posToTranslate as posToTranslateFromBounds, translate } from './util.js';\nimport { whitePov } from './board.js';\n// ported from https://github.com/lichess-org/lichobile/blob/master/src/chessground/render.ts\n// in case of bugs, blame @veloce\nexport function render(s) {\n    const asWhite = whitePov(s), posToTranslate = posToTranslateFromBounds(s.dom.bounds()), boardEl = s.dom.elements.board, pieces = s.pieces, curAnim = s.animation.current, anims = curAnim ? curAnim.plan.anims : new Map(), fadings = curAnim ? curAnim.plan.fadings : new Map(), curDrag = s.draggable.current, squares = computeSquareClasses(s), samePieces = new Set(), sameSquares = new Set(), movedPieces = new Map(), movedSquares = new Map(); // by class name\n    let k, el, pieceAtKey, elPieceName, anim, fading, pMvdset, pMvd, sMvdset, sMvd;\n    // walk over all board dom elements, apply animations and flag moved pieces\n    el = boardEl.firstChild;\n    while (el) {\n        k = el.cgKey;\n        if (isPieceNode(el)) {\n            pieceAtKey = pieces.get(k);\n            anim = anims.get(k);\n            fading = fadings.get(k);\n            elPieceName = el.cgPiece;\n            // if piece not being dragged anymore, remove dragging style\n            if (el.cgDragging && (!curDrag || curDrag.orig !== k)) {\n                el.classList.remove('dragging');\n                translate(el, posToTranslate(key2pos(k), asWhite));\n                el.cgDragging = false;\n            }\n            // remove fading class if it still remains\n            if (!fading && el.cgFading) {\n                el.cgFading = false;\n                el.classList.remove('fading');\n            }\n            // there is now a piece at this dom key\n            if (pieceAtKey) {\n                // continue animation if already animating and same piece\n                // (otherwise it could animate a captured piece)\n                if (anim && el.cgAnimating && elPieceName === pieceNameOf(pieceAtKey)) {\n                    const pos = key2pos(k);\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                    el.classList.add('anim');\n                    translate(el, posToTranslate(pos, asWhite));\n                }\n                else if (el.cgAnimating) {\n                    el.cgAnimating = false;\n                    el.classList.remove('anim');\n                    translate(el, posToTranslate(key2pos(k), asWhite));\n                    if (s.addPieceZIndex)\n                        el.style.zIndex = posZIndex(key2pos(k), asWhite);\n                }\n                // same piece: flag as same\n                if (elPieceName === pieceNameOf(pieceAtKey) && (!fading || !el.cgFading)) {\n                    samePieces.add(k);\n                }\n                // different piece: flag as moved unless it is a fading piece\n                else {\n                    if (fading && elPieceName === pieceNameOf(fading)) {\n                        el.classList.add('fading');\n                        el.cgFading = true;\n                    }\n                    else {\n                        appendValue(movedPieces, elPieceName, el);\n                    }\n                }\n            }\n            // no piece: flag as moved\n            else {\n                appendValue(movedPieces, elPieceName, el);\n            }\n        }\n        else if (isSquareNode(el)) {\n            const cn = el.className;\n            if (squares.get(k) === cn)\n                sameSquares.add(k);\n            else\n                appendValue(movedSquares, cn, el);\n        }\n        el = el.nextSibling;\n    }\n    // walk over all squares in current set, apply dom changes to moved squares\n    // or append new squares\n    for (const [sk, className] of squares) {\n        if (!sameSquares.has(sk)) {\n            sMvdset = movedSquares.get(className);\n            sMvd = sMvdset && sMvdset.pop();\n            const translation = posToTranslate(key2pos(sk), asWhite);\n            if (sMvd) {\n                sMvd.cgKey = sk;\n                translate(sMvd, translation);\n            }\n            else {\n                const squareNode = createEl('square', className);\n                squareNode.cgKey = sk;\n                translate(squareNode, translation);\n                boardEl.insertBefore(squareNode, boardEl.firstChild);\n            }\n        }\n    }\n    // walk over all pieces in current set, apply dom changes to moved pieces\n    // or append new pieces\n    for (const [k, p] of pieces) {\n        anim = anims.get(k);\n        if (!samePieces.has(k)) {\n            pMvdset = movedPieces.get(pieceNameOf(p));\n            pMvd = pMvdset && pMvdset.pop();\n            // a same piece was moved\n            if (pMvd) {\n                // apply dom changes\n                pMvd.cgKey = k;\n                if (pMvd.cgFading) {\n                    pMvd.classList.remove('fading');\n                    pMvd.cgFading = false;\n                }\n                const pos = key2pos(k);\n                if (s.addPieceZIndex)\n                    pMvd.style.zIndex = posZIndex(pos, asWhite);\n                if (anim) {\n                    pMvd.cgAnimating = true;\n                    pMvd.classList.add('anim');\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                }\n                translate(pMvd, posToTranslate(pos, asWhite));\n            }\n            // no piece in moved obj: insert the new piece\n            // assumes the new piece is not being dragged\n            else {\n                const pieceName = pieceNameOf(p), pieceNode = createEl('piece', pieceName), pos = key2pos(k);\n                pieceNode.cgPiece = pieceName;\n                pieceNode.cgKey = k;\n                if (anim) {\n                    pieceNode.cgAnimating = true;\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                }\n                translate(pieceNode, posToTranslate(pos, asWhite));\n                if (s.addPieceZIndex)\n                    pieceNode.style.zIndex = posZIndex(pos, asWhite);\n                boardEl.appendChild(pieceNode);\n            }\n        }\n    }\n    // remove any element that remains in the moved sets\n    for (const nodes of movedPieces.values())\n        removeNodes(s, nodes);\n    for (const nodes of movedSquares.values())\n        removeNodes(s, nodes);\n}\nexport function renderResized(s) {\n    const asWhite = whitePov(s), posToTranslate = posToTranslateFromBounds(s.dom.bounds());\n    let el = s.dom.elements.board.firstChild;\n    while (el) {\n        if ((isPieceNode(el) && !el.cgAnimating) || isSquareNode(el)) {\n            translate(el, posToTranslate(key2pos(el.cgKey), asWhite));\n        }\n        el = el.nextSibling;\n    }\n}\nexport function updateBounds(s) {\n    var _a, _b;\n    const bounds = s.dom.elements.wrap.getBoundingClientRect();\n    const container = s.dom.elements.container;\n    const ratio = bounds.height / bounds.width;\n    const width = (Math.floor((bounds.width * window.devicePixelRatio) / 8) * 8) / window.devicePixelRatio;\n    const height = width * ratio;\n    container.style.width = width + 'px';\n    container.style.height = height + 'px';\n    s.dom.bounds.clear();\n    (_a = s.addDimensionsCssVarsTo) === null || _a === void 0 ? void 0 : _a.style.setProperty('---cg-width', width + 'px');\n    (_b = s.addDimensionsCssVarsTo) === null || _b === void 0 ? void 0 : _b.style.setProperty('---cg-height', height + 'px');\n}\nconst isPieceNode = (el) => el.tagName === 'PIECE';\nconst isSquareNode = (el) => el.tagName === 'SQUARE';\nfunction removeNodes(s, nodes) {\n    for (const node of nodes)\n        s.dom.elements.board.removeChild(node);\n}\nfunction posZIndex(pos, asWhite) {\n    const minZ = 3;\n    const rank = pos[1];\n    const z = asWhite ? minZ + 7 - rank : minZ + rank;\n    return `${z}`;\n}\nconst pieceNameOf = (piece) => `${piece.color} ${piece.role}`;\nfunction computeSquareClasses(s) {\n    var _a, _b, _c;\n    const squares = new Map();\n    if (s.lastMove && s.highlight.lastMove)\n        for (const k of s.lastMove) {\n            addSquare(squares, k, 'last-move');\n        }\n    if (s.check && s.highlight.check)\n        addSquare(squares, s.check, 'check');\n    if (s.selected) {\n        addSquare(squares, s.selected, 'selected');\n        if (s.movable.showDests) {\n            const dests = (_a = s.movable.dests) === null || _a === void 0 ? void 0 : _a.get(s.selected);\n            if (dests)\n                for (const k of dests) {\n                    addSquare(squares, k, 'move-dest' + (s.pieces.has(k) ? ' oc' : ''));\n                }\n            const pDests = (_c = (_b = s.premovable.customDests) === null || _b === void 0 ? void 0 : _b.get(s.selected)) !== null && _c !== void 0 ? _c : s.premovable.dests;\n            if (pDests)\n                for (const k of pDests) {\n                    addSquare(squares, k, 'premove-dest' + (s.pieces.has(k) ? ' oc' : ''));\n                }\n        }\n    }\n    const premove = s.premovable.current;\n    if (premove)\n        for (const k of premove)\n            addSquare(squares, k, 'current-premove');\n    else if (s.predroppable.current)\n        addSquare(squares, s.predroppable.current.key, 'current-premove');\n    const o = s.exploding;\n    if (o)\n        for (const k of o.keys)\n            addSquare(squares, k, 'exploding' + o.stage);\n    if (s.highlight.custom) {\n        s.highlight.custom.forEach((v, k) => {\n            addSquare(squares, k, v);\n        });\n    }\n    return squares;\n}\nfunction addSquare(squares, key, klass) {\n    const classes = squares.get(key);\n    if (classes)\n        squares.set(key, `${classes} ${klass}`);\n    else\n        squares.set(key, klass);\n}\nfunction appendValue(map, key, value) {\n    const arr = map.get(key);\n    if (arr)\n        arr.push(value);\n    else\n        map.set(key, [value]);\n}\n//# sourceMappingURL=render.js.map","import { State } from './state.js';\nimport { key2pos, createEl, posToTranslate as posToTranslateFromBounds, translate } from './util.js';\nimport { whitePov } from './board.js';\nimport { AnimCurrent, AnimVectors, AnimVector, AnimFadings } from './anim.js';\nimport { DragCurrent } from './drag.js';\nimport * as cg from './types.js';\n\ntype PieceName = string; // `$color $role`\n\n// ported from https://github.com/lichess-org/lichobile/blob/master/src/chessground/render.ts\n// in case of bugs, blame @veloce\nexport function render(s: State): void {\n  const asWhite: boolean = whitePov(s),\n    posToTranslate = posToTranslateFromBounds(s.dom.bounds()),\n    boardEl: HTMLElement = s.dom.elements.board,\n    pieces: cg.Pieces = s.pieces,\n    curAnim: AnimCurrent | undefined = s.animation.current,\n    anims: AnimVectors = curAnim ? curAnim.plan.anims : new Map(),\n    fadings: AnimFadings = curAnim ? curAnim.plan.fadings : new Map(),\n    curDrag: DragCurrent | undefined = s.draggable.current,\n    squares: cg.SquareClasses = computeSquareClasses(s),\n    samePieces: Set<cg.Key> = new Set(),\n    sameSquares: Set<cg.Key> = new Set(),\n    movedPieces: Map<PieceName, cg.PieceNode[]> = new Map(),\n    movedSquares: Map<string, cg.SquareNode[]> = new Map(); // by class name\n  let k: cg.Key,\n    el: cg.PieceNode | cg.SquareNode | undefined,\n    pieceAtKey: cg.Piece | undefined,\n    elPieceName: PieceName,\n    anim: AnimVector | undefined,\n    fading: cg.Piece | undefined,\n    pMvdset: cg.PieceNode[] | undefined,\n    pMvd: cg.PieceNode | undefined,\n    sMvdset: cg.SquareNode[] | undefined,\n    sMvd: cg.SquareNode | undefined;\n\n  // walk over all board dom elements, apply animations and flag moved pieces\n  el = boardEl.firstChild as cg.PieceNode | cg.SquareNode | undefined;\n  while (el) {\n    k = el.cgKey;\n    if (isPieceNode(el)) {\n      pieceAtKey = pieces.get(k);\n      anim = anims.get(k);\n      fading = fadings.get(k);\n      elPieceName = el.cgPiece;\n      // if piece not being dragged anymore, remove dragging style\n      if (el.cgDragging && (!curDrag || curDrag.orig !== k)) {\n        el.classList.remove('dragging');\n        translate(el, posToTranslate(key2pos(k), asWhite));\n        el.cgDragging = false;\n      }\n      // remove fading class if it still remains\n      if (!fading && el.cgFading) {\n        el.cgFading = false;\n        el.classList.remove('fading');\n      }\n      // there is now a piece at this dom key\n      if (pieceAtKey) {\n        // continue animation if already animating and same piece\n        // (otherwise it could animate a captured piece)\n        if (anim && el.cgAnimating && elPieceName === pieceNameOf(pieceAtKey)) {\n          const pos = key2pos(k);\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n          el.classList.add('anim');\n          translate(el, posToTranslate(pos, asWhite));\n        } else if (el.cgAnimating) {\n          el.cgAnimating = false;\n          el.classList.remove('anim');\n          translate(el, posToTranslate(key2pos(k), asWhite));\n          if (s.addPieceZIndex) el.style.zIndex = posZIndex(key2pos(k), asWhite);\n        }\n        // same piece: flag as same\n        if (elPieceName === pieceNameOf(pieceAtKey) && (!fading || !el.cgFading)) {\n          samePieces.add(k);\n        }\n        // different piece: flag as moved unless it is a fading piece\n        else {\n          if (fading && elPieceName === pieceNameOf(fading)) {\n            el.classList.add('fading');\n            el.cgFading = true;\n          } else {\n            appendValue(movedPieces, elPieceName, el);\n          }\n        }\n      }\n      // no piece: flag as moved\n      else {\n        appendValue(movedPieces, elPieceName, el);\n      }\n    } else if (isSquareNode(el)) {\n      const cn = el.className;\n      if (squares.get(k) === cn) sameSquares.add(k);\n      else appendValue(movedSquares, cn, el);\n    }\n    el = el.nextSibling as cg.PieceNode | cg.SquareNode | undefined;\n  }\n\n  // walk over all squares in current set, apply dom changes to moved squares\n  // or append new squares\n  for (const [sk, className] of squares) {\n    if (!sameSquares.has(sk)) {\n      sMvdset = movedSquares.get(className);\n      sMvd = sMvdset && sMvdset.pop();\n      const translation = posToTranslate(key2pos(sk), asWhite);\n      if (sMvd) {\n        sMvd.cgKey = sk;\n        translate(sMvd, translation);\n      } else {\n        const squareNode = createEl('square', className) as cg.SquareNode;\n        squareNode.cgKey = sk;\n        translate(squareNode, translation);\n        boardEl.insertBefore(squareNode, boardEl.firstChild);\n      }\n    }\n  }\n\n  // walk over all pieces in current set, apply dom changes to moved pieces\n  // or append new pieces\n  for (const [k, p] of pieces) {\n    anim = anims.get(k);\n    if (!samePieces.has(k)) {\n      pMvdset = movedPieces.get(pieceNameOf(p));\n      pMvd = pMvdset && pMvdset.pop();\n      // a same piece was moved\n      if (pMvd) {\n        // apply dom changes\n        pMvd.cgKey = k;\n        if (pMvd.cgFading) {\n          pMvd.classList.remove('fading');\n          pMvd.cgFading = false;\n        }\n        const pos = key2pos(k);\n        if (s.addPieceZIndex) pMvd.style.zIndex = posZIndex(pos, asWhite);\n        if (anim) {\n          pMvd.cgAnimating = true;\n          pMvd.classList.add('anim');\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n        }\n        translate(pMvd, posToTranslate(pos, asWhite));\n      }\n      // no piece in moved obj: insert the new piece\n      // assumes the new piece is not being dragged\n      else {\n        const pieceName = pieceNameOf(p),\n          pieceNode = createEl('piece', pieceName) as cg.PieceNode,\n          pos = key2pos(k);\n\n        pieceNode.cgPiece = pieceName;\n        pieceNode.cgKey = k;\n        if (anim) {\n          pieceNode.cgAnimating = true;\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n        }\n        translate(pieceNode, posToTranslate(pos, asWhite));\n\n        if (s.addPieceZIndex) pieceNode.style.zIndex = posZIndex(pos, asWhite);\n\n        boardEl.appendChild(pieceNode);\n      }\n    }\n  }\n\n  // remove any element that remains in the moved sets\n  for (const nodes of movedPieces.values()) removeNodes(s, nodes);\n  for (const nodes of movedSquares.values()) removeNodes(s, nodes);\n}\n\nexport function renderResized(s: State): void {\n  const asWhite: boolean = whitePov(s),\n    posToTranslate = posToTranslateFromBounds(s.dom.bounds());\n  let el = s.dom.elements.board.firstChild as cg.PieceNode | cg.SquareNode | undefined;\n  while (el) {\n    if ((isPieceNode(el) && !el.cgAnimating) || isSquareNode(el)) {\n      translate(el, posToTranslate(key2pos(el.cgKey), asWhite));\n    }\n    el = el.nextSibling as cg.PieceNode | cg.SquareNode | undefined;\n  }\n}\n\nexport function updateBounds(s: State): void {\n  const bounds = s.dom.elements.wrap.getBoundingClientRect();\n  const container = s.dom.elements.container;\n  const ratio = bounds.height / bounds.width;\n  const width = (Math.floor((bounds.width * window.devicePixelRatio) / 8) * 8) / window.devicePixelRatio;\n  const height = width * ratio;\n  container.style.width = width + 'px';\n  container.style.height = height + 'px';\n  s.dom.bounds.clear();\n\n  s.addDimensionsCssVarsTo?.style.setProperty('---cg-width', width + 'px');\n  s.addDimensionsCssVarsTo?.style.setProperty('---cg-height', height + 'px');\n}\n\nconst isPieceNode = (el: cg.PieceNode | cg.SquareNode): el is cg.PieceNode => el.tagName === 'PIECE';\nconst isSquareNode = (el: cg.PieceNode | cg.SquareNode): el is cg.SquareNode => el.tagName === 'SQUARE';\n\nfunction removeNodes(s: State, nodes: HTMLElement[]): void {\n  for (const node of nodes) s.dom.elements.board.removeChild(node);\n}\n\nfunction posZIndex(pos: cg.Pos, asWhite: boolean): string {\n  const minZ = 3;\n  const rank = pos[1];\n  const z = asWhite ? minZ + 7 - rank : minZ + rank;\n\n  return `${z}`;\n}\n\nconst pieceNameOf = (piece: cg.Piece): string => `${piece.color} ${piece.role}`;\n\nfunction computeSquareClasses(s: State): cg.SquareClasses {\n  const squares: cg.SquareClasses = new Map();\n  if (s.lastMove && s.highlight.lastMove)\n    for (const k of s.lastMove) {\n      addSquare(squares, k, 'last-move');\n    }\n  if (s.check && s.highlight.check) addSquare(squares, s.check, 'check');\n  if (s.selected) {\n    addSquare(squares, s.selected, 'selected');\n    if (s.movable.showDests) {\n      const dests = s.movable.dests?.get(s.selected);\n      if (dests)\n        for (const k of dests) {\n          addSquare(squares, k, 'move-dest' + (s.pieces.has(k) ? ' oc' : ''));\n        }\n      const pDests = s.premovable.customDests?.get(s.selected) ?? s.premovable.dests;\n      if (pDests)\n        for (const k of pDests) {\n          addSquare(squares, k, 'premove-dest' + (s.pieces.has(k) ? ' oc' : ''));\n        }\n    }\n  }\n  const premove = s.premovable.current;\n  if (premove) for (const k of premove) addSquare(squares, k, 'current-premove');\n  else if (s.predroppable.current) addSquare(squares, s.predroppable.current.key, 'current-premove');\n\n  const o = s.exploding;\n  if (o) for (const k of o.keys) addSquare(squares, k, 'exploding' + o.stage);\n\n  if (s.highlight.custom) {\n    s.highlight.custom.forEach((v: string, k: cg.Key) => {\n      addSquare(squares, k, v);\n    });\n  }\n\n  return squares;\n}\n\nfunction addSquare(squares: cg.SquareClasses, key: cg.Key, klass: string): void {\n  const classes = squares.get(key);\n  if (classes) squares.set(key, `${classes} ${klass}`);\n  else squares.set(key, klass);\n}\n\nfunction appendValue<K, V>(map: Map<K, V[]>, key: K, value: V): void {\n  const arr = map.get(key);\n  if (arr) arr.push(value);\n  else map.set(key, [value]);\n}\n","import { key2pos, createEl, posToTranslate as posToTranslateFromBounds, translateAndScale } from './util.js';\nimport { whitePov } from './board.js';\nimport { syncShapes } from './sync.js';\nexport function render(state, autoPieceEl) {\n    const autoPieces = state.drawable.autoShapes.filter(autoShape => autoShape.piece);\n    const autoPieceShapes = autoPieces.map((s) => {\n        return {\n            shape: s,\n            hash: hash(s),\n            current: false,\n        };\n    });\n    syncShapes(autoPieceShapes, autoPieceEl, shape => renderShape(state, shape, state.dom.bounds()));\n}\nexport function renderResized(state) {\n    var _a;\n    const asWhite = whitePov(state), posToTranslate = posToTranslateFromBounds(state.dom.bounds());\n    let el = (_a = state.dom.elements.autoPieces) === null || _a === void 0 ? void 0 : _a.firstChild;\n    while (el) {\n        translateAndScale(el, posToTranslate(key2pos(el.cgKey), asWhite), el.cgScale);\n        el = el.nextSibling;\n    }\n}\nfunction renderShape(state, { shape, hash }, bounds) {\n    var _a, _b, _c;\n    const orig = shape.orig;\n    const role = (_a = shape.piece) === null || _a === void 0 ? void 0 : _a.role;\n    const color = (_b = shape.piece) === null || _b === void 0 ? void 0 : _b.color;\n    const scale = (_c = shape.piece) === null || _c === void 0 ? void 0 : _c.scale;\n    const pieceEl = createEl('piece', `${role} ${color}`);\n    pieceEl.setAttribute('cgHash', hash);\n    pieceEl.cgKey = orig;\n    pieceEl.cgScale = scale;\n    translateAndScale(pieceEl, posToTranslateFromBounds(bounds)(key2pos(orig), whitePov(state)), scale);\n    return pieceEl;\n}\nconst hash = (autoPiece) => { var _a, _b, _c; return [autoPiece.orig, (_a = autoPiece.piece) === null || _a === void 0 ? void 0 : _a.role, (_b = autoPiece.piece) === null || _b === void 0 ? void 0 : _b.color, (_c = autoPiece.piece) === null || _c === void 0 ? void 0 : _c.scale].join(','); };\n//# sourceMappingURL=autoPieces.js.map","import { State } from './state.js';\nimport { key2pos, createEl, posToTranslate as posToTranslateFromBounds, translateAndScale } from './util.js';\nimport { whitePov } from './board.js';\nimport * as cg from './types.js';\nimport { DrawShape } from './draw.js';\nimport { SyncableShape, Hash, syncShapes } from './sync.js';\n\nexport function render(state: State, autoPieceEl: HTMLElement): void {\n  const autoPieces = state.drawable.autoShapes.filter(autoShape => autoShape.piece);\n  const autoPieceShapes: SyncableShape[] = autoPieces.map((s: DrawShape) => {\n    return {\n      shape: s,\n      hash: hash(s),\n      current: false,\n    };\n  });\n\n  syncShapes(autoPieceShapes, autoPieceEl, shape => renderShape(state, shape, state.dom.bounds()));\n}\n\nexport function renderResized(state: State): void {\n  const asWhite: boolean = whitePov(state),\n    posToTranslate = posToTranslateFromBounds(state.dom.bounds());\n  let el = state.dom.elements.autoPieces?.firstChild as cg.PieceNode | undefined;\n  while (el) {\n    translateAndScale(el, posToTranslate(key2pos(el.cgKey), asWhite), el.cgScale);\n    el = el.nextSibling as cg.PieceNode | undefined;\n  }\n}\n\nfunction renderShape(state: State, { shape, hash }: SyncableShape, bounds: DOMRectReadOnly): cg.PieceNode {\n  const orig = shape.orig;\n  const role = shape.piece?.role;\n  const color = shape.piece?.color;\n  const scale = shape.piece?.scale;\n\n  const pieceEl = createEl('piece', `${role} ${color}`) as cg.PieceNode;\n  pieceEl.setAttribute('cgHash', hash);\n  pieceEl.cgKey = orig;\n  pieceEl.cgScale = scale;\n  translateAndScale(pieceEl, posToTranslateFromBounds(bounds)(key2pos(orig), whitePov(state)), scale);\n\n  return pieceEl;\n}\n\nconst hash = (autoPiece: DrawShape): Hash =>\n  [autoPiece.orig, autoPiece.piece?.role, autoPiece.piece?.color, autoPiece.piece?.scale].join(',');\n","// append and remove only. No updates.\nexport function syncShapes(shapes, root, renderShape) {\n    const hashesInDom = new Map(), // by hash\n    toRemove = [];\n    for (const sc of shapes)\n        hashesInDom.set(sc.hash, false);\n    let el = root.firstElementChild, elHash;\n    while (el) {\n        elHash = el.getAttribute('cgHash');\n        // found a shape element that's here to stay\n        if (hashesInDom.has(elHash))\n            hashesInDom.set(elHash, true);\n        // or remove it\n        else\n            toRemove.push(el);\n        el = el.nextElementSibling;\n    }\n    // remove old shapes\n    for (const el of toRemove)\n        root.removeChild(el);\n    // insert shapes that are not yet in dom\n    for (const sc of shapes) {\n        if (!hashesInDom.get(sc.hash))\n            root.appendChild(renderShape(sc));\n    }\n}\n//# sourceMappingURL=sync.js.map","import { DrawShape } from './draw';\n\nexport interface SyncableShape {\n  shape: DrawShape;\n  current: boolean;\n  hash: Hash;\n}\n\nexport type Hash = string;\n\n// append and remove only. No updates.\nexport function syncShapes(\n  shapes: SyncableShape[],\n  root: HTMLElement | SVGElement,\n  renderShape: (shape: SyncableShape) => HTMLElement | SVGElement,\n): void {\n  const hashesInDom = new Map(), // by hash\n    toRemove: SVGElement[] = [];\n  for (const sc of shapes) hashesInDom.set(sc.hash, false);\n  let el: SVGElement | undefined = root.firstElementChild as SVGElement,\n    elHash: Hash | null;\n  while (el) {\n    elHash = el.getAttribute('cgHash') as Hash;\n    // found a shape element that's here to stay\n    if (hashesInDom.has(elHash)) hashesInDom.set(elHash, true);\n    // or remove it\n    else toRemove.push(el);\n    el = el.nextElementSibling as SVGElement | undefined;\n  }\n  // remove old shapes\n  for (const el of toRemove) root.removeChild(el);\n  // insert shapes that are not yet in dom\n  for (const sc of shapes) {\n    if (!hashesInDom.get(sc.hash)) root.appendChild(renderShape(sc));\n  }\n}\n","import { Chess, fen, type Move } from \"chessops\";\n\ntype EvaluatedState = {\n  value: number;\n  certain: boolean;\n};\n\nconst heuristicEvaluation = (chess: Chess): EvaluatedState => {\n  return {\n    value:\n      [...chess.board[\"white\"]].flatMap((from) =>\n        [...chess.dests(from, chess.ctx())].map((to) => ({ from, to }))\n      ).length -\n      [...chess.board[\"black\"]].flatMap((from) =>\n        [...chess.dests(from, chess.ctx())].map((to) => ({ from, to }))\n      ).length,\n    certain: false,\n  };\n};\n\n// Maximises result on our turn, but minimises it on opponent's turn\nconst minMaxValueComparator = (\n  a: EvaluatedState,\n  b: EvaluatedState,\n  shouldMaximise = true // should this sorter try to maximise or minimise the result\n) => {\n  // Invert result if we want the minimizer\n  return (b.value - a.value) * (shouldMaximise ? 1 : -1);\n};\n\nconst evaluateState = (\n  chess: Chess,\n  recursiveLimit: number\n): EvaluatedState => {\n  if (chess.isStalemate())\n    // A tie is worth nothing!\n    return { value: 0, certain: true };\n\n  if (chess.isCheckmate())\n    // TODO not clear if this condition is the right way around\n    return { value: chess.turn === \"white\" ? -1 : 1, certain: true };\n\n  if (recursiveLimit === 0) {\n    return heuristicEvaluation(chess);\n  }\n\n  const allMoves = [...chess.board[chess.turn]].flatMap((from) =>\n    [...chess.dests(from, chess.ctx())].map((to) => ({ from, to }))\n  );\n\n  const rankedFutureStates = allMoves\n    .map((move) => {\n      const clone = chess.clone();\n      clone.play(move);\n      return memoEvaluateStateForPlayer(clone, recursiveLimit - 1);\n    })\n    .sort((a, b) => minMaxValueComparator(a, b, chess.turn === \"white\"));\n\n  const bestFutureState = rankedFutureStates[0];\n\n  return {\n    value: bestFutureState.value,\n    certain: bestFutureState.certain,\n  };\n};\n\nconst memoedEvaluations: Record<string, EvaluatedState> = {};\n\nconst memoEvaluateStateForPlayer = (state: Chess, recursiveLimit = 2) => {\n  const memoKey = fen.makeBoardFen(state.board);\n  if (memoedEvaluations[memoKey]) {\n    return memoedEvaluations[memoKey];\n  }\n\n  const realEvaluation = evaluateState(state, recursiveLimit);\n\n  if (realEvaluation.certain) {\n    memoedEvaluations[memoKey] = realEvaluation;\n  }\n\n  return realEvaluation;\n};\n\nexport const pickBestMove = (chess: Chess): Move => {\n  // Get the set of all legal moves\n  const allMoves = [...chess.board[chess.turn]].flatMap((from) =>\n    [...chess.dests(from, chess.ctx())].map((to) => ({ from, to }))\n  );\n  // Evaluate the state each move would yield\n  const rankedMoves = allMoves\n    .map((move) => {\n      const clone = chess.clone();\n      clone.play(move);\n      return {\n        move,\n        evaluation: memoEvaluateStateForPlayer(clone),\n      };\n    })\n    .sort((a, b) =>\n      minMaxValueComparator(a.evaluation, b.evaluation, chess.turn === \"white\")\n    );\n\n  // pick randomly from equal best\n  const bestMove = rankedMoves[0];\n  const equalBestMoves = rankedMoves\n    .filter(({ evaluation }) => evaluation.value === bestMove.evaluation.value)\n    .map(({ move }) => move);\n\n  const randomBestMove =\n    equalBestMoves[Math.floor(Math.random() * equalBestMoves.length)];\n\n  return randomBestMove;\n};\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$0b15f372ed432f56$var$r","r","prototype","create","constructor","$0b15f372ed432f56$var$t","setPrototypeOf","bind","t","__proto__","IllegalSetup","InvalidFen","$9c49db522b46d242$export$5426f43bd8f77457","$9d83a5ecbd86440e$export$c3be932223332a30","$0b15f372ed432f56$export$8fdcabde73f49165","$0b15f372ed432f56$var$e","unwrap","_chain","ok","err","isErr","error","value","map","chain","$0b15f372ed432f56$var$o","call","isOk","$0b15f372ed432f56$var$u","Error","all","Array","isArray","length","o","push","u","i","keys","c","f","$9894c45c69033325$var$popcnt32","Math","imul","$9894c45c69033325$var$bswap32","$9894c45c69033325$var$rbit32","$9894c45c69033325$export$1cb45477e81f9503","lo","hi","fromSquare","square","fromRank","rank","shl64","fromFile","file","empty","full","corners","center","backranks","backrank","color","lightSquares","darkSquares","complement","xor","other","union","intersect","diff","intersects","nonEmpty","isDisjoint","isEmpty","supersetOf","subsetOf","shr64","shift","bswap64","rbit64","minus64","equals","size","has","on","with","without","toggle","last","clz32","first","withoutFirst","moreThanOne","singleSquare","undefined","Symbol","iterator","idx","reversed","$c489d07ce8bc1a25$export$603b1d1551079add","$c489d07ce8bc1a25$export$2b1421cb957c0b7e","$c489d07ce8bc1a25$export$56d196d2844d1ca1","$c489d07ce8bc1a25$export$d1cfdc29cbc61821","$c489d07ce8bc1a25$export$2ac9b71d100b39a1","$c489d07ce8bc1a25$export$90ffe53e9bf2dee8","$ced645034f45bdd3$export$43f40ad3fa1d5c97","$ced645034f45bdd3$export$a27c3a1c44ba515b","$ced645034f45bdd3$export$8ec54076fe05cd3f","$ced645034f45bdd3$export$4e7f80514dc39415","$ced645034f45bdd3$export$4a0d5207d1ffca15","$ced645034f45bdd3$export$f10eeb6aa79a8bf2","role","$ced645034f45bdd3$export$c6ba26669b4144a1","str","charCodeAt","$ced645034f45bdd3$export$232f91fc931f1158","$ced645034f45bdd3$export$7557b324d9d37023","move","toUpperCase","to","from","promotion","$ced645034f45bdd3$export$9d0713081c523620","side","$ced645034f45bdd3$export$d958227fca9654a5","$9fc1d75359bd39d5$var$computeRange","deltas","range","delta","sq","abs","$9fc1d75359bd39d5$var$tabulate","table","$9fc1d75359bd39d5$var$KING_ATTACKS","$9fc1d75359bd39d5$var$KNIGHT_ATTACKS","$9fc1d75359bd39d5$var$PAWN_ATTACKS","white","black","$9fc1d75359bd39d5$export$a60166eda477d9f1","$9fc1d75359bd39d5$export$f98f014d8442d39e","$9fc1d75359bd39d5$export$891089f6415f4f9e","$9fc1d75359bd39d5$var$FILE_RANGE","$9fc1d75359bd39d5$var$RANK_RANGE","$9fc1d75359bd39d5$var$DIAG_RANGE","diag","$9fc1d75359bd39d5$var$ANTI_DIAG_RANGE","$9fc1d75359bd39d5$var$hyperbola","bit","occupied","forward","reverse","$9fc1d75359bd39d5$var$fileAttacks","$9fc1d75359bd39d5$var$rankAttacks","$9fc1d75359bd39d5$export$b599b52d035a6fc7","$9fc1d75359bd39d5$export$1f4e7eaa3e729013","$9fc1d75359bd39d5$export$91813132f8c8e3a9","$9fc1d75359bd39d5$export$e006947b4f05482d","a","b","$9fc1d75359bd39d5$export$cf95c51b03f10bae","$4f484c5772f22add$export$dc537a3a3893548e","default","board","reset","promoted","pawn","knight","bishop","rook","queen","king","clear","clone","getColor","getRole","take","piece","old","pieces","rooksAndQueens","bishopsAndQueens","kingOf","$9c49db522b46d242$export$e965a47eea052e24","$9c49db522b46d242$var$attacksTo","attacker","$9c49db522b46d242$export$9e972839f626f452","castles","castlingRights","h","path","add","kingTo","rookTo","fromSetup","setup","rooks","aSide","hSide","discardRook","discardColor","$9c49db522b46d242$export$13807d9ee5a34a42","rules","pockets","turn","epSquare","remainingChecks","halfmoves","fullmoves","setupUnchecked","$9c49db522b46d242$var$validEpSquare","kingAttackers","playCaptureAt","captured","ctx","variantEnd","isVariantEnd","blockers","checkers","mustCapture","snipers","sniper","_a","_b","pos","validate","Empty","Kings","otherKing","OppositeCheck","PawnsOnBackrank","dropDests","_ctx","dests","pseudo","legal","step","canDoubleStep","doubleStep","$9c49db522b46d242$var$canCaptureEp","occ","$9c49db522b46d242$var$castlingDest","checker","variantOutcome","hasInsufficientMaterial","sameColor","toSetup","$9c49db522b46d242$var$legalEpSquare","min","max","isInsufficientMaterial","every","hasDests","isLegal","$9c49db522b46d242$export$c027268f00e9726","isCheck","isEnd","isCheckmate","isStalemate","outcome","winner","allDests","d","Map","play","castling","$9c49db522b46d242$export$4cb9b6e3b2f07aa1","epCapture","rookFrom","capture","$9c49db522b46d242$export$a4d6ea685c300d39","_","epRank","candidate","ourPawns","pawnFrom","kingPath","after","$9d83a5ecbd86440e$exports","$9d83a5ecbd86440e$export$a7af5e4473279ca4","$9d83a5ecbd86440e$export$f55e4ecc51581d46","$9d83a5ecbd86440e$export$e7275301a68905e5","$9d83a5ecbd86440e$export$cf2dfba1ebb0c02f","$9d83a5ecbd86440e$export$a8056043964453a9","$9d83a5ecbd86440e$export$5dd74b96db3f93aa","$9d83a5ecbd86440e$export$e160fb1161fc30ea","$9d83a5ecbd86440e$export$1fedd4affc50d07d","$9d83a5ecbd86440e$export$b5493de85cc66c92","$9d83a5ecbd86440e$export$4d18bb43bf7a3116","$9d83a5ecbd86440e$export$fca9881f86ac8234","$9d83a5ecbd86440e$export$d6cccad725f80cdb","$9d83a5ecbd86440e$export$49ab54498a5f7b98","$9d83a5ecbd86440e$export$d7c07e9c8afa4b1f","$9d83a5ecbd86440e$export$df21f977b5ae750e","$9d83a5ecbd86440e$export$cabb40a7cab9b9b6","$9d83a5ecbd86440e$export$10f55b5fe2f0ee58","$9d83a5ecbd86440e$export$38938fa8a3afa51d","$9d83a5ecbd86440e$export$13fac14d3ea80023","$9d83a5ecbd86440e$export$1c84988fe62ae4c9","$a4364a4b65f8973f$export$ef284b30650dc04c","m","fromBoard","subtract","some","hasPawns","hasNonPawns","$a4364a4b65f8973f$export$a2d8b23205c25948","count","$a4364a4b65f8973f$export$3f36e62a1e5d2e47","$9d83a5ecbd86440e$var$nthIndexOf","haystack","needle","index","indexOf","$9d83a5ecbd86440e$var$parseSmallUint","test","parseInt","$9d83a5ecbd86440e$var$charToPiece","ch","toLowerCase","boardPart","Board","pocketPart","Pockets","castlingPart","lower","Castling","rooksAndKings","part","parts","split","RemainingChecks","fen","endsWith","pocketStart","Fen","slice","turnPart","Turn","earlyRemainingChecks","epPart","EpSquare","halfmovePart","includes","Halfmoves","fullmovesPart","Fullmoves","remainingChecksPart","material","repeat","join","pocket","candidates","checks","opts","epd","$89afb1487ee9ea89$export$8f45430ccf837300","$89afb1487ee9ea89$export$3a444357c5f65f65","$89afb1487ee9ea89$export$d8e4e3952f325c95","$12cc5d8f1c8e91f5$export$978f7ef4c67d166e","$12cc5d8f1c8e91f5$export$ade7a30951d0bc54","concat","$12cc5d8f1c8e91f5$export$fe9f8b727818c0ae","$12cc5d8f1c8e91f5$export$e2878eba51f22d11","k","$12cc5d8f1c8e91f5$export$26773b74d67e09c2","$12cc5d8f1c8e91f5$export$9dc4ecf953986f04","startAt","start","performance","now","cancel","stop","time","$12cc5d8f1c8e91f5$export$a27c3a1c44ba515b","$12cc5d8f1c8e91f5$export$e4884e1734dcd545","pos1","pos2","dx","dy","$12cc5d8f1c8e91f5$export$e329b1a538c004fa","p1","p2","$12cc5d8f1c8e91f5$export$2135ad75550a2ff4","bounds","asWhite","width","height","$12cc5d8f1c8e91f5$export$d73ee8ef04f5226a","el","style","transform","$12cc5d8f1c8e91f5$export$f8afaca97e230dc6","scale","$12cc5d8f1c8e91f5$export$8cb512849e51eaf5","visibility","$12cc5d8f1c8e91f5$export$33052595192f7117","clientX","clientY","targetTouches","$12cc5d8f1c8e91f5$export$947a472b5b3020ba","button","$12cc5d8f1c8e91f5$export$3d7cd8ed57263b30","tagName","className","document","createElement","$12cc5d8f1c8e91f5$export$1c17f680299a31f7","key","left","top","$e201ff49adfb06e2$var$diff","$e201ff49adfb06e2$var$pawn","x1","y1","x2","y2","$e201ff49adfb06e2$export$5584fb45fd3a6d08","xd","yd","$e201ff49adfb06e2$var$bishop","$e201ff49adfb06e2$var$rook","$e201ff49adfb06e2$export$b9d1aa6d9cf991c6","$e201ff49adfb06e2$var$king","rookFiles","canCastle","$e201ff49adfb06e2$export$99ff1a176ab1ff90","mobility","$e201ff49adfb06e2$var$rookFilesOf","files","filter","$e9a4281a8a1ce8a6$export$6511920ae9f0cd34","args","setTimeout","$e9a4281a8a1ce8a6$export$f92a111f74a3f7c7","state","premovable","current","events","unset","$e9a4281a8a1ce8a6$export$9e6f418e5ea6b92c","pd","predroppable","$e9a4281a8a1ce8a6$export$13f6ca6271343510","orig","dest","origPiece","destPiece","selected","$e9a4281a8a1ce8a6$export$fe412c270a34f415","$e9a4281a8a1ce8a6$var$tryAutoCastle","autoCastle","origPos","destPos","delete","lastMove","check","change","$e9a4281a8a1ce8a6$export$13886f9573facc29","force","dropNewPiece","movable","turnColor","$e9a4281a8a1ce8a6$var$baseUserMove","result","animation","$e9a4281a8a1ce8a6$export$843c446e2e718822","$e9a4281a8a1ce8a6$export$a4ef2b0c3fa55ad2","holdTime","hold","metadata","premove","ctrlKey","stats","$e9a4281a8a1ce8a6$var$canPremove","validPremoves","customDests","castle","$e9a4281a8a1ce8a6$var$isPremovable","meta","$e9a4281a8a1ce8a6$export$b2b9f46b948033b0","$e9a4281a8a1ce8a6$var$canDrop","afterNewPiece","predrop","$e9a4281a8a1ce8a6$var$canPredrop","enabled","$e9a4281a8a1ce8a6$var$setPredrop","$e9a4281a8a1ce8a6$export$6073914ea697a63e","select","draggable","selectable","dragged","$e9a4281a8a1ce8a6$var$isMovable","$e9a4281a8a1ce8a6$export$5a4818cec1656a71","free","$e9a4281a8a1ce8a6$export$d04320a93cdae73d","success","$e9a4281a8a1ce8a6$export$e47a3d6268102bb5","$e9a4281a8a1ce8a6$export$fa6813432f753b0d","$e9a4281a8a1ce8a6$export$102bdd581884418b","floor","$e9a4281a8a1ce8a6$export$970133fdf67d86cb","orientation","$f02efaa0c4f5e00a$export$59ff82fc918bd7e3","$f02efaa0c4f5e00a$var$roles","p","q","$f02efaa0c4f5e00a$var$letters","$f02efaa0c4f5e00a$export$aafa59e2e03f2942","row","col","nb","$f210fdc398bed13f$export$d771543c4ed87064","config","$f210fdc398bed13f$var$deepMerge","duration","$f210fdc398bed13f$export$8d21e34596265fa2","_c","drawable","autoShapes","shapes","rookCastle","kingStartPos","base","extend","hasOwnProperty","$f210fdc398bed13f$var$isPlainObject","proto","getPrototypeOf","$eef2d951b1990073$export$bd46b8ab3689edc4","mutation","$eef2d951b1990073$var$animate","prevPieces","plan","$eef2d951b1990073$var$computePlan","curP","preP","vector","anims","animedOrigs","fadings","missings","news","prePieces","$eef2d951b1990073$var$makePiece","newP","$eef2d951b1990073$var$closer","alreadyRunning","frequency","$eef2d951b1990073$var$step","cur","dom","destroyed","redrawNow","rest","ease","$eef2d951b1990073$var$easing","cfg","values","requestAnimationFrame","redraw","$eef2d951b1990073$export$b3890eb0ae9dca99","sort","$ca7a5155221e62eb$var$brushes","$ca7a5155221e62eb$export$d947e5f4f4c48d48","$ca7a5155221e62eb$export$bd5df0f255a350f8","mouseSq","$ca7a5155221e62eb$var$addShape","sameShape","similar","find","brush","$ca7a5155221e62eb$var$onChange","$ca7a5155221e62eb$export$70b61ad426ddbe54","onChange","$d6c60d68c89e4d3b$var$processDrag","started","pow","distance","element","found","cgDragging","classList","keyHasChanged","$d6c60d68c89e4d3b$export$70b61ad426ddbe54","$d6c60d68c89e4d3b$export$d947e5f4f4c48d48","touches","$d6c60d68c89e4d3b$export$bd5df0f255a350f8","type","cancelable","preventDefault","originTarget","target","newPiece","deleteOnDropOff","previouslySelected","$d6c60d68c89e4d3b$var$removeDragElements","elements","ghost","$d6c60d68c89e4d3b$var$pieceElementByKey","firstChild","cgKey","nextSibling","$9838d65c005eac88$var$setStage","stage","exploding","$c530a7760a946b4a$var$hilites","hilitePrimary","opacity","lineWidth","hiliteWhite","$c530a7760a946b4a$var$shapeHash","modifiers","customSvg","label","shorten","x","hilite","$c530a7760a946b4a$var$textHash","html","text","toString","$c530a7760a946b4a$var$hilite","$c530a7760a946b4a$var$orient","$c530a7760a946b4a$var$isShort","$c530a7760a946b4a$export$c8a8987d4410bf2d","createElementNS","$c530a7760a946b4a$export$74da2cba014bdc09","attrs","setAttribute","$c530a7760a946b4a$var$makeCustomBrush","round","$c530a7760a946b4a$var$opacity","$c530a7760a946b4a$var$pos2user","xScale","yScale","$c530a7760a946b4a$var$moveAngle","asSlot","angle","atan2","PI","$c530a7760a946b4a$var$labelCoords","slots","mag","sqrt","reduce","acc","slot","cos","sin","$2dd2d8dceeead3a2$var$renderCoords","elems","elem","textContent","appendChild","$bb9a2d6168a64a48$var$unbindable","eventName","callback","options","addEventListener","removeEventListener","$bb9a2d6168a64a48$var$startDragOrDraw","shiftKey","$ca7a5155221e62eb$export$b3571188c770cc5a","stopPropagation","modA","modB","altKey","metaKey","getModifierState","snapToValidMove","defaultSnapToValidMove","$ca7a5155221e62eb$export$816e7b21815d9cf9","keyAtDomPos","validSnapPos","validSnapDistances","validSnapCenters","closestSnapIndex","viewOnly","dropmode","active","position","$d6c60d68c89e4d3b$export$b3571188c770cc5a","trustAllEvents","isTrusted","buttons","eraseOnClick","blockTouchScroll","$d6c60d68c89e4d3b$var$pieceCloseTo","radiusSq","hadPremove","hadPredrop","stillSelected","$e9a4281a8a1ce8a6$export$fe8f97248bbe2d04","autoDistance","$bb9a2d6168a64a48$var$dragOrDraw","withDrag","withDraw","$4bb5156c5d36bd23$export$f4467a4f41373bc7","wrap","getBoundingClientRect","container","ratio","window","devicePixelRatio","addDimensionsCssVarsTo","setProperty","$4bb5156c5d36bd23$var$isPieceNode","$4bb5156c5d36bd23$var$isSquareNode","$4bb5156c5d36bd23$var$removeNodes","nodes","node","removeChild","$4bb5156c5d36bd23$var$posZIndex","minZ","$4bb5156c5d36bd23$var$pieceNameOf","$4bb5156c5d36bd23$var$addSquare","squares","klass","classes","$4bb5156c5d36bd23$var$appendValue","arr","$54757388b7ad83d3$var$hash","autoPiece","$1625af68404aac73$var$heuristicEvaluation","chess","flatMap","certain","$1625af68404aac73$var$minMaxValueComparator","shouldMaximise","$1625af68404aac73$var$evaluateState","recursiveLimit","bestFutureState","rankedFutureStates","allMoves","$1625af68404aac73$var$memoEvaluateStateForPlayer","$1625af68404aac73$var$memoedEvaluations","memoKey","makeBoardFen","realEvaluation","$1625af68404aac73$export$295d986d08d83031","rankedMoves","evaluation","bestMove","equalBestMoves","random","$253ce2a319769a4a$var$toPlayDisplay","querySelector","$253ce2a319769a4a$var$fenForm","$253ce2a319769a4a$var$fenInput","$253ce2a319769a4a$var$bestMoveDisplay","$253ce2a319769a4a$var$chess","$253ce2a319769a4a$var$board","maybeState","coordinates","coordinatesOnSquares","ranksPosition","disableContextMenu","addPieceZIndex","pieceKey","highlight","showDests","showGhost","visible","brushes","green","red","blue","yellow","paleBlue","paleGreen","paleRed","paleGrey","purple","pink","prevSvgHash","redrawAll","redrawing","prevUnbind","unbind","svg","autoPieces","innerHTML","class","viewBox","preserveAspectRatio","defs","id","stdDeviation","orientClass","ranksPositionClass","rankN","forEach","$12cc5d8f1c8e91f5$export$7c73462e0d25e514","ret","skipSvg","pieceAtKey","elPieceName","anim","fading","pMvdset","pMvd","sMvdset","sMvd","posToTranslate","boardEl","curAnim","curDrag","$4bb5156c5d36bd23$var$computeSquareClasses","pDests","custom","samePieces","Set","sameSquares","movedPieces","movedSquares","cgPiece","remove","cgFading","cgAnimating","zIndex","cn","sk","pop","translation","squareNode","insertBefore","pieceName","pieceNode","$54757388b7ad83d3$export$b3890eb0ae9dca99","autoPieceEl","root","renderShape","hashesInDom","toRemove","sc","hash","firstElementChild","elHash","getAttribute","nextElementSibling","autoShape","shape","$54757388b7ad83d3$var$renderShape","pieceEl","cgScale","$c530a7760a946b4a$export$fb80b1b7d7777ee5","shapesEl","customsEl","curD","nonPieceAutoShapes","sources","fullHash","$c530a7760a946b4a$var$syncDefs","defsEl","keysInDom","entries","$c530a7760a946b4a$var$renderMarker","marker","orient","overflow","markerWidth","markerHeight","refX","startsWith","refY","fill","$c530a7760a946b4a$var$syncShapes","syncables","customs","isCustom","$c530a7760a946b4a$var$renderShape","svgs","cgHash","$c530a7760a946b4a$var$renderArrow","renderLine","isHilite","xo","yo","stroke","$c530a7760a946b4a$var$lineWidth","g","blurred","$c530a7760a946b4a$var$filterBox","box","ceil","y","$c530a7760a946b4a$var$renderCircle","at","widths","radius","cx","cy","corner","$c530a7760a946b4a$var$renderLabel","fontSize","labelSize","cornerOff","labelEl","onResize","$54757388b7ad83d3$export$d62f185fd39aa98c","$bb9a2d6168a64a48$export$fc48d2ed06541843","ResizeObserver","observe","onStart","passive","$bb9a2d6168a64a48$export$fdc77453278b0fa9","unbinds","body","onmove","onend","ev","onScroll","insert","toggleOrientation","getFen","replace","setPieces","$e9a4281a8a1ce8a6$export$20a063d1402ff7ff","selectSquare","playPremove","playPredrop","$e9a4281a8a1ce8a6$export$8efa9460c0cedd9e","drop","cancelPremove","cancelPredrop","cancelMove","explode","setAutoShapes","setShapes","getKeyAtDomPos","dragNewPiece","event","destroy","parseFen","console","Result","_Result","_proto","_Ok","this","_Result2","_this","_inheritsLoose","_err","_Err","_Result3","_this2","_ok","obj","item","res","_i","_item"],"version":3,"file":"index.082a427f.js.map"}